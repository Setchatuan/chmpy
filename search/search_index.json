{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"chmpy A library for computational chemistry in python. Featuring support for molecules, crystals, Hirshfeld & promolecule density isosurfaces, spherical harmonic shape descriptors and much more... Features While the library is intended to be flexible and make it easy to build complex pipelines or properties, the following is a brief summary of intended features: Load crystal structures from .cif , .res , POSCAR files, and molecules from .xyz , .sdf files. Evaluate promolecule and procrystal electron densities. Easily generate Hirshfeld or promolecule isosurfaces and associated properties. Easily generate spherical harmonic shape descriptors for atoms, molecules, or molecular fragments. Efficiently calculate crystal slabs, periodic connectivity and more... It should also serve as a simple, easy to read library for learning how to represent crystal structures, molecules etc. and evaluate scientifically relevant information quickly and efficiently using python. At a glance Crystal structures and molecules Loading a crystal structure from a CIF ( .cif ) or SHELX ( .res ) file, or a molecule from an XMOL ( .xyz ) file is straightforward: >>> from chmpy import Crystal , Molecule >>> c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) >>> c < Crystal C2H4O2 Pna2_1 > # Calculate the unique molecules in this crystal >>> c . symmetry_unique_molecules () [ < Molecule : C2H4O2 ( 2.12 , 1.15 , 0.97 ) > ] >>> m = Molecule . load ( \"tests/test_files/water.xyz\" ) >>> m < Molecule : H2O ( - 0.67 , - 0.00 , 0.01 ) > Hirshfeld and promolecule density isosurfaces Generation of surfaces with the default settings can be done with minimal hassle, simply by using the corresponding members of the Crystal class: >>> c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # This will generate a high resolution surface # for each symmetry unique molecule in the crystal >>> surfaces = c . hirshfeld_surfaces () >>> surfaces [ < trimesh . Trimesh ( vertices . shape = ( 3598 , 3 ), faces . shape = ( 7192 , 3 )) > ] # We can generate lower resolution surfaces with the separation parameter >>> surfaces = c . hirshfeld_surfaces ( separation = 0.5 ) >>> surfaces [ < trimesh . Trimesh ( vertices . shape = ( 584 , 3 ), faces . shape = ( 1164 , 3 )) > ] # Surfaces can be saved via trimesh >>> surfaces [ 0 ] . export ( \"acetic_acid_trimesh.ply\" , \"ply\" ) # or a utility function provided in chmpy >>> from chmpy.util.mesh import save_mesh >>> save_mesh ( surfaces [ 0 ], \"acetic_acid.ply\" )","title":"Home"},{"location":"#chmpy","text":"A library for computational chemistry in python. Featuring support for molecules, crystals, Hirshfeld & promolecule density isosurfaces, spherical harmonic shape descriptors and much more...","title":"chmpy"},{"location":"#features","text":"While the library is intended to be flexible and make it easy to build complex pipelines or properties, the following is a brief summary of intended features: Load crystal structures from .cif , .res , POSCAR files, and molecules from .xyz , .sdf files. Evaluate promolecule and procrystal electron densities. Easily generate Hirshfeld or promolecule isosurfaces and associated properties. Easily generate spherical harmonic shape descriptors for atoms, molecules, or molecular fragments. Efficiently calculate crystal slabs, periodic connectivity and more... It should also serve as a simple, easy to read library for learning how to represent crystal structures, molecules etc. and evaluate scientifically relevant information quickly and efficiently using python.","title":"Features"},{"location":"#at-a-glance","text":"","title":"At a glance"},{"location":"#crystal-structures-and-molecules","text":"Loading a crystal structure from a CIF ( .cif ) or SHELX ( .res ) file, or a molecule from an XMOL ( .xyz ) file is straightforward: >>> from chmpy import Crystal , Molecule >>> c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) >>> c < Crystal C2H4O2 Pna2_1 > # Calculate the unique molecules in this crystal >>> c . symmetry_unique_molecules () [ < Molecule : C2H4O2 ( 2.12 , 1.15 , 0.97 ) > ] >>> m = Molecule . load ( \"tests/test_files/water.xyz\" ) >>> m < Molecule : H2O ( - 0.67 , - 0.00 , 0.01 ) >","title":"Crystal structures and molecules"},{"location":"#hirshfeld-and-promolecule-density-isosurfaces","text":"Generation of surfaces with the default settings can be done with minimal hassle, simply by using the corresponding members of the Crystal class: >>> c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # This will generate a high resolution surface # for each symmetry unique molecule in the crystal >>> surfaces = c . hirshfeld_surfaces () >>> surfaces [ < trimesh . Trimesh ( vertices . shape = ( 3598 , 3 ), faces . shape = ( 7192 , 3 )) > ] # We can generate lower resolution surfaces with the separation parameter >>> surfaces = c . hirshfeld_surfaces ( separation = 0.5 ) >>> surfaces [ < trimesh . Trimesh ( vertices . shape = ( 584 , 3 ), faces . shape = ( 1164 , 3 )) > ] # Surfaces can be saved via trimesh >>> surfaces [ 0 ] . export ( \"acetic_acid_trimesh.ply\" , \"ply\" ) # or a utility function provided in chmpy >>> from chmpy.util.mesh import save_mesh >>> save_mesh ( surfaces [ 0 ], \"acetic_acid.ply\" )","title":"Hirshfeld and promolecule density isosurfaces"},{"location":"parallel/","text":"Parallelization Some of the Cython code in chmpy makes use of OpenMP parallelism. If this is interfering with your own parallelism at a higher level, or you simply wish to modify how many cores the code should make use of, consider setting the environment variable OMP_NUM_THREADS to the desired number of threads. export OMP_NUM_THREADS = 1","title":"Notes on Parallelization"},{"location":"parallel/#parallelization","text":"Some of the Cython code in chmpy makes use of OpenMP parallelism. If this is interfering with your own parallelism at a higher level, or you simply wish to modify how many cores the code should make use of, consider setting the environment variable OMP_NUM_THREADS to the desired number of threads. export OMP_NUM_THREADS = 1","title":"Parallelization"},{"location":"shape_descriptors/","text":"Shape descriptors What they are A rotation invariant description of a shape. In essence, these are rotation invariants calculated from the coefficients of the spherical harmonic transform of a shape function, which in our case is either the radius (distance from the origin) of an isosurface as a function of the spherical angles theta and phi. References: PR Spackman et al. Sci. Rep. 6, 22204 (2016) PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) How to calculate shape descriptors Molecules in crystals from chmpy import Crystal c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # calculate shape descriptors for each molecule in the asymmetric unit desc = c . molecular_shape_descriptors () Atoms in crystals Likewise, atomic shape descriptors can be conveniently calculated directly from the Crystal object: from chmpy import Crystal c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # calculate shape descriptors for each atom in the asymmetric unit desc = c . atomic_shape_descriptors () Isolated molecules Hirshfeld surfaces typically only have a sensible definition in a crystal (or at least in a environment where the molecule is not isolated). As such, the more sensible descriptor to utilise may be one of the Promolecule density isosurface . This can be readily calculated using the Molecule object: from chmpy import Molecule m = Molecule . load ( \"tests/test_files/water.xyz\" ) desc = m . shape_descriptors () # use EEM calculated charges to describe the shape and the ESP # up to maximum angular momentum 16 desc_with_esp = m . shape_descriptors ( l_max = 16 , with_property = \"esp\" ) However, another useful descriptor of atomic environments is a Hirshfeld-type descriptor in a molecule, where in order to 'close' the exterior of the surface we introduce a background density, as follows: from chmpy import Molecule m = Molecule . load ( \"tests/test_files/water.xyz\" ) # with the default background density desc = m . atomic_shape_descriptors () # or with, a larger background density, contracting the atoms desc = m . atomic_shape_descriptors ( background = 0.0001 )","title":"Shape Descriptors"},{"location":"shape_descriptors/#shape-descriptors","text":"","title":"Shape descriptors"},{"location":"shape_descriptors/#what-they-are","text":"A rotation invariant description of a shape. In essence, these are rotation invariants calculated from the coefficients of the spherical harmonic transform of a shape function, which in our case is either the radius (distance from the origin) of an isosurface as a function of the spherical angles theta and phi.","title":"What they are"},{"location":"shape_descriptors/#references","text":"PR Spackman et al. Sci. Rep. 6, 22204 (2016) PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)","title":"References:"},{"location":"shape_descriptors/#how-to-calculate-shape-descriptors","text":"","title":"How to calculate shape descriptors"},{"location":"shape_descriptors/#molecules-in-crystals","text":"from chmpy import Crystal c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # calculate shape descriptors for each molecule in the asymmetric unit desc = c . molecular_shape_descriptors ()","title":"Molecules in crystals"},{"location":"shape_descriptors/#atoms-in-crystals","text":"Likewise, atomic shape descriptors can be conveniently calculated directly from the Crystal object: from chmpy import Crystal c = Crystal . load ( \"tests/test_files/acetic_acid.cif\" ) # calculate shape descriptors for each atom in the asymmetric unit desc = c . atomic_shape_descriptors ()","title":"Atoms in crystals"},{"location":"shape_descriptors/#isolated-molecules","text":"Hirshfeld surfaces typically only have a sensible definition in a crystal (or at least in a environment where the molecule is not isolated). As such, the more sensible descriptor to utilise may be one of the Promolecule density isosurface . This can be readily calculated using the Molecule object: from chmpy import Molecule m = Molecule . load ( \"tests/test_files/water.xyz\" ) desc = m . shape_descriptors () # use EEM calculated charges to describe the shape and the ESP # up to maximum angular momentum 16 desc_with_esp = m . shape_descriptors ( l_max = 16 , with_property = \"esp\" ) However, another useful descriptor of atomic environments is a Hirshfeld-type descriptor in a molecule, where in order to 'close' the exterior of the surface we introduce a background density, as follows: from chmpy import Molecule m = Molecule . load ( \"tests/test_files/water.xyz\" ) # with the default background density desc = m . atomic_shape_descriptors () # or with, a larger background density, contracting the atoms desc = m . atomic_shape_descriptors ( background = 0.0001 )","title":"Isolated molecules"},{"location":"API/sampling/","text":"This module is dedicated to sampling points, sequences and generation of random or quasi random object. quasirandom ( d1 , d2 = None , method = 'sobol' , seed = 1 ) Generate a quasirandom point, or sequence of points with coefficients in the interval [0, 1]. Parameters: Name Type Description Default d1 int number of points to generate (or number of dimensions if d2 is not provided) required d2 int number of dimensions None method str use the 'sobol' or 'kgf' sequences to generate points 'sobol' seed int start seed for the sequence of numbers. if more than 1 point is generated then the seeds will be in the range [seed, seed + d1 -1] corresponding to each point in the resulting sequence. 1 Returns: Type Description ndarray np.ndarray: The sequence of quasirandom vectors Source code in chmpy/sampling/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def quasirandom ( d1 : int , d2 = None , method = \"sobol\" , seed = 1 ) -> np . ndarray : \"\"\" Generate a quasirandom point, or sequence of points with coefficients in the interval [0, 1]. Args: d1 (int): number of points to generate (or number of dimensions if d2 is not provided) d2 (int, optional): number of dimensions method (str, optional): use the 'sobol' or 'kgf' sequences to generate points seed (int, optional): start seed for the sequence of numbers. if more than 1 point is generated then the seeds will be in the range [seed, seed + d1 -1] corresponding to each point in the resulting sequence. Returns: np.ndarray: The sequence of quasirandom vectors \"\"\" if d2 is None : return _SINGLE [ method ]( seed , d1 ) else : return _BATCH [ method ]( seed , seed + d1 - 1 , d2 ) point_mapper SamplingPointMapperMeta Abstract base class of a sampling point mapper","title":"Quasirandom Sampling"},{"location":"API/sampling/#chmpy.sampling","text":"This module is dedicated to sampling points, sequences and generation of random or quasi random object.","title":"chmpy.sampling"},{"location":"API/sampling/#chmpy.sampling.quasirandom","text":"Generate a quasirandom point, or sequence of points with coefficients in the interval [0, 1]. Parameters: Name Type Description Default d1 int number of points to generate (or number of dimensions if d2 is not provided) required d2 int number of dimensions None method str use the 'sobol' or 'kgf' sequences to generate points 'sobol' seed int start seed for the sequence of numbers. if more than 1 point is generated then the seeds will be in the range [seed, seed + d1 -1] corresponding to each point in the resulting sequence. 1 Returns: Type Description ndarray np.ndarray: The sequence of quasirandom vectors Source code in chmpy/sampling/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def quasirandom ( d1 : int , d2 = None , method = \"sobol\" , seed = 1 ) -> np . ndarray : \"\"\" Generate a quasirandom point, or sequence of points with coefficients in the interval [0, 1]. Args: d1 (int): number of points to generate (or number of dimensions if d2 is not provided) d2 (int, optional): number of dimensions method (str, optional): use the 'sobol' or 'kgf' sequences to generate points seed (int, optional): start seed for the sequence of numbers. if more than 1 point is generated then the seeds will be in the range [seed, seed + d1 -1] corresponding to each point in the resulting sequence. Returns: np.ndarray: The sequence of quasirandom vectors \"\"\" if d2 is None : return _SINGLE [ method ]( seed , d1 ) else : return _BATCH [ method ]( seed , seed + d1 - 1 , d2 )","title":"quasirandom()"},{"location":"API/sampling/#chmpy.sampling.point_mapper","text":"","title":"point_mapper"},{"location":"API/sampling/#chmpy.sampling.point_mapper.SamplingPointMapperMeta","text":"Abstract base class of a sampling point mapper","title":"SamplingPointMapperMeta"},{"location":"API/shape_descriptors/","text":"make_invariants ( l_max , coefficients , kinds = 'NP' , real = True ) Construct the N and/or P type invariants from SHT coefficients. Parameters: Name Type Description Default l_max int the maximum angular momentum of the coefficients required coefficients np.ndarray the set of spherical harmonic coefficients required kinds str which kinds of invariants to include 'NP' real bool whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) True Returns: Type Description ndarray np.ndarray the N and/or P type rotational invariants based on these coefficients Source code in chmpy/shape/shape_descriptors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def make_invariants ( l_max , coefficients , kinds = \"NP\" , real = True ) -> np . ndarray : \"\"\" Construct the `N` and/or `P` type invariants from SHT coefficients. Arguments: l_max (int): the maximum angular momentum of the coefficients coefficients (np.ndarray): the set of spherical harmonic coefficients kinds (str, optional): which kinds of invariants to include real (bool, optional): whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) Returns: np.ndarray the `N` and/or `P` type rotational invariants based on these coefficients \"\"\" global _HAVE_WARNED_ABOUT_LMAX_P invariants = [] if \"N\" in kinds : invariants . append ( make_N_invariants ( coefficients , real = real )) if \"P\" in kinds : # Because we only have factorial precision (double precision) # in our clebsch implementation up to 70! l_max for P type # invariants is restricted to <= 23 # TODO use a better clebsch gordan coefficients implementation # e.g. that in https://github.com/GXhelsinki/Clebsch-Gordan-Coefficients- pfunc = p_invariants_r if real else p_invariants_c MAX_L_MAX = 23 if l_max > MAX_L_MAX : if not _HAVE_WARNED_ABOUT_LMAX_P : LOG . warn ( f \"P type invariants only supported up to l_max = { MAX_L_MAX } : \" \"will only using N type invariants beyond that.\" ) _HAVE_WARNED_ABOUT_LMAX_P = True if real : c = coefficients [: (( MAX_L_MAX + 2 ) * ( MAX_L_MAX + 1 )) // 2 ] else : c = coefficients [: ( MAX_L_MAX * MAX_L_MAX )] invariants . append ( pfunc ( c )) else : invariants . append ( pfunc ( coefficients )) return np . hstack ( invariants ) make_N_invariants ( coefficients , real = True ) Construct the N type invariants from SHT coefficients. If coefficients is of length n, the size of the result will be sqrt(n) Parameters: Name Type Description Default coefficients np.ndarray the set of spherical harmonic coefficients required real bool whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) True Returns: Type Description ndarray np.ndarray the N type rotational invariants based on these coefficients Source code in chmpy/shape/shape_descriptors.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def make_N_invariants ( coefficients , real = True ) -> np . ndarray : \"\"\" Construct the `N` type invariants from SHT coefficients. If coefficients is of length n, the size of the result will be sqrt(n) Arguments: coefficients (np.ndarray): the set of spherical harmonic coefficients real (bool, optional): whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) Returns: np.ndarray the `N` type rotational invariants based on these coefficients \"\"\" if real : # n = (l_max +2)(l_max+1)/2 n = len ( coefficients ) size = int (( - 3 + np . sqrt ( 8 * n + 1 )) // 2 ) + 1 lower = 0 invariants = np . empty ( shape = ( size ), dtype = np . float64 ) for i in range ( 0 , size ): x = i + 1 upper = lower + x invariants [ i ] = np . sum ( coefficients [ lower : upper + 1 ] * np . conj ( coefficients [ lower : upper + 1 ]) ) . real lower += x else : size = int ( np . sqrt ( len ( coefficients ))) invariants = np . empty ( shape = ( size ), dtype = np . float64 ) for i in range ( 0 , size ): lower , upper = i ** 2 , ( i + 1 ) ** 2 invariants [ i ] = np . sum ( coefficients [ lower : upper + 1 ] * np . conj ( coefficients [ lower : upper + 1 ]) ) . real return np . sqrt ( invariants ) promolecule_density_descriptor ( sht , n_i , p_i , ** kwargs ) Calculate the shape description of the promolecule density isosurface. Parameters: Name Type Description Default sht SHT the spherical harmonic transform object handle required n_i np.ndarray atomic numbers of the atoms required p_i np.ndarray Cartesian coordinates of the atoms required kwargs dict keyword arguments for optional settings. Options include: isovalue (float): change the Hirshfeld weight value (default 0.5) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the atoms) kinds (str): the kinds of invariants to calculate (default 'NP') {} Returns: Type Description np.ndarray the rotation invariant descriptors of the promolecule surface shape Source code in chmpy/shape/shape_descriptors.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def promolecule_density_descriptor ( sht , n_i , p_i , ** kwargs ): \"\"\" Calculate the shape description of the promolecule density isosurface. Args: sht (SHT): the spherical harmonic transform object handle n_i (np.ndarray): atomic numbers of the atoms p_i (np.ndarray): Cartesian coordinates of the atoms kwargs (dict): keyword arguments for optional settings. Options include: ``` isovalue (float): change the Hirshfeld weight value (default 0.5) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the atoms) kinds (str): the kinds of invariants to calculate (default 'NP') ``` Returns: np.ndarray: the rotation invariant descriptors of the promolecule surface shape \"\"\" isovalue = kwargs . get ( \"isovalue\" , 0.0002 ) property_function = kwargs . get ( \"with_property\" , None ) r_min , r_max = kwargs . get ( \"bounds\" , ( 0.4 , 20.0 )) pro = PromoleculeDensity (( n_i , p_i )) g = np . empty ( sht . grid . shape , dtype = np . float32 ) g [:, :] = sht . grid [:, :] o = kwargs . get ( \"origin\" , np . mean ( p_i , axis = 0 , dtype = np . float32 )) r = sphere_promolecule_radii ( pro . dens , o , g , r_min , r_max , 1e-7 , 30 , isovalue ) real = True if property_function is not None : if property_function == \"d_norm\" : property_function = lambda x : pro . d_norm ( x )[ 1 ] elif property_function == \"esp\" : from chmpy import Molecule els = pro . elements pos = pro . positions property_function = Molecule . from_arrays ( els , pos ) . electrostatic_potential xyz = sht . grid_cartesian * r [:, np . newaxis ] prop_values = property_function ( xyz ) r_cplx = np . empty ( r . shape , dtype = np . complex128 ) r_cplx . real = r r_cplx . imag = prop_values r = r_cplx real = False l_max = sht . l_max coeffs = sht . analyse ( r ) invariants = make_invariants ( l_max , coeffs , kinds = kwargs . get ( \"kinds\" , \"NP\" ), real = real ) if kwargs . get ( \"coefficients\" , False ): return coeffs , invariants return invariants stockholder_weight_descriptor ( sht , n_i , p_i , n_e , p_e , ** kwargs ) Calculate the 'stockholder weight' shape descriptors based on the Hirshfeld weight i.e. ratio of electron density from the 'interior' to the total electron density. Parameters: Name Type Description Default sht SHT the spherical harmonic transform object handle required n_i np.ndarray atomic numbers of the interior atoms required p_i np.ndarray Cartesian coordinates of the interior atoms required n_e np.ndarray atomic numbers of the exterior atoms required p_e np.ndarray Cartesian coordinates of the exterior atoms required kwargs dict keyword arguments for optional settings. Options include: isovalue (float): change the Hirshfeld weight value (default 0.5) background (float): include an optional 'background' electron density (default 0.0) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the interior atoms) kinds (str): the kinds of invariants to calculate (default 'NP') {} Returns: Type Description np.ndarray the rotation invariant descriptors of the Hirshfeld surface shape Source code in chmpy/shape/shape_descriptors.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def stockholder_weight_descriptor ( sht , n_i , p_i , n_e , p_e , ** kwargs ): \"\"\" Calculate the 'stockholder weight' shape descriptors based on the Hirshfeld weight i.e. ratio of electron density from the 'interior' to the total electron density. Args: sht (SHT): the spherical harmonic transform object handle n_i (np.ndarray): atomic numbers of the interior atoms p_i (np.ndarray): Cartesian coordinates of the interior atoms n_e (np.ndarray): atomic numbers of the exterior atoms p_e (np.ndarray): Cartesian coordinates of the exterior atoms kwargs (dict): keyword arguments for optional settings. Options include: ``` isovalue (float): change the Hirshfeld weight value (default 0.5) background (float): include an optional 'background' electron density (default 0.0) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the interior atoms) kinds (str): the kinds of invariants to calculate (default 'NP') ``` Returns: np.ndarray: the rotation invariant descriptors of the Hirshfeld surface shape \"\"\" isovalue = kwargs . get ( \"isovalue\" , 0.5 ) background = kwargs . get ( \"background\" , 0.0 ) property_function = kwargs . get ( \"with_property\" , None ) r_min , r_max = kwargs . get ( \"bounds\" , ( 0.1 , 20.0 )) s = StockholderWeight . from_arrays ( n_i , p_i , n_e , p_e , background = background ) g = np . empty ( sht . grid . shape , dtype = np . float32 ) g [:, :] = sht . grid [:, :] o = kwargs . get ( \"origin\" , np . mean ( p_i , axis = 0 , dtype = np . float32 )) r = sphere_stockholder_radii ( s . s , o , g , r_min , r_max , 1e-7 , 30 , isovalue ) real = True if property_function is not None : if property_function == \"d_norm\" : property_function = s . d_norm elif property_function == \"esp\" : from chmpy import Molecule els = s . dens_a . elements pos = s . dens_a . positions property_function = Molecule . from_arrays ( s . dens_a . elements , s . dens_a . positions ) . electrostatic_potential xyz = sht . grid_cartesian * r [:, np . newaxis ] prop_values = property_function ( xyz ) r_cplx = np . empty ( r . shape , dtype = np . complex128 ) r_cplx . real = r r_cplx . imag = prop_values r = r_cplx real = False l_max = sht . l_max coeffs = sht . analyse ( r ) invariants = make_invariants ( l_max , coeffs , kinds = kwargs . get ( \"kinds\" , \"NP\" ), real = real ) if kwargs . get ( \"coefficients\" , False ): return coeffs , invariants return invariants","title":"Shape Descriptors"},{"location":"API/shape_descriptors/#chmpy.shape.shape_descriptors","text":"","title":"chmpy.shape.shape_descriptors"},{"location":"API/shape_descriptors/#chmpy.shape.shape_descriptors.make_invariants","text":"Construct the N and/or P type invariants from SHT coefficients. Parameters: Name Type Description Default l_max int the maximum angular momentum of the coefficients required coefficients np.ndarray the set of spherical harmonic coefficients required kinds str which kinds of invariants to include 'NP' real bool whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) True Returns: Type Description ndarray np.ndarray the N and/or P type rotational invariants based on these coefficients Source code in chmpy/shape/shape_descriptors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def make_invariants ( l_max , coefficients , kinds = \"NP\" , real = True ) -> np . ndarray : \"\"\" Construct the `N` and/or `P` type invariants from SHT coefficients. Arguments: l_max (int): the maximum angular momentum of the coefficients coefficients (np.ndarray): the set of spherical harmonic coefficients kinds (str, optional): which kinds of invariants to include real (bool, optional): whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) Returns: np.ndarray the `N` and/or `P` type rotational invariants based on these coefficients \"\"\" global _HAVE_WARNED_ABOUT_LMAX_P invariants = [] if \"N\" in kinds : invariants . append ( make_N_invariants ( coefficients , real = real )) if \"P\" in kinds : # Because we only have factorial precision (double precision) # in our clebsch implementation up to 70! l_max for P type # invariants is restricted to <= 23 # TODO use a better clebsch gordan coefficients implementation # e.g. that in https://github.com/GXhelsinki/Clebsch-Gordan-Coefficients- pfunc = p_invariants_r if real else p_invariants_c MAX_L_MAX = 23 if l_max > MAX_L_MAX : if not _HAVE_WARNED_ABOUT_LMAX_P : LOG . warn ( f \"P type invariants only supported up to l_max = { MAX_L_MAX } : \" \"will only using N type invariants beyond that.\" ) _HAVE_WARNED_ABOUT_LMAX_P = True if real : c = coefficients [: (( MAX_L_MAX + 2 ) * ( MAX_L_MAX + 1 )) // 2 ] else : c = coefficients [: ( MAX_L_MAX * MAX_L_MAX )] invariants . append ( pfunc ( c )) else : invariants . append ( pfunc ( coefficients )) return np . hstack ( invariants )","title":"make_invariants()"},{"location":"API/shape_descriptors/#chmpy.shape.shape_descriptors.make_N_invariants","text":"Construct the N type invariants from SHT coefficients. If coefficients is of length n, the size of the result will be sqrt(n) Parameters: Name Type Description Default coefficients np.ndarray the set of spherical harmonic coefficients required real bool whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) True Returns: Type Description ndarray np.ndarray the N type rotational invariants based on these coefficients Source code in chmpy/shape/shape_descriptors.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def make_N_invariants ( coefficients , real = True ) -> np . ndarray : \"\"\" Construct the `N` type invariants from SHT coefficients. If coefficients is of length n, the size of the result will be sqrt(n) Arguments: coefficients (np.ndarray): the set of spherical harmonic coefficients real (bool, optional): whether to assume the coefficients are from a real SHT (true) or a complex SHT (false) Returns: np.ndarray the `N` type rotational invariants based on these coefficients \"\"\" if real : # n = (l_max +2)(l_max+1)/2 n = len ( coefficients ) size = int (( - 3 + np . sqrt ( 8 * n + 1 )) // 2 ) + 1 lower = 0 invariants = np . empty ( shape = ( size ), dtype = np . float64 ) for i in range ( 0 , size ): x = i + 1 upper = lower + x invariants [ i ] = np . sum ( coefficients [ lower : upper + 1 ] * np . conj ( coefficients [ lower : upper + 1 ]) ) . real lower += x else : size = int ( np . sqrt ( len ( coefficients ))) invariants = np . empty ( shape = ( size ), dtype = np . float64 ) for i in range ( 0 , size ): lower , upper = i ** 2 , ( i + 1 ) ** 2 invariants [ i ] = np . sum ( coefficients [ lower : upper + 1 ] * np . conj ( coefficients [ lower : upper + 1 ]) ) . real return np . sqrt ( invariants )","title":"make_N_invariants()"},{"location":"API/shape_descriptors/#chmpy.shape.shape_descriptors.promolecule_density_descriptor","text":"Calculate the shape description of the promolecule density isosurface. Parameters: Name Type Description Default sht SHT the spherical harmonic transform object handle required n_i np.ndarray atomic numbers of the atoms required p_i np.ndarray Cartesian coordinates of the atoms required kwargs dict keyword arguments for optional settings. Options include: isovalue (float): change the Hirshfeld weight value (default 0.5) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the atoms) kinds (str): the kinds of invariants to calculate (default 'NP') {} Returns: Type Description np.ndarray the rotation invariant descriptors of the promolecule surface shape Source code in chmpy/shape/shape_descriptors.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def promolecule_density_descriptor ( sht , n_i , p_i , ** kwargs ): \"\"\" Calculate the shape description of the promolecule density isosurface. Args: sht (SHT): the spherical harmonic transform object handle n_i (np.ndarray): atomic numbers of the atoms p_i (np.ndarray): Cartesian coordinates of the atoms kwargs (dict): keyword arguments for optional settings. Options include: ``` isovalue (float): change the Hirshfeld weight value (default 0.5) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the atoms) kinds (str): the kinds of invariants to calculate (default 'NP') ``` Returns: np.ndarray: the rotation invariant descriptors of the promolecule surface shape \"\"\" isovalue = kwargs . get ( \"isovalue\" , 0.0002 ) property_function = kwargs . get ( \"with_property\" , None ) r_min , r_max = kwargs . get ( \"bounds\" , ( 0.4 , 20.0 )) pro = PromoleculeDensity (( n_i , p_i )) g = np . empty ( sht . grid . shape , dtype = np . float32 ) g [:, :] = sht . grid [:, :] o = kwargs . get ( \"origin\" , np . mean ( p_i , axis = 0 , dtype = np . float32 )) r = sphere_promolecule_radii ( pro . dens , o , g , r_min , r_max , 1e-7 , 30 , isovalue ) real = True if property_function is not None : if property_function == \"d_norm\" : property_function = lambda x : pro . d_norm ( x )[ 1 ] elif property_function == \"esp\" : from chmpy import Molecule els = pro . elements pos = pro . positions property_function = Molecule . from_arrays ( els , pos ) . electrostatic_potential xyz = sht . grid_cartesian * r [:, np . newaxis ] prop_values = property_function ( xyz ) r_cplx = np . empty ( r . shape , dtype = np . complex128 ) r_cplx . real = r r_cplx . imag = prop_values r = r_cplx real = False l_max = sht . l_max coeffs = sht . analyse ( r ) invariants = make_invariants ( l_max , coeffs , kinds = kwargs . get ( \"kinds\" , \"NP\" ), real = real ) if kwargs . get ( \"coefficients\" , False ): return coeffs , invariants return invariants","title":"promolecule_density_descriptor()"},{"location":"API/shape_descriptors/#chmpy.shape.shape_descriptors.stockholder_weight_descriptor","text":"Calculate the 'stockholder weight' shape descriptors based on the Hirshfeld weight i.e. ratio of electron density from the 'interior' to the total electron density. Parameters: Name Type Description Default sht SHT the spherical harmonic transform object handle required n_i np.ndarray atomic numbers of the interior atoms required p_i np.ndarray Cartesian coordinates of the interior atoms required n_e np.ndarray atomic numbers of the exterior atoms required p_e np.ndarray Cartesian coordinates of the exterior atoms required kwargs dict keyword arguments for optional settings. Options include: isovalue (float): change the Hirshfeld weight value (default 0.5) background (float): include an optional 'background' electron density (default 0.0) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the interior atoms) kinds (str): the kinds of invariants to calculate (default 'NP') {} Returns: Type Description np.ndarray the rotation invariant descriptors of the Hirshfeld surface shape Source code in chmpy/shape/shape_descriptors.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def stockholder_weight_descriptor ( sht , n_i , p_i , n_e , p_e , ** kwargs ): \"\"\" Calculate the 'stockholder weight' shape descriptors based on the Hirshfeld weight i.e. ratio of electron density from the 'interior' to the total electron density. Args: sht (SHT): the spherical harmonic transform object handle n_i (np.ndarray): atomic numbers of the interior atoms p_i (np.ndarray): Cartesian coordinates of the interior atoms n_e (np.ndarray): atomic numbers of the exterior atoms p_e (np.ndarray): Cartesian coordinates of the exterior atoms kwargs (dict): keyword arguments for optional settings. Options include: ``` isovalue (float): change the Hirshfeld weight value (default 0.5) background (float): include an optional 'background' electron density (default 0.0) with_property (str): calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp) bounds (Tuple): modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0) coefficients (bool): also return the coefficients of the SHT origin (np.ndarray): specify the center of the surface (default is the geometric centroid of the interior atoms) kinds (str): the kinds of invariants to calculate (default 'NP') ``` Returns: np.ndarray: the rotation invariant descriptors of the Hirshfeld surface shape \"\"\" isovalue = kwargs . get ( \"isovalue\" , 0.5 ) background = kwargs . get ( \"background\" , 0.0 ) property_function = kwargs . get ( \"with_property\" , None ) r_min , r_max = kwargs . get ( \"bounds\" , ( 0.1 , 20.0 )) s = StockholderWeight . from_arrays ( n_i , p_i , n_e , p_e , background = background ) g = np . empty ( sht . grid . shape , dtype = np . float32 ) g [:, :] = sht . grid [:, :] o = kwargs . get ( \"origin\" , np . mean ( p_i , axis = 0 , dtype = np . float32 )) r = sphere_stockholder_radii ( s . s , o , g , r_min , r_max , 1e-7 , 30 , isovalue ) real = True if property_function is not None : if property_function == \"d_norm\" : property_function = s . d_norm elif property_function == \"esp\" : from chmpy import Molecule els = s . dens_a . elements pos = s . dens_a . positions property_function = Molecule . from_arrays ( s . dens_a . elements , s . dens_a . positions ) . electrostatic_potential xyz = sht . grid_cartesian * r [:, np . newaxis ] prop_values = property_function ( xyz ) r_cplx = np . empty ( r . shape , dtype = np . complex128 ) r_cplx . real = r r_cplx . imag = prop_values r = r_cplx real = False l_max = sht . l_max coeffs = sht . analyse ( r ) invariants = make_invariants ( l_max , coeffs , kinds = kwargs . get ( \"kinds\" , \"NP\" ), real = real ) if kwargs . get ( \"coefficients\" , False ): return coeffs , invariants return invariants","title":"stockholder_weight_descriptor()"},{"location":"API/core/element/","text":"Module for static information about chemical elements. Element Storage class for information about a chemical element. !!! examples >>> h = Element . from_string ( \"H\" ) >>> c = Element . from_string ( \"C\" ) >>> n = Element . from_atomic_number ( 7 ) >>> f = Element . from_string ( \"F\" ) Element implements an ordering for sorting in e . g . molecular formulae where carbon and hydrogen come first , otherwise elements are sorted in order of atomic number . >>> sorted ([ h , f , f , c , n ]) [ C , H , N , F , F ] ball_stick_radius: float property readonly The radius of this element in a ball and stick representation. color property readonly The color RGBA color of this element. covalent_radius: float property readonly The covalent radius in angstroms. vdw_radius: float property readonly The van der Waals radius in angstroms. __eq__ ( self , other ) special Check if two Elements have the same atomic number. Source code in chmpy/core/element.py 391 392 393 394 395 def __eq__ ( self , other ): \"\"\"Check if two Elements have the same atomic number.\"\"\" if not self . _is_valid_operand ( other ): raise NotImplementedError return self . atomic_number == other . atomic_number __ge__ ( self , other , NotImplemented = NotImplemented ) special Return a >= b. Computed by @total_ordering from (not a < b). Source code in chmpy/core/element.py 100 101 102 103 104 105 def _ge_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a >= b. Computed by @total_ordering from (not a < b).' op_result = self . __lt__ ( other ) if op_result is NotImplemented : return op_result return not op_result __gt__ ( self , other , NotImplemented = NotImplemented ) special Return a > b. Computed by @total_ordering from (not a < b) and (a != b). Source code in chmpy/core/element.py 88 89 90 91 92 93 def _gt_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a > b. Computed by @total_ordering from (not a < b) and (a != b).' op_result = self . __lt__ ( other ) if op_result is NotImplemented : return op_result return not op_result and self != other __hash__ ( self ) special Hash of this element (its atomic number). Source code in chmpy/core/element.py 384 385 386 def __hash__ ( self ): \"\"\"Hash of this element (its atomic number).\"\"\" return int ( self . atomic_number ) __init__ ( self , atomic_number , name , symbol , cov , vdw , mass ) special Initialize an Element from its chemical data. Source code in chmpy/core/element.py 270 271 272 273 274 275 276 277 def __init__ ( self , atomic_number , name , symbol , cov , vdw , mass ): \"\"\"Initialize an Element from its chemical data.\"\"\" self . atomic_number = atomic_number self . name = name self . symbol = symbol self . cov = cov self . vdw = vdw self . mass = mass __le__ ( self , other , NotImplemented = NotImplemented ) special Return a <= b. Computed by @total_ordering from (a < b) or (a == b). Source code in chmpy/core/element.py 95 96 97 98 def _le_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a <= b. Computed by @total_ordering from (a < b) or (a == b).' op_result = self . __lt__ ( other ) return op_result or self == other __lt__ ( self , other ) special Check which element comes before the other in chemical formulae (C first, then order of atomic number). Source code in chmpy/core/element.py 397 398 399 400 401 402 403 404 405 406 407 408 409 def __lt__ ( self , other ): \"\"\"Check which element comes before the other in chemical formulae (C first, then order of atomic number).\"\"\" if not self . _is_valid_operand ( other ): raise NotImplementedError n1 , n2 = self . atomic_number , other . atomic_number if n1 == n2 : return False if n1 == 6 : return True elif n2 == 6 : return False else : return n1 < n2 __repr__ ( self ) special Represent this element as a string for REPL. Source code in chmpy/core/element.py 380 381 382 def __repr__ ( self ): \"\"\"Represent this element as a string for REPL.\"\"\" return self . symbol from_atomic_number ( n ) staticmethod Create an element from a given atomic number. Parameters: Name Type Description Default n int the atomic number of the element required Returns: Type Description Element Element: an Element object if atomic number was valid, otherwise an exception is raised Examples: 1 2 3 4 >>> Element . from_atomic_number ( 2 ) He >>> Element [ 79 ] . name 'gold' Source code in chmpy/core/element.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 @staticmethod def from_atomic_number ( n : int ) -> \"Element\" : \"\"\"Create an element from a given atomic number. Args: n (int): the atomic number of the element Returns: Element: an Element object if atomic number was valid, otherwise an exception is raised Examples: >>> Element.from_atomic_number(2) He >>> Element[79].name 'gold' \"\"\" return Element ( n , * _ELEMENT_DATA [ n - 1 ]) from_label ( label ) staticmethod Create an element from a label e.g. 'C1', 'H2_F2___i' etc. Parameters: Name Type Description Default l str a string representation of an element in the periodic table required Returns: Type Description Element Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: 1 2 3 4 5 6 >>> Element . from_label ( \"C1\" ) C >>> Element . from_label ( \"H\" ) H >>> Element [ \"LI2_F2____1____i\" ] Li An ambiguous case, will make this Calcium not Carbon 1 2 >>> Element . from_label ( \"Ca2_F2____1____i\" ) Ca Source code in chmpy/core/element.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @staticmethod def from_label ( label : str ) -> \"Element\" : \"\"\"Create an element from a label e.g. 'C1', 'H2_F2___i' etc. Args: l (str): a string representation of an element in the periodic table Returns: Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: >>> Element.from_label(\"C1\") C >>> Element.from_label(\"H\") H >>> Element[\"LI2_F2____1____i\"] Li An ambiguous case, will make this Calcium not Carbon >>> Element.from_label(\"Ca2_F2____1____i\") Ca \"\"\" m = re . match ( _SYMBOL_REGEX , label ) if m is None : raise ValueError ( \"Could not determine symbol from {} \" . format ( label )) sym = m . group ( 1 ) . strip () . capitalize () if sym not in _EL_FROM_SYM : raise ValueError ( \"Could not determine symbol from {} \" . format ( label )) return Element ( * _EL_FROM_SYM [ sym ]) from_string ( s ) staticmethod Create an element from a given element symbol. Parameters: Name Type Description Default s str a string representation of an element in the periodic table required Returns: Type Description Element Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: 1 2 3 4 5 6 >>> Element . from_string ( \"h\" ) H >>> Element [ \"rn\" ] . name 'radon' >>> Element [ \"AC\" ] . cov 2.15 Source code in chmpy/core/element.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 @staticmethod def from_string ( s : str ) -> \"Element\" : \"\"\"Create an element from a given element symbol. Args: s (str): a string representation of an element in the periodic table Returns: Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: >>> Element.from_string(\"h\") H >>> Element[\"rn\"].name 'radon' >>> Element[\"AC\"].cov 2.15 \"\"\" symbol = s . strip () . capitalize () if symbol == \"D\" : symbol = \"H\" if symbol . isdigit (): return Element . from_atomic_number ( int ( symbol )) if symbol not in _EL_FROM_SYM : name = symbol . lower () if name not in _EL_FROM_NAME : return Element . from_label ( s ) else : return Element ( * _EL_FROM_NAME [ name ]) return Element ( * _EL_FROM_SYM [ symbol ]) chemical_formula ( elements , subscript = False ) Calculate the chemical formula for the given list of elements. Examples: 1 2 3 4 >>> chemical_formula ([ 'O' , 'C' , 'O' ]) 'CO2' >>> chemical_formula ([ 'C' , 'H' , 'O' , 'B' ]) 'BCHO' Parameters: Name Type Description Default elements List[Element or str] a list of elements or element symbols. Note that if a list of strings are provided the order of chemical symbols may not match convention. required subscript bool, optoinal toggle to use unicode subscripts for the chemical formula string False Returns: Type Description str the chemical formula Source code in chmpy/core/element.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def chemical_formula ( elements , subscript = False ): \"\"\"Calculate the chemical formula for the given list of elements. Examples: >>> chemical_formula(['O', 'C', 'O']) 'CO2' >>> chemical_formula(['C', 'H', 'O', 'B']) 'BCHO' Args: elements (List[Element or str]): a list of elements or element symbols. Note that if a list of strings are provided the order of chemical symbols may not match convention. subscript (bool, optoinal): toggle to use unicode subscripts for the chemical formula string Returns: str: the chemical formula \"\"\" count = Counter ( sorted ( elements )) if subscript : blocks = [] for el , c in count . items (): c = \"\" . join ( chr ( 0x2080 + int ( i )) for i in str ( c )) if c > 1 else \"\" blocks . append ( f \" { el }{ c } \" ) else : blocks = [] for el , c in count . items (): c = c if c > 1 else \"\" blocks . append ( f \" { el }{ c } \" ) return \"\" . join ( blocks ) cov_radii ( atomic_numbers ) Return the covalent radii for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description np.ndarray (N,) array of floats representing covalent radii Source code in chmpy/core/element.py 444 445 446 447 448 449 450 451 452 453 454 455 def cov_radii ( atomic_numbers ): \"\"\"Return the covalent radii for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: np.ndarray: (N,) array of floats representing covalent radii \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return np . array ([ _ELEMENT_DATA [ i - 1 ][ 2 ] for i in atomic_numbers ], dtype = np . float32 ) element_names ( atomic_numbers ) Return the element names for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description List[str] (N,) list of strings representing element names Source code in chmpy/core/element.py 472 473 474 475 476 477 478 479 480 481 482 483 def element_names ( atomic_numbers ): \"\"\"Return the element names for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: List[str]: (N,) list of strings representing element names \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return [ _ELEMENT_DATA [ i - 1 ][ 0 ] for i in atomic_numbers ] element_symbols ( atomic_numbers ) Return the element symbols for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description List[str] (N,) list of strings representing element symbols Source code in chmpy/core/element.py 486 487 488 489 490 491 492 493 494 495 496 497 def element_symbols ( atomic_numbers ): \"\"\"Return the element symbols for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: List[str]: (N,) list of strings representing element symbols \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return [ _ELEMENT_DATA [ i - 1 ][ 1 ] for i in atomic_numbers ] vdw_radii ( atomic_numbers ) Return the van der Waals radii for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description np.ndarray (N,) array of floats representing van der Waals radii Source code in chmpy/core/element.py 458 459 460 461 462 463 464 465 466 467 468 469 def vdw_radii ( atomic_numbers ): \"\"\"Return the van der Waals radii for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: np.ndarray: (N,) array of floats representing van der Waals radii \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return np . array ([ _ELEMENT_DATA [ i - 1 ][ 3 ] for i in atomic_numbers ], dtype = np . float32 )","title":"Element"},{"location":"API/core/element/#chmpy.core.element","text":"Module for static information about chemical elements.","title":"chmpy.core.element"},{"location":"API/core/element/#chmpy.core.element.Element","text":"Storage class for information about a chemical element. !!! examples >>> h = Element . from_string ( \"H\" ) >>> c = Element . from_string ( \"C\" ) >>> n = Element . from_atomic_number ( 7 ) >>> f = Element . from_string ( \"F\" ) Element implements an ordering for sorting in e . g . molecular formulae where carbon and hydrogen come first , otherwise elements are sorted in order of atomic number . >>> sorted ([ h , f , f , c , n ]) [ C , H , N , F , F ]","title":"Element"},{"location":"API/core/element/#chmpy.core.element.Element.ball_stick_radius","text":"The radius of this element in a ball and stick representation.","title":"ball_stick_radius"},{"location":"API/core/element/#chmpy.core.element.Element.color","text":"The color RGBA color of this element.","title":"color"},{"location":"API/core/element/#chmpy.core.element.Element.covalent_radius","text":"The covalent radius in angstroms.","title":"covalent_radius"},{"location":"API/core/element/#chmpy.core.element.Element.vdw_radius","text":"The van der Waals radius in angstroms.","title":"vdw_radius"},{"location":"API/core/element/#chmpy.core.element.Element.__eq__","text":"Check if two Elements have the same atomic number. Source code in chmpy/core/element.py 391 392 393 394 395 def __eq__ ( self , other ): \"\"\"Check if two Elements have the same atomic number.\"\"\" if not self . _is_valid_operand ( other ): raise NotImplementedError return self . atomic_number == other . atomic_number","title":"__eq__()"},{"location":"API/core/element/#chmpy.core.element.Element.__ge__","text":"Return a >= b. Computed by @total_ordering from (not a < b). Source code in chmpy/core/element.py 100 101 102 103 104 105 def _ge_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a >= b. Computed by @total_ordering from (not a < b).' op_result = self . __lt__ ( other ) if op_result is NotImplemented : return op_result return not op_result","title":"__ge__()"},{"location":"API/core/element/#chmpy.core.element.Element.__gt__","text":"Return a > b. Computed by @total_ordering from (not a < b) and (a != b). Source code in chmpy/core/element.py 88 89 90 91 92 93 def _gt_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a > b. Computed by @total_ordering from (not a < b) and (a != b).' op_result = self . __lt__ ( other ) if op_result is NotImplemented : return op_result return not op_result and self != other","title":"__gt__()"},{"location":"API/core/element/#chmpy.core.element.Element.__hash__","text":"Hash of this element (its atomic number). Source code in chmpy/core/element.py 384 385 386 def __hash__ ( self ): \"\"\"Hash of this element (its atomic number).\"\"\" return int ( self . atomic_number )","title":"__hash__()"},{"location":"API/core/element/#chmpy.core.element.Element.__init__","text":"Initialize an Element from its chemical data. Source code in chmpy/core/element.py 270 271 272 273 274 275 276 277 def __init__ ( self , atomic_number , name , symbol , cov , vdw , mass ): \"\"\"Initialize an Element from its chemical data.\"\"\" self . atomic_number = atomic_number self . name = name self . symbol = symbol self . cov = cov self . vdw = vdw self . mass = mass","title":"__init__()"},{"location":"API/core/element/#chmpy.core.element.Element.__le__","text":"Return a <= b. Computed by @total_ordering from (a < b) or (a == b). Source code in chmpy/core/element.py 95 96 97 98 def _le_from_lt ( self , other , NotImplemented = NotImplemented ): 'Return a <= b. Computed by @total_ordering from (a < b) or (a == b).' op_result = self . __lt__ ( other ) return op_result or self == other","title":"__le__()"},{"location":"API/core/element/#chmpy.core.element.Element.__lt__","text":"Check which element comes before the other in chemical formulae (C first, then order of atomic number). Source code in chmpy/core/element.py 397 398 399 400 401 402 403 404 405 406 407 408 409 def __lt__ ( self , other ): \"\"\"Check which element comes before the other in chemical formulae (C first, then order of atomic number).\"\"\" if not self . _is_valid_operand ( other ): raise NotImplementedError n1 , n2 = self . atomic_number , other . atomic_number if n1 == n2 : return False if n1 == 6 : return True elif n2 == 6 : return False else : return n1 < n2","title":"__lt__()"},{"location":"API/core/element/#chmpy.core.element.Element.__repr__","text":"Represent this element as a string for REPL. Source code in chmpy/core/element.py 380 381 382 def __repr__ ( self ): \"\"\"Represent this element as a string for REPL.\"\"\" return self . symbol","title":"__repr__()"},{"location":"API/core/element/#chmpy.core.element.Element.from_atomic_number","text":"Create an element from a given atomic number. Parameters: Name Type Description Default n int the atomic number of the element required Returns: Type Description Element Element: an Element object if atomic number was valid, otherwise an exception is raised Examples: 1 2 3 4 >>> Element . from_atomic_number ( 2 ) He >>> Element [ 79 ] . name 'gold' Source code in chmpy/core/element.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 @staticmethod def from_atomic_number ( n : int ) -> \"Element\" : \"\"\"Create an element from a given atomic number. Args: n (int): the atomic number of the element Returns: Element: an Element object if atomic number was valid, otherwise an exception is raised Examples: >>> Element.from_atomic_number(2) He >>> Element[79].name 'gold' \"\"\" return Element ( n , * _ELEMENT_DATA [ n - 1 ])","title":"from_atomic_number()"},{"location":"API/core/element/#chmpy.core.element.Element.from_label","text":"Create an element from a label e.g. 'C1', 'H2_F2___i' etc. Parameters: Name Type Description Default l str a string representation of an element in the periodic table required Returns: Type Description Element Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: 1 2 3 4 5 6 >>> Element . from_label ( \"C1\" ) C >>> Element . from_label ( \"H\" ) H >>> Element [ \"LI2_F2____1____i\" ] Li An ambiguous case, will make this Calcium not Carbon 1 2 >>> Element . from_label ( \"Ca2_F2____1____i\" ) Ca Source code in chmpy/core/element.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 @staticmethod def from_label ( label : str ) -> \"Element\" : \"\"\"Create an element from a label e.g. 'C1', 'H2_F2___i' etc. Args: l (str): a string representation of an element in the periodic table Returns: Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: >>> Element.from_label(\"C1\") C >>> Element.from_label(\"H\") H >>> Element[\"LI2_F2____1____i\"] Li An ambiguous case, will make this Calcium not Carbon >>> Element.from_label(\"Ca2_F2____1____i\") Ca \"\"\" m = re . match ( _SYMBOL_REGEX , label ) if m is None : raise ValueError ( \"Could not determine symbol from {} \" . format ( label )) sym = m . group ( 1 ) . strip () . capitalize () if sym not in _EL_FROM_SYM : raise ValueError ( \"Could not determine symbol from {} \" . format ( label )) return Element ( * _EL_FROM_SYM [ sym ])","title":"from_label()"},{"location":"API/core/element/#chmpy.core.element.Element.from_string","text":"Create an element from a given element symbol. Parameters: Name Type Description Default s str a string representation of an element in the periodic table required Returns: Type Description Element Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: 1 2 3 4 5 6 >>> Element . from_string ( \"h\" ) H >>> Element [ \"rn\" ] . name 'radon' >>> Element [ \"AC\" ] . cov 2.15 Source code in chmpy/core/element.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 @staticmethod def from_string ( s : str ) -> \"Element\" : \"\"\"Create an element from a given element symbol. Args: s (str): a string representation of an element in the periodic table Returns: Element: an Element object if the conversion was successful, otherwise an exception is raised Examples: >>> Element.from_string(\"h\") H >>> Element[\"rn\"].name 'radon' >>> Element[\"AC\"].cov 2.15 \"\"\" symbol = s . strip () . capitalize () if symbol == \"D\" : symbol = \"H\" if symbol . isdigit (): return Element . from_atomic_number ( int ( symbol )) if symbol not in _EL_FROM_SYM : name = symbol . lower () if name not in _EL_FROM_NAME : return Element . from_label ( s ) else : return Element ( * _EL_FROM_NAME [ name ]) return Element ( * _EL_FROM_SYM [ symbol ])","title":"from_string()"},{"location":"API/core/element/#chmpy.core.element.chemical_formula","text":"Calculate the chemical formula for the given list of elements. Examples: 1 2 3 4 >>> chemical_formula ([ 'O' , 'C' , 'O' ]) 'CO2' >>> chemical_formula ([ 'C' , 'H' , 'O' , 'B' ]) 'BCHO' Parameters: Name Type Description Default elements List[Element or str] a list of elements or element symbols. Note that if a list of strings are provided the order of chemical symbols may not match convention. required subscript bool, optoinal toggle to use unicode subscripts for the chemical formula string False Returns: Type Description str the chemical formula Source code in chmpy/core/element.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def chemical_formula ( elements , subscript = False ): \"\"\"Calculate the chemical formula for the given list of elements. Examples: >>> chemical_formula(['O', 'C', 'O']) 'CO2' >>> chemical_formula(['C', 'H', 'O', 'B']) 'BCHO' Args: elements (List[Element or str]): a list of elements or element symbols. Note that if a list of strings are provided the order of chemical symbols may not match convention. subscript (bool, optoinal): toggle to use unicode subscripts for the chemical formula string Returns: str: the chemical formula \"\"\" count = Counter ( sorted ( elements )) if subscript : blocks = [] for el , c in count . items (): c = \"\" . join ( chr ( 0x2080 + int ( i )) for i in str ( c )) if c > 1 else \"\" blocks . append ( f \" { el }{ c } \" ) else : blocks = [] for el , c in count . items (): c = c if c > 1 else \"\" blocks . append ( f \" { el }{ c } \" ) return \"\" . join ( blocks )","title":"chemical_formula()"},{"location":"API/core/element/#chmpy.core.element.cov_radii","text":"Return the covalent radii for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description np.ndarray (N,) array of floats representing covalent radii Source code in chmpy/core/element.py 444 445 446 447 448 449 450 451 452 453 454 455 def cov_radii ( atomic_numbers ): \"\"\"Return the covalent radii for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: np.ndarray: (N,) array of floats representing covalent radii \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return np . array ([ _ELEMENT_DATA [ i - 1 ][ 2 ] for i in atomic_numbers ], dtype = np . float32 )","title":"cov_radii()"},{"location":"API/core/element/#chmpy.core.element.element_names","text":"Return the element names for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description List[str] (N,) list of strings representing element names Source code in chmpy/core/element.py 472 473 474 475 476 477 478 479 480 481 482 483 def element_names ( atomic_numbers ): \"\"\"Return the element names for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: List[str]: (N,) list of strings representing element names \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return [ _ELEMENT_DATA [ i - 1 ][ 0 ] for i in atomic_numbers ]","title":"element_names()"},{"location":"API/core/element/#chmpy.core.element.element_symbols","text":"Return the element symbols for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description List[str] (N,) list of strings representing element symbols Source code in chmpy/core/element.py 486 487 488 489 490 491 492 493 494 495 496 497 def element_symbols ( atomic_numbers ): \"\"\"Return the element symbols for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: List[str]: (N,) list of strings representing element symbols \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return [ _ELEMENT_DATA [ i - 1 ][ 1 ] for i in atomic_numbers ]","title":"element_symbols()"},{"location":"API/core/element/#chmpy.core.element.vdw_radii","text":"Return the van der Waals radii for the given atomic numbers. Parameters: Name Type Description Default atomic_numbers array_like the (N,) length integer array of atomic numbers required Returns: Type Description np.ndarray (N,) array of floats representing van der Waals radii Source code in chmpy/core/element.py 458 459 460 461 462 463 464 465 466 467 468 469 def vdw_radii ( atomic_numbers ): \"\"\"Return the van der Waals radii for the given atomic numbers. Args: atomic_numbers (array_like): the (N,) length integer array of atomic numbers Returns: np.ndarray: (N,) array of floats representing van der Waals radii \"\"\" if np . any ( atomic_numbers < 1 ) or np . any ( atomic_numbers > 103 ): raise ValueError ( \"All elements must be atomic numbers between [1,103]\" ) return np . array ([ _ELEMENT_DATA [ i - 1 ][ 3 ] for i in atomic_numbers ], dtype = np . float32 )","title":"vdw_radii()"},{"location":"API/core/molecule/","text":"Molecule Class to represent information about a molecule i.e. a set of atoms with 3D coordinates joined by covalent bonds e.g. int, float, str etc. Will handle uncertainty values contained in parentheses. Attributes: Name Type Description elements ndarray list of element information for each atom in this molecule positions ndarray (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) bonds dok_matrix (N, N) adjacency matrix of bond lengths for connected atoms, 0 otherwise. If not provided this will be calculated. labels ndarray (N,) vector of string labels for each atom in this molecule If not provided this will assigned default labels i.e. numbered in order. proerties Additional keyword arguments will be stored in the properties member, and some may be utilized in methods, raising an exception if they are not set. asym_symops property readonly the symmetry operations which generate this molecule (default x,y,z if not set) atomic_numbers: ndarray property readonly Atomic numbers for each atom in this molecule bbox_corners: Tuple property readonly the lower, upper corners of a axis-aligned bounding box for this molecule bbox_size: ndarray property readonly the dimensions of the axis-aligned bounding box for this molecule center_of_mass: ndarray property readonly Mean cartesian position of atoms in this molecule, weighted by atomic mass centroid: ndarray property readonly Mean cartesian position of atoms in this molecule distance_matrix: ndarray property readonly The (dense) pairwise distance matrix for this molecule molecular_formula: str property readonly string of the molecular formula for this molecule name property readonly The name of this molecule, checks 'GENERIC_NAME' and 'name' keys in self.properties partial_charges: ndarray property readonly The partial charges associated with atoms in this molecule. If self._partial_charges is not set, the charges will be assigned based on EEM method. unique_bonds: List property readonly The unique bonds for this molecule. If bonds are not assigned, this will None __init__ ( self , elements , positions , bonds = None , labels = None , ** kwargs ) special Initialize a new molecule. Parameters: Name Type Description Default elements List[Element] N length list of elements associated with the sites required positions array_like (N, 3) array of site positions in Cartesian coordinates required bonds dok_matrix if bonds are already calculated provide them here None labels array_like labels (array_like): N length array of string labels for each site None kwargs Additional properties (will populate the properties member) to store in this molecule {} Source code in chmpy/core/molecule.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , elements , positions , bonds = None , labels = None , ** kwargs ): \"\"\" Initialize a new molecule. Arguments: elements (List[Element]): N length list of elements associated with the sites positions (array_like): (N, 3) array of site positions in Cartesian coordinates bonds (dok_matrix, optional): if bonds are already calculated provide them here labels (array_like, optional): labels (array_like): N length array of string labels for each site kwargs: Additional properties (will populate the properties member) to store in this molecule \"\"\" self . positions = positions self . elements = elements self . properties = {} self . properties . update ( kwargs ) self . bonds = None self . charge = kwargs . get ( \"charge\" , 0 ) self . multiplicity = kwargs . get ( \"multiplicity\" , 1 ) if bonds is None : if kwargs . get ( \"guess_bonds\" , False ): self . guess_bonds () else : self . bonds = dok_matrix ( bonds ) if labels is None : self . assign_default_labels () else : self . labels = labels assign_default_labels ( self ) Assign the default labels to atom sites in this molecule (number them by element) Source code in chmpy/core/molecule.py 162 163 164 165 166 167 168 169 def assign_default_labels ( self ): \"Assign the default labels to atom sites in this molecule (number them by element)\" counts = defaultdict ( int ) labels = [] for el , _ in self : counts [ el ] += 1 labels . append ( \" {}{} \" . format ( el . symbol , counts [ el ])) self . labels = np . asarray ( labels ) atomic_shape_descriptors ( self , l_max = 5 , radius = 6.0 , background = 1e-05 ) Calculate the shape descriptors [1,2] for all atoms in this isolated molecule. If you wish to use the crystal environment please see the corresponding method in :obj: chmpy.crystal.Crystal . Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the shape function. (default=5) 5 radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms (default=6.0) 6.0 background float 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) 1e-05 Returns: Type Description ndarray shape description vector References [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/core/molecule.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def atomic_shape_descriptors ( self , l_max = 5 , radius = 6.0 , background = 1e-5 ) -> np . ndarray : \"\"\" Calculate the shape descriptors`[1,2]` for all atoms in this isolated molecule. If you wish to use the crystal environment please see the corresponding method in :obj:`chmpy.crystal.Crystal`. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the shape function. (default=5) radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms (default=6.0) background (float, optional): 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) Returns: shape description vector References ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) elements = self . atomic_numbers positions = self . positions dists = self . distance_matrix for n in range ( elements . shape [ 0 ]): els = elements [ n : n + 1 ] pos = positions [ n : n + 1 , :] idxs = np . where (( dists [ n , :] < radius ) & ( dists [ n , :] > 1e-3 ))[ 0 ] neighbour_els = elements [ idxs ] neighbour_pos = positions [ idxs ] ubound = Element [ n ] . vdw_radius * 3 descriptors . append ( stockholder_weight_descriptor ( sph , els , pos , neighbour_els , neighbour_pos , bounds = ( 0.2 , ubound ), background = background , ) ) return np . asarray ( descriptors ) atomic_stockholder_weight_isosurfaces ( self , ** kwargs ) Calculate the stockholder weight isosurfaces for the atoms in this molecule, with the provided background density. Parameters: Name Type Description Default kwargs dict keyword arguments to be passed to isosurface generation code Options are: background : float , optional 'background' density to ensure closed surfaces for isolated atoms ( default = 1 e - 5 ) isovalue : float , optional level set value for the isosurface ( default = 0.5 ). Must be between 0 and 1 , but values other than 0.5 probably won 't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of (' d_norm_i ', ' d_i ', ' d_norm_e ', ' d_e ', ' d_norm ') colormap: str, optional matplotlib colormap to use for surface coloring (default ' viridis_r ' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description List[trimesh.Trimesh] A list of meshes representing the stockholder weight isosurfaces Source code in chmpy/core/molecule.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def atomic_stockholder_weight_isosurfaces ( self , ** kwargs ): \"\"\" Calculate the stockholder weight isosurfaces for the atoms in this molecule, with the provided background density. Args: kwargs (dict): keyword arguments to be passed to isosurface generation code Options are: ``` background: float, optional 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) isovalue: float, optional level set value for the isosurface (default=0.5). Must be between 0 and 1, but values other than 0.5 probably won't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e', 'd_norm') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: List[trimesh.Trimesh]: A list of meshes representing the stockholder weight isosurfaces \"\"\" from chmpy import StockholderWeight from chmpy.surface import stockholder_weight_isosurface from matplotlib.cm import get_cmap import trimesh from chmpy.util.color import DEFAULT_COLORMAPS sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) radius = kwargs . get ( \"radius\" , 12.0 ) background = kwargs . get ( \"background\" , 1e-5 ) vertex_color = kwargs . get ( \"color\" , \"d_norm_i\" ) isovalue = kwargs . get ( \"isovalue\" , 0.5 ) midpoint = kwargs . get ( \"midpoint\" , 0.0 if vertex_color == \"d_norm\" else None ) meshes = [] colormap = get_cmap ( kwargs . get ( \"colormap\" , DEFAULT_COLORMAPS . get ( vertex_color , \"viridis_r\" )) ) isos = [] elements = self . atomic_numbers positions = self . positions dists = self . distance_matrix for n in range ( elements . shape [ 0 ]): els = elements [ n : n + 1 ] pos = positions [ n : n + 1 , :] idxs = np . where (( dists [ n , :] < radius ) & ( dists [ n , :] > 1e-3 ))[ 0 ] neighbour_els = elements [ idxs ] neighbour_pos = positions [ idxs ] s = StockholderWeight . from_arrays ( els , pos , neighbour_els , neighbour_pos , background = background ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) for iso in isos : prop = iso . vertex_prop [ vertex_color ] norm = None if midpoint is not None : from matplotlib.colors import DivergingNorm norm = DivergingNorm ( vmin = prop . min (), vcenter = midpoint , vmax = prop . max ()) prop = norm ( prop ) color = colormap ( prop ) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) meshes . append ( mesh ) return meshes bond_graph ( self ) Calculate the graph_tool.Graph object corresponding to this molecule. Requires the graph_tool library to be installed Returns: Type Description graph_tool.Graph the (undirected) graph of this molecule Source code in chmpy/core/molecule.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 def bond_graph ( self ): \"\"\" Calculate the `graph_tool.Graph` object corresponding to this molecule. Requires the graph_tool library to be installed Returns: graph_tool.Graph: the (undirected) graph of this molecule \"\"\" if hasattr ( self , \"_bond_graph\" ): return getattr ( self , \"_bond_graph\" ) try : import graph_tool as gt except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) if self . bonds is None : self . guess_bonds () g = gt . Graph ( directed = False ) v_el = g . new_vertex_property ( \"int\" ) g . add_edge_list ( self . bonds . keys ()) e_w = g . new_edge_property ( \"float\" ) v_el . a [:] = self . atomic_numbers g . vertex_properties [ \"element\" ] = v_el e_w . a [:] = list ( self . bonds . values ()) g . edge_properties [ \"bond_distance\" ] = e_w self . _bond_graph = g return g connected_fragments ( self ) Separate this molecule into fragments/molecules based on covalent bonding criteria. Returns: Type Description List a list of connected Molecule objects Source code in chmpy/core/molecule.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def connected_fragments ( self ) -> List : \"\"\" Separate this molecule into fragments/molecules based on covalent bonding criteria. Returns: a list of connected `Molecule` objects \"\"\" from chmpy.util.num import cartesian_product from scipy.sparse.csgraph import connected_components if self . bonds is None : self . guess_bonds () nfrag , labels = connected_components ( self . bonds ) molecules = [] for frag in range ( nfrag ): atoms = np . where ( labels == frag )[ 0 ] na = len ( atoms ) sqidx = cartesian_product ( atoms , atoms ) molecules . append ( Molecule ( [ self . elements [ i ] for i in atoms ], self . positions [ atoms ], labels = self . labels [ atoms ], bonds = self . bonds [ sqidx [:, 0 ], sqidx [:, 1 ]] . reshape ( na , na ), ) ) return molecules distance_to ( self , other , method = 'centroid' ) Calculate the euclidean distance between this molecule and another. May use the distance between centres-of-mass, centroids, or nearest atoms. Parameters other (Molecule): the molecule to calculate distance to method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom' Source code in chmpy/core/molecule.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def distance_to ( self , other , method = \"centroid\" ): \"\"\" Calculate the euclidean distance between this molecule and another. May use the distance between centres-of-mass, centroids, or nearest atoms. Parameters other (Molecule): the molecule to calculate distance to method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom' \"\"\" method = method . lower () if method == \"centroid\" : return np . linalg . norm ( self . centroid - other . centroid ) elif method == \"center_of_mass\" : return np . linalg . norm ( self . center_of_mass - other . center_of_mass ) elif method == \"nearest_atom\" : return np . min ( cdist ( self . positions , other . positions )) else : raise ValueError ( f \"Unknown method= { method } \" ) electrostatic_potential ( self , positions ) Calculate the electrostatic potential based on the partial charges associated with this molecule. The potential will be in atomic units. Parameters: Name Type Description Default positions np.ndarray (N, 3) array of locations where the molecular ESP should be calculated. Assumed to be in Angstroms. required Returns: Type Description ndarray np.ndarray: (N,) array of electrostatic potential values (atomic units) at the given positions. Source code in chmpy/core/molecule.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 def electrostatic_potential ( self , positions ) -> np . ndarray : \"\"\" Calculate the electrostatic potential based on the partial charges associated with this molecule. The potential will be in atomic units. Args: positions (np.ndarray): (N, 3) array of locations where the molecular ESP should be calculated. Assumed to be in Angstroms. Returns: np.ndarray: (N,) array of electrostatic potential values (atomic units) at the given positions. \"\"\" from chmpy.util.unit import BOHR_TO_ANGSTROM BOHR_PER_ANGSTROM = 1 / BOHR_TO_ANGSTROM v_pot = np . zeros ( positions . shape [ 0 ]) for charge , position in zip ( self . partial_charges , self . positions ): if charge == 0.0 : continue r = np . linalg . norm ( positions - position [ np . newaxis , :], axis = 1 ) v_pot += charge / ( r * BOHR_PER_ANGSTROM ) return v_pot from_arrays ( elements , positions , ** kwargs ) classmethod Construct a molecule from the provided arrays. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default elements np.ndarray (N,) array of atomic numbers for each atom in this molecule required positions np.ndarray (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) required Returns: Type Description Molecule a new molecule object Source code in chmpy/core/molecule.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 @classmethod def from_arrays ( cls , elements , positions , ** kwargs ): \"\"\" Construct a molecule from the provided arrays. kwargs will be passed through to the Molecule constructor. Args: elements (np.ndarray): (N,) array of atomic numbers for each atom in this molecule positions (np.ndarray): (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) Returns: Molecule: a new molecule object \"\"\" return cls ([ Element [ x ] for x in elements ], np . array ( positions ), ** kwargs ) from_sdf_dict ( sdf_dict , ** kwargs ) classmethod Construct a molecule from the provided dictionary of sdf terms. Not intended for typical use cases, but as a helper method for Molecule.from_sdf_file Parameters: Name Type Description Default sdf_dict dict a dictionary containing the 'atoms', 'x', 'y', 'z', 'symbol', 'bonds' members. required Returns: Type Description Molecule Molecule: a new Molecule from the provided data Source code in chmpy/core/molecule.py 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 @classmethod def from_sdf_dict ( cls , sdf_dict , ** kwargs ) -> \"Molecule\" : \"\"\" Construct a molecule from the provided dictionary of sdf terms. Not intended for typical use cases, but as a helper method for `Molecule.from_sdf_file` Args: sdf_dict (dict): a dictionary containing the 'atoms', 'x', 'y', 'z', 'symbol', 'bonds' members. Returns: Molecule: a new `Molecule` from the provided data \"\"\" atoms = sdf_dict [ \"atoms\" ] positions = np . c_ [ atoms [ \"x\" ], atoms [ \"y\" ], atoms [ \"z\" ]] elements = [ Element [ x ] for x in atoms [ \"symbol\" ]] # TODO use bonds from SDF # bonds = sdf_dict[\"bonds\"] m = cls ( elements , positions , ** sdf_dict [ \"data\" ]) if \"sdf\" in sdf_dict : m . properties [ \"sdf\" ] = sdf_dict [ \"sdf\" ] return m from_sdf_file ( filename , ** kwargs ) classmethod Construct a molecule from the provided SDF file. Because an SDF file can have multiple molecules, an optional keyword argument 'progress' may be provided to track the loading of many molecules. Parameters: Name Type Description Default filename str the path of the SDF file to read. required Returns: Type Description Molecule a new Molecule or list of :obj: Molecule objects from the provided SDF file. Source code in chmpy/core/molecule.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 @classmethod def from_sdf_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided SDF file. Because an SDF file can have multiple molecules, an optional keyword argument 'progress' may be provided to track the loading of many molecules. Args: filename (str): the path of the SDF file to read. Returns: Molecule: a new `Molecule` or list of :obj:`Molecule` objects from the provided SDF file. \"\"\" from chmpy.fmt.sdf import parse_sdf_file sdf_data = parse_sdf_file ( filename , ** kwargs ) progress = kwargs . get ( \"progress\" , False ) update = lambda x : None if progress : from tqdm import tqdm pbar = tqdm ( desc = \"Creating molecule objects\" , total = len ( sdf_data ), leave = False ) update = pbar . update molecules = [] for d in sdf_data : molecules . append ( cls . from_sdf_dict ( d , ** kwargs )) update ( 1 ) if progress : pbar . close () if len ( molecules ) == 1 : return molecules [ 0 ] return molecules from_turbomole_file ( filename , ** kwargs ) classmethod Construct a molecule from the provided turbomole file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default filename str the path to the .xyz file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @classmethod def from_turbomole_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided turbomole file. kwargs will be passed through to the Molecule constructor. Args: filename (str): the path to the .xyz file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" return cls . from_turbomole_string ( Path ( filename ) . read_text (), ** kwargs ) from_turbomole_string ( contents , ** kwargs ) classmethod Construct a molecule from the provided turbomole file contents. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default contents str the contents of the .xyz file to read required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @classmethod def from_turbomole_string ( cls , contents , ** kwargs ): \"\"\" Construct a molecule from the provided turbomole file contents. kwargs will be passed through to the Molecule constructor. Args: contents (str): the contents of the .xyz file to read kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" from chmpy.fmt.tmol import parse_tmol_string elements , positions = parse_tmol_string ( contents ) return cls ( elements , np . asarray ( positions ), ** kwargs ) from_xyz_file ( filename , ** kwargs ) classmethod Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default filename str the path to the .xyz file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @classmethod def from_xyz_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Args: filename (str): the path to the .xyz file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" return cls . from_xyz_string ( Path ( filename ) . read_text (), ** kwargs ) from_xyz_string ( contents , ** kwargs ) classmethod Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default contents str the contents of the .xyz file to read required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @classmethod def from_xyz_string ( cls , contents , ** kwargs ): \"\"\" Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Args: contents (str): the contents of the .xyz file to read kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" from chmpy.fmt.xyz_file import parse_xyz_string elements , positions = parse_xyz_string ( contents ) return cls ( elements , np . asarray ( positions ), ** kwargs ) functional_groups ( self , kind = None ) Find all indices of atom groups which constitute subgraph isomorphisms with stored functional group data Parameters: Name Type Description Default kind str Find only matches of the given kind None Returns: Type Description Union[dict, List] Either a dict with keys as functional group type and values as list of lists of indices, or a list of lists of indices if kind is specified. Source code in chmpy/core/molecule.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def functional_groups ( self , kind = None ) -> Union [ dict , List ]: \"\"\" Find all indices of atom groups which constitute subgraph isomorphisms with stored functional group data Args: kind (str, optional):Find only matches of the given kind Returns: Either a dict with keys as functional group type and values as list of lists of indices, or a list of lists of indices if kind is specified. \"\"\" global _FUNCTIONAL_GROUP_SUBGRAPHS try : import graph_tool.topology as top # noqa: F401 except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) if not _FUNCTIONAL_GROUP_SUBGRAPHS : from chmpy.subgraphs import load_data _FUNCTIONAL_GROUP_SUBGRAPHS = load_data () if kind is not None : sub = _FUNCTIONAL_GROUP_SUBGRAPHS [ kind ] matches = self . matching_subgraph ( sub ) if kind == \"ring\" : matches = list ( set ( tuple ( sorted ( x )) for x in matches )) return matches matches = {} for n , sub in _FUNCTIONAL_GROUP_SUBGRAPHS . items (): m = self . matching_subgraph ( sub ) if n == \"ring\" : m = list ( set ( tuple ( sorted ( x )) for x in m )) matches [ n ] = m return matches guess_bonds ( self , tolerance = 0.4 ) Use geometric distances and covalent radii to determine bonding information for this molecule. Bonding is determined by the distance between sites being closer than the sum of covalent radii + tolerance Will set the bonds member. If the graph_tool library is available, this will call the bond_graph method to populate the connectivity graph. Parameters: Name Type Description Default tolerance float Additional tolerance for attributing two sites as 'bonded'. The default is 0.4 angstroms, which is recommended by the CCDC 0.4 Source code in chmpy/core/molecule.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def guess_bonds ( self , tolerance = 0.40 ): \"\"\" Use geometric distances and covalent radii to determine bonding information for this molecule. Bonding is determined by the distance between sites being closer than the sum of covalent radii + `tolerance` Will set the `bonds` member. If the `graph_tool` library is available, this will call the `bond_graph` method to populate the connectivity graph. Args: tolerance (float, optional): Additional tolerance for attributing two sites as 'bonded'. The default is 0.4 angstroms, which is recommended by the CCDC \"\"\" tree = KDTree ( self . positions ) covalent_radii = np . array ([ x . cov for x in self . elements ]) max_cov = np . max ( covalent_radii ) thresholds = ( covalent_radii [:, np . newaxis ] + covalent_radii [ np . newaxis , :] + tolerance ) max_distance = max_cov * 2 + tolerance dist = tree . sparse_distance_matrix ( tree , max_distance = max_distance ) . toarray () mask = ( dist > 0 ) & ( dist < thresholds ) self . bonds = np . zeros ( dist . shape ) self . bonds [ mask ] = dist [ mask ] self . bonds = dok_matrix ( self . bonds ) try : self . bond_graph () except Exception : pass load ( filename , ** kwargs ) classmethod Construct a molecule from the provided file. Parameters: Name Type Description Default filename str the path to the (xyz or SDF) file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 @classmethod def load ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided file. Args: filename (str): the path to the (xyz or SDF) file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = cls . _fname_load_map () if n in fname_map : return fname_map [ n ]( filename ) extension_map = cls . _ext_load_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs ) mask ( self , mask , ** kwargs ) Convenience method to construct a new molecule from this molecule with the given mask array. Parameters: Name Type Description Default mask np.ndarray a numpy mask array used to filter which atoms to keep in the new molecule. required Returns: Type Description Molecule a new Molecule , with atoms filtered by the mask. Source code in chmpy/core/molecule.py 859 860 861 862 863 864 865 866 867 868 869 870 871 872 def mask ( self , mask , ** kwargs ): \"\"\" Convenience method to construct a new molecule from this molecule with the given mask array. Args: mask (np.ndarray): a numpy mask array used to filter which atoms to keep in the new molecule. Returns: Molecule: a new `Molecule`, with atoms filtered by the mask. \"\"\" return Molecule . from_arrays ( self . atomic_numbers [ mask ], self . positions [ mask ], ** kwargs ) matching_fragments ( self , fragment , method = 'connectivity' ) Find the indices of a matching fragment to the given molecular fragment Parameters: Name Type Description Default fragment Molecule Molecule object containing the desired fragment required method str the method for matching 'connectivity' Returns: Type Description List[dict] List of maps between matching indices in this molecule and those in the fragment Source code in chmpy/core/molecule.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 def matching_fragments ( self , fragment , method = \"connectivity\" ): \"\"\" Find the indices of a matching fragment to the given molecular fragment Args: fragment (Molecule): Molecule object containing the desired fragment method (str, optional): the method for matching Returns: List[dict]: List of maps between matching indices in this molecule and those in the fragment \"\"\" try : import graph_tool.topology as top except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) sub = fragment . bond_graph () g = self . bond_graph () matches = top . subgraph_isomorphism ( sub , g , vertex_label = ( sub . vertex_properties [ \"element\" ], g . vertex_properties [ \"element\" ], ), ) return [ list ( x . a ) for x in matches ] matching_subgraph ( self , sub ) Find all indices of atoms which match the given graph. Parameters: Name Type Description Default sub graph_tool.Graph the subgraph required Returns: Type Description List list of lists of atomic indices matching the atoms in sub to those in this molecule Source code in chmpy/core/molecule.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 def matching_subgraph ( self , sub ): \"\"\"Find all indices of atoms which match the given graph. Args: sub (graph_tool.Graph): the subgraph Returns: List: list of lists of atomic indices matching the atoms in sub to those in this molecule \"\"\" try : import graph_tool.topology as top except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) g = self . bond_graph () matches = top . subgraph_isomorphism ( sub , g , vertex_label = ( sub . vertex_properties [ \"element\" ], g . vertex_properties [ \"element\" ], ), ) return [ tuple ( x . a ) for x in matches ] promolecule_density_isosurface ( self , ** kwargs ) Calculate promolecule electron density isosurface for this molecule. Parameters: Name Type Description Default kwargs keyword arguments passed to promolecule_density_isosurface Options are: isovalue : float , optional level set value for the isosurface ( default = 0.002 ) in au . separation : float , optional separation between density grid used in the surface calculation ( default 0.2 ) in Angstroms . color : str , optional surface property to use for vertex coloring , one of ( 'd_norm_i' , 'd_i' , 'd_norm_e' , 'd_e' ) colormap : str , optional matplotlib colormap to use for surface coloring ( default 'viridis_r' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description trimesh.Trimesh A mesh representing the promolecule density isosurface Source code in chmpy/core/molecule.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def promolecule_density_isosurface ( self , ** kwargs ): \"\"\" Calculate promolecule electron density isosurface for this molecule. Args: kwargs: keyword arguments passed to `promolecule_density_isosurface` Options are: ``` isovalue: float, optional level set value for the isosurface (default=0.002) in au. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: trimesh.Trimesh: A mesh representing the promolecule density isosurface \"\"\" from chmpy import PromoleculeDensity from chmpy.surface import promolecule_density_isosurface from chmpy.util.color import property_to_color import trimesh isovalue = kwargs . get ( \"isovalue\" , 0.002 ) sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) vertex_color = kwargs . get ( \"color\" , \"d_norm_i\" ) extra_props = {} pro = PromoleculeDensity (( self . atomic_numbers , self . positions )) if vertex_color == \"esp\" : extra_props [ \"esp\" ] = self . electrostatic_potential iso = promolecule_density_isosurface ( pro , sep = sep , isovalue = isovalue , extra_props = extra_props ) prop = iso . vertex_prop [ vertex_color ] color = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , vertex_color )) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) return mesh rotate ( self , rotation , origin = ( 0 , 0 , 0 )) Convenience method to rotate this molecule by a given rotation matrix Parameters: Name Type Description Default rotation np.ndarray A (3, 3) rotation matrix required Source code in chmpy/core/molecule.py 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 def rotate ( self , rotation , origin = ( 0 , 0 , 0 )): \"\"\" Convenience method to rotate this molecule by a given rotation matrix Args: rotation (np.ndarray): A (3, 3) rotation matrix \"\"\" if np . allclose ( origin , ( 0 , 0 , 0 )): np . dot ( self . positions , rotation , out = self . positions ) else : self . positions -= origin np . dot ( self . positions , rotation , out = self . positions ) self . positions += origin rotated ( self , rotation , origin = ( 0 , 0 , 0 )) Convenience method to construct a new copy of thismolecule rotated by a given rotation matrix Parameters: Name Type Description Default rotation np.ndarray A (3, 3) rotation matrix required Returns: Type Description Molecule a new copy of this Molecule rotated by the given rotation matrix. Source code in chmpy/core/molecule.py 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def rotated ( self , rotation , origin = ( 0 , 0 , 0 )): \"\"\" Convenience method to construct a new copy of thismolecule rotated by a given rotation matrix Args: rotation (np.ndarray): A (3, 3) rotation matrix Returns: Molecule: a new copy of this `Molecule` rotated by the given rotation matrix. \"\"\" from copy import deepcopy result = deepcopy ( self ) result . rotate ( rotation , origin = origin ) return result save ( self , filename , ** kwargs ) Save this molecule to the destination file in xyz format, optionally discarding the typical header. Parameters: Name Type Description Default filename str path to the destination file required kwargs keyword arguments passed to the relevant method {} Source code in chmpy/core/molecule.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def save ( self , filename , ** kwargs ): \"\"\" Save this molecule to the destination file in xyz format, optionally discarding the typical header. Args: filename (str): path to the destination file kwargs: keyword arguments passed to the relevant method \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = self . _fname_save_map () if n in fname_map : return fname_map [ n ]( filename , ** kwargs ) extension_map = self . _ext_save_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs ) shape_descriptors ( self , l_max = 5 , ** kwargs ) Calculate the molecular shape descriptors [1,2] for this molecule using the promolecule density. Parameters: Name Type Description Default kwargs keyword arguments passed to promolecule_density_descriptor Options are: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. with_property (str, optional): describe the combination of the radial shape function and a surface property in the real, imaginary channels of a complex function isovalue (float, optional): the isovalue for the promolecule density surface (default 0.0002 au) {} Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/core/molecule.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def shape_descriptors ( self , l_max = 5 , ** kwargs ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors`[1,2]` for this molecule using the promolecule density. Args: kwargs: keyword arguments passed to `promolecule_density_descriptor` Options are: ``` l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. with_property (str, optional): describe the combination of the radial shape function and a surface property in the real, imaginary channels of a complex function isovalue (float, optional): the isovalue for the promolecule density surface (default 0.0002 au) ``` Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , promolecule_density_descriptor sph = SHT ( l_max = l_max ) return promolecule_density_descriptor ( sph , self . atomic_numbers , self . positions , ** kwargs ) to_mesh ( self , ** kwargs ) Convert this molecule to a mesh of spheres and cylinders, colored by element. The origins of the spheres will be at the corresponding atomic position, and all units will be Angstroms. Returns: Type Description dict a dictionary of trimesh.Trimesh objects representing this molecule. Source code in chmpy/core/molecule.py 818 819 820 821 822 823 824 825 826 827 828 829 830 def to_mesh ( self , ** kwargs ): \"\"\" Convert this molecule to a mesh of spheres and cylinders, colored by element. The origins of the spheres will be at the corresponding atomic position, and all units will be Angstroms. Returns: dict: a dictionary of `trimesh.Trimesh` objects representing this molecule. \"\"\" from chmpy.util.mesh import molecule_to_meshes return molecule_to_meshes ( self , ** kwargs ) to_xyz_file ( self , filename , ** kwargs ) Represent this molecule as an of an xmol .xyz file. Keyword arguments are passed to self.to_xyz_string . Parameters: Name Type Description Default filename str The path in which store this molecule required kwargs Keyword arguments to be passed to self.to_xyz_string {} Source code in chmpy/core/molecule.py 414 415 416 417 418 419 420 421 422 423 424 425 def to_xyz_file ( self , filename , ** kwargs ): \"\"\" Represent this molecule as an of an xmol .xyz file. Keyword arguments are passed to `self.to_xyz_string`. Args: filename (str): The path in which store this molecule kwargs: Keyword arguments to be passed to `self.to_xyz_string` \"\"\" Path ( filename ) . write_text ( self . to_xyz_string ( ** kwargs )) to_xyz_string ( self , header = True ) Represent this molecule as a string in the format of an xmol .xyz file. Parameters: Name Type Description Default header bool toggle whether or not to return the 'header' of the xyz file i.e. the number of atoms line and the comment line True Returns: Type Description str contents (str) the contents of the .xyz file Source code in chmpy/core/molecule.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def to_xyz_string ( self , header = True ) -> str : \"\"\" Represent this molecule as a string in the format of an xmol .xyz file. Args: header (bool, optional):toggle whether or not to return the 'header' of the xyz file i.e. the number of atoms line and the comment line Returns: contents (str) the contents of the .xyz file \"\"\" if header : lines = [ f \" { len ( self ) } \" , self . properties . get ( \"comment\" , self . molecular_formula ), ] else : lines = [] for el , ( x , y , z ) in zip ( self . elements , self . positions ): lines . append ( f \" { el } { x : 20.12f } { y : 20.12f } { z : 20.12f } \" ) return \" \\n \" . join ( lines ) transform ( self , rotation = None , translation = None ) Convenience method to transform this molecule by rotation and translation. Parameters: Name Type Description Default rotation np.ndarray A (3,3) rotation matrix None translation np.ndarray A (3,) vector of x, y, z coordinates of the translation None Source code in chmpy/core/molecule.py 934 935 936 937 938 939 940 941 942 943 944 945 946 947 def transform ( self , rotation = None , translation = None ): \"\"\" Convenience method to transform this molecule by rotation and translation. Args: rotation (np.ndarray): A (3,3) rotation matrix translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation \"\"\" if rotation is not None : self . rotate ( rotation , origin = ( 0 , 0 , 0 )) if translation is not None : self . translate ( translation ) transformed ( self , rotation = None , translation = None ) Convenience method to transform this molecule by rotation and translation. Parameters: Name Type Description Default rotation np.ndarray A (3,3) rotation matrix None translation np.ndarray A (3,) vector of x, y, z coordinates of the translation None Returns: Type Description Molecule a new copy of this Molecule transformed by the provided matrix and vector. Source code in chmpy/core/molecule.py 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 def transformed ( self , rotation = None , translation = None ): \"\"\" Convenience method to transform this molecule by rotation and translation. Args: rotation (np.ndarray): A (3,3) rotation matrix translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation Returns: Molecule: a new copy of this `Molecule` transformed by the provided matrix and vector. \"\"\" from copy import deepcopy result = deepcopy ( self ) result . transform ( rotation = rotation , translation = translation ) return result translate ( self , translation ) Convenience method to translate this molecule by a given translation vector Parameters: Name Type Description Default translation np.ndarray A (3,) vector of x, y, z coordinates of the translation required Source code in chmpy/core/molecule.py 907 908 909 910 911 912 913 914 915 def translate ( self , translation ): \"\"\" Convenience method to translate this molecule by a given translation vector Args: translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation \"\"\" self . positions += translation translated ( self , translation ) Convenience method to construct a new copy of this molecule translated by a given translation vector Parameters: Name Type Description Default translation np.ndarray A (3,) vector of x, y, z coordinates of the translation required Returns: Type Description Molecule a new copy of this Molecule translated by the given vector. Source code in chmpy/core/molecule.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 def translated ( self , translation ): \"\"\" Convenience method to construct a new copy of this molecule translated by a given translation vector Args: translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation Returns: Molecule: a new copy of this `Molecule` translated by the given vector. \"\"\" import copy result = copy . deepcopy ( self ) result . positions += translation return result","title":"Molecule"},{"location":"API/core/molecule/#chmpy.core.molecule","text":"","title":"chmpy.core.molecule"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule","text":"Class to represent information about a molecule i.e. a set of atoms with 3D coordinates joined by covalent bonds e.g. int, float, str etc. Will handle uncertainty values contained in parentheses. Attributes: Name Type Description elements ndarray list of element information for each atom in this molecule positions ndarray (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) bonds dok_matrix (N, N) adjacency matrix of bond lengths for connected atoms, 0 otherwise. If not provided this will be calculated. labels ndarray (N,) vector of string labels for each atom in this molecule If not provided this will assigned default labels i.e. numbered in order. proerties Additional keyword arguments will be stored in the properties member, and some may be utilized in methods, raising an exception if they are not set.","title":"Molecule"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.asym_symops","text":"the symmetry operations which generate this molecule (default x,y,z if not set)","title":"asym_symops"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.atomic_numbers","text":"Atomic numbers for each atom in this molecule","title":"atomic_numbers"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.bbox_corners","text":"the lower, upper corners of a axis-aligned bounding box for this molecule","title":"bbox_corners"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.bbox_size","text":"the dimensions of the axis-aligned bounding box for this molecule","title":"bbox_size"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.center_of_mass","text":"Mean cartesian position of atoms in this molecule, weighted by atomic mass","title":"center_of_mass"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.centroid","text":"Mean cartesian position of atoms in this molecule","title":"centroid"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.distance_matrix","text":"The (dense) pairwise distance matrix for this molecule","title":"distance_matrix"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.molecular_formula","text":"string of the molecular formula for this molecule","title":"molecular_formula"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.name","text":"The name of this molecule, checks 'GENERIC_NAME' and 'name' keys in self.properties","title":"name"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.partial_charges","text":"The partial charges associated with atoms in this molecule. If self._partial_charges is not set, the charges will be assigned based on EEM method.","title":"partial_charges"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.unique_bonds","text":"The unique bonds for this molecule. If bonds are not assigned, this will None","title":"unique_bonds"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.__init__","text":"Initialize a new molecule. Parameters: Name Type Description Default elements List[Element] N length list of elements associated with the sites required positions array_like (N, 3) array of site positions in Cartesian coordinates required bonds dok_matrix if bonds are already calculated provide them here None labels array_like labels (array_like): N length array of string labels for each site None kwargs Additional properties (will populate the properties member) to store in this molecule {} Source code in chmpy/core/molecule.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , elements , positions , bonds = None , labels = None , ** kwargs ): \"\"\" Initialize a new molecule. Arguments: elements (List[Element]): N length list of elements associated with the sites positions (array_like): (N, 3) array of site positions in Cartesian coordinates bonds (dok_matrix, optional): if bonds are already calculated provide them here labels (array_like, optional): labels (array_like): N length array of string labels for each site kwargs: Additional properties (will populate the properties member) to store in this molecule \"\"\" self . positions = positions self . elements = elements self . properties = {} self . properties . update ( kwargs ) self . bonds = None self . charge = kwargs . get ( \"charge\" , 0 ) self . multiplicity = kwargs . get ( \"multiplicity\" , 1 ) if bonds is None : if kwargs . get ( \"guess_bonds\" , False ): self . guess_bonds () else : self . bonds = dok_matrix ( bonds ) if labels is None : self . assign_default_labels () else : self . labels = labels","title":"__init__()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.assign_default_labels","text":"Assign the default labels to atom sites in this molecule (number them by element) Source code in chmpy/core/molecule.py 162 163 164 165 166 167 168 169 def assign_default_labels ( self ): \"Assign the default labels to atom sites in this molecule (number them by element)\" counts = defaultdict ( int ) labels = [] for el , _ in self : counts [ el ] += 1 labels . append ( \" {}{} \" . format ( el . symbol , counts [ el ])) self . labels = np . asarray ( labels )","title":"assign_default_labels()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.atomic_shape_descriptors","text":"Calculate the shape descriptors [1,2] for all atoms in this isolated molecule. If you wish to use the crystal environment please see the corresponding method in :obj: chmpy.crystal.Crystal . Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the shape function. (default=5) 5 radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms (default=6.0) 6.0 background float 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) 1e-05 Returns: Type Description ndarray shape description vector References [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/core/molecule.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def atomic_shape_descriptors ( self , l_max = 5 , radius = 6.0 , background = 1e-5 ) -> np . ndarray : \"\"\" Calculate the shape descriptors`[1,2]` for all atoms in this isolated molecule. If you wish to use the crystal environment please see the corresponding method in :obj:`chmpy.crystal.Crystal`. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the shape function. (default=5) radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms (default=6.0) background (float, optional): 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) Returns: shape description vector References ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) elements = self . atomic_numbers positions = self . positions dists = self . distance_matrix for n in range ( elements . shape [ 0 ]): els = elements [ n : n + 1 ] pos = positions [ n : n + 1 , :] idxs = np . where (( dists [ n , :] < radius ) & ( dists [ n , :] > 1e-3 ))[ 0 ] neighbour_els = elements [ idxs ] neighbour_pos = positions [ idxs ] ubound = Element [ n ] . vdw_radius * 3 descriptors . append ( stockholder_weight_descriptor ( sph , els , pos , neighbour_els , neighbour_pos , bounds = ( 0.2 , ubound ), background = background , ) ) return np . asarray ( descriptors )","title":"atomic_shape_descriptors()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.atomic_stockholder_weight_isosurfaces","text":"Calculate the stockholder weight isosurfaces for the atoms in this molecule, with the provided background density. Parameters: Name Type Description Default kwargs dict keyword arguments to be passed to isosurface generation code Options are: background : float , optional 'background' density to ensure closed surfaces for isolated atoms ( default = 1 e - 5 ) isovalue : float , optional level set value for the isosurface ( default = 0.5 ). Must be between 0 and 1 , but values other than 0.5 probably won 't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of (' d_norm_i ', ' d_i ', ' d_norm_e ', ' d_e ', ' d_norm ') colormap: str, optional matplotlib colormap to use for surface coloring (default ' viridis_r ' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description List[trimesh.Trimesh] A list of meshes representing the stockholder weight isosurfaces Source code in chmpy/core/molecule.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 def atomic_stockholder_weight_isosurfaces ( self , ** kwargs ): \"\"\" Calculate the stockholder weight isosurfaces for the atoms in this molecule, with the provided background density. Args: kwargs (dict): keyword arguments to be passed to isosurface generation code Options are: ``` background: float, optional 'background' density to ensure closed surfaces for isolated atoms (default=1e-5) isovalue: float, optional level set value for the isosurface (default=0.5). Must be between 0 and 1, but values other than 0.5 probably won't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e', 'd_norm') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: List[trimesh.Trimesh]: A list of meshes representing the stockholder weight isosurfaces \"\"\" from chmpy import StockholderWeight from chmpy.surface import stockholder_weight_isosurface from matplotlib.cm import get_cmap import trimesh from chmpy.util.color import DEFAULT_COLORMAPS sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) radius = kwargs . get ( \"radius\" , 12.0 ) background = kwargs . get ( \"background\" , 1e-5 ) vertex_color = kwargs . get ( \"color\" , \"d_norm_i\" ) isovalue = kwargs . get ( \"isovalue\" , 0.5 ) midpoint = kwargs . get ( \"midpoint\" , 0.0 if vertex_color == \"d_norm\" else None ) meshes = [] colormap = get_cmap ( kwargs . get ( \"colormap\" , DEFAULT_COLORMAPS . get ( vertex_color , \"viridis_r\" )) ) isos = [] elements = self . atomic_numbers positions = self . positions dists = self . distance_matrix for n in range ( elements . shape [ 0 ]): els = elements [ n : n + 1 ] pos = positions [ n : n + 1 , :] idxs = np . where (( dists [ n , :] < radius ) & ( dists [ n , :] > 1e-3 ))[ 0 ] neighbour_els = elements [ idxs ] neighbour_pos = positions [ idxs ] s = StockholderWeight . from_arrays ( els , pos , neighbour_els , neighbour_pos , background = background ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) for iso in isos : prop = iso . vertex_prop [ vertex_color ] norm = None if midpoint is not None : from matplotlib.colors import DivergingNorm norm = DivergingNorm ( vmin = prop . min (), vcenter = midpoint , vmax = prop . max ()) prop = norm ( prop ) color = colormap ( prop ) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) meshes . append ( mesh ) return meshes","title":"atomic_stockholder_weight_isosurfaces()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.bond_graph","text":"Calculate the graph_tool.Graph object corresponding to this molecule. Requires the graph_tool library to be installed Returns: Type Description graph_tool.Graph the (undirected) graph of this molecule Source code in chmpy/core/molecule.py 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 def bond_graph ( self ): \"\"\" Calculate the `graph_tool.Graph` object corresponding to this molecule. Requires the graph_tool library to be installed Returns: graph_tool.Graph: the (undirected) graph of this molecule \"\"\" if hasattr ( self , \"_bond_graph\" ): return getattr ( self , \"_bond_graph\" ) try : import graph_tool as gt except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) if self . bonds is None : self . guess_bonds () g = gt . Graph ( directed = False ) v_el = g . new_vertex_property ( \"int\" ) g . add_edge_list ( self . bonds . keys ()) e_w = g . new_edge_property ( \"float\" ) v_el . a [:] = self . atomic_numbers g . vertex_properties [ \"element\" ] = v_el e_w . a [:] = list ( self . bonds . values ()) g . edge_properties [ \"bond_distance\" ] = e_w self . _bond_graph = g return g","title":"bond_graph()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.connected_fragments","text":"Separate this molecule into fragments/molecules based on covalent bonding criteria. Returns: Type Description List a list of connected Molecule objects Source code in chmpy/core/molecule.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def connected_fragments ( self ) -> List : \"\"\" Separate this molecule into fragments/molecules based on covalent bonding criteria. Returns: a list of connected `Molecule` objects \"\"\" from chmpy.util.num import cartesian_product from scipy.sparse.csgraph import connected_components if self . bonds is None : self . guess_bonds () nfrag , labels = connected_components ( self . bonds ) molecules = [] for frag in range ( nfrag ): atoms = np . where ( labels == frag )[ 0 ] na = len ( atoms ) sqidx = cartesian_product ( atoms , atoms ) molecules . append ( Molecule ( [ self . elements [ i ] for i in atoms ], self . positions [ atoms ], labels = self . labels [ atoms ], bonds = self . bonds [ sqidx [:, 0 ], sqidx [:, 1 ]] . reshape ( na , na ), ) ) return molecules","title":"connected_fragments()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.distance_to","text":"Calculate the euclidean distance between this molecule and another. May use the distance between centres-of-mass, centroids, or nearest atoms. Parameters other (Molecule): the molecule to calculate distance to method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom' Source code in chmpy/core/molecule.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def distance_to ( self , other , method = \"centroid\" ): \"\"\" Calculate the euclidean distance between this molecule and another. May use the distance between centres-of-mass, centroids, or nearest atoms. Parameters other (Molecule): the molecule to calculate distance to method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom' \"\"\" method = method . lower () if method == \"centroid\" : return np . linalg . norm ( self . centroid - other . centroid ) elif method == \"center_of_mass\" : return np . linalg . norm ( self . center_of_mass - other . center_of_mass ) elif method == \"nearest_atom\" : return np . min ( cdist ( self . positions , other . positions )) else : raise ValueError ( f \"Unknown method= { method } \" )","title":"distance_to()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.electrostatic_potential","text":"Calculate the electrostatic potential based on the partial charges associated with this molecule. The potential will be in atomic units. Parameters: Name Type Description Default positions np.ndarray (N, 3) array of locations where the molecular ESP should be calculated. Assumed to be in Angstroms. required Returns: Type Description ndarray np.ndarray: (N,) array of electrostatic potential values (atomic units) at the given positions. Source code in chmpy/core/molecule.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 def electrostatic_potential ( self , positions ) -> np . ndarray : \"\"\" Calculate the electrostatic potential based on the partial charges associated with this molecule. The potential will be in atomic units. Args: positions (np.ndarray): (N, 3) array of locations where the molecular ESP should be calculated. Assumed to be in Angstroms. Returns: np.ndarray: (N,) array of electrostatic potential values (atomic units) at the given positions. \"\"\" from chmpy.util.unit import BOHR_TO_ANGSTROM BOHR_PER_ANGSTROM = 1 / BOHR_TO_ANGSTROM v_pot = np . zeros ( positions . shape [ 0 ]) for charge , position in zip ( self . partial_charges , self . positions ): if charge == 0.0 : continue r = np . linalg . norm ( positions - position [ np . newaxis , :], axis = 1 ) v_pot += charge / ( r * BOHR_PER_ANGSTROM ) return v_pot","title":"electrostatic_potential()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_arrays","text":"Construct a molecule from the provided arrays. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default elements np.ndarray (N,) array of atomic numbers for each atom in this molecule required positions np.ndarray (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) required Returns: Type Description Molecule a new molecule object Source code in chmpy/core/molecule.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 @classmethod def from_arrays ( cls , elements , positions , ** kwargs ): \"\"\" Construct a molecule from the provided arrays. kwargs will be passed through to the Molecule constructor. Args: elements (np.ndarray): (N,) array of atomic numbers for each atom in this molecule positions (np.ndarray): (N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms) Returns: Molecule: a new molecule object \"\"\" return cls ([ Element [ x ] for x in elements ], np . array ( positions ), ** kwargs )","title":"from_arrays()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_sdf_dict","text":"Construct a molecule from the provided dictionary of sdf terms. Not intended for typical use cases, but as a helper method for Molecule.from_sdf_file Parameters: Name Type Description Default sdf_dict dict a dictionary containing the 'atoms', 'x', 'y', 'z', 'symbol', 'bonds' members. required Returns: Type Description Molecule Molecule: a new Molecule from the provided data Source code in chmpy/core/molecule.py 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 @classmethod def from_sdf_dict ( cls , sdf_dict , ** kwargs ) -> \"Molecule\" : \"\"\" Construct a molecule from the provided dictionary of sdf terms. Not intended for typical use cases, but as a helper method for `Molecule.from_sdf_file` Args: sdf_dict (dict): a dictionary containing the 'atoms', 'x', 'y', 'z', 'symbol', 'bonds' members. Returns: Molecule: a new `Molecule` from the provided data \"\"\" atoms = sdf_dict [ \"atoms\" ] positions = np . c_ [ atoms [ \"x\" ], atoms [ \"y\" ], atoms [ \"z\" ]] elements = [ Element [ x ] for x in atoms [ \"symbol\" ]] # TODO use bonds from SDF # bonds = sdf_dict[\"bonds\"] m = cls ( elements , positions , ** sdf_dict [ \"data\" ]) if \"sdf\" in sdf_dict : m . properties [ \"sdf\" ] = sdf_dict [ \"sdf\" ] return m","title":"from_sdf_dict()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_sdf_file","text":"Construct a molecule from the provided SDF file. Because an SDF file can have multiple molecules, an optional keyword argument 'progress' may be provided to track the loading of many molecules. Parameters: Name Type Description Default filename str the path of the SDF file to read. required Returns: Type Description Molecule a new Molecule or list of :obj: Molecule objects from the provided SDF file. Source code in chmpy/core/molecule.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 @classmethod def from_sdf_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided SDF file. Because an SDF file can have multiple molecules, an optional keyword argument 'progress' may be provided to track the loading of many molecules. Args: filename (str): the path of the SDF file to read. Returns: Molecule: a new `Molecule` or list of :obj:`Molecule` objects from the provided SDF file. \"\"\" from chmpy.fmt.sdf import parse_sdf_file sdf_data = parse_sdf_file ( filename , ** kwargs ) progress = kwargs . get ( \"progress\" , False ) update = lambda x : None if progress : from tqdm import tqdm pbar = tqdm ( desc = \"Creating molecule objects\" , total = len ( sdf_data ), leave = False ) update = pbar . update molecules = [] for d in sdf_data : molecules . append ( cls . from_sdf_dict ( d , ** kwargs )) update ( 1 ) if progress : pbar . close () if len ( molecules ) == 1 : return molecules [ 0 ] return molecules","title":"from_sdf_file()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_turbomole_file","text":"Construct a molecule from the provided turbomole file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default filename str the path to the .xyz file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 @classmethod def from_turbomole_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided turbomole file. kwargs will be passed through to the Molecule constructor. Args: filename (str): the path to the .xyz file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" return cls . from_turbomole_string ( Path ( filename ) . read_text (), ** kwargs )","title":"from_turbomole_file()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_turbomole_string","text":"Construct a molecule from the provided turbomole file contents. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default contents str the contents of the .xyz file to read required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @classmethod def from_turbomole_string ( cls , contents , ** kwargs ): \"\"\" Construct a molecule from the provided turbomole file contents. kwargs will be passed through to the Molecule constructor. Args: contents (str): the contents of the .xyz file to read kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" from chmpy.fmt.tmol import parse_tmol_string elements , positions = parse_tmol_string ( contents ) return cls ( elements , np . asarray ( positions ), ** kwargs )","title":"from_turbomole_string()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_xyz_file","text":"Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default filename str the path to the .xyz file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @classmethod def from_xyz_file ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Args: filename (str): the path to the .xyz file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" return cls . from_xyz_string ( Path ( filename ) . read_text (), ** kwargs )","title":"from_xyz_file()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.from_xyz_string","text":"Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Parameters: Name Type Description Default contents str the contents of the .xyz file to read required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @classmethod def from_xyz_string ( cls , contents , ** kwargs ): \"\"\" Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor. Args: contents (str): the contents of the .xyz file to read kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" from chmpy.fmt.xyz_file import parse_xyz_string elements , positions = parse_xyz_string ( contents ) return cls ( elements , np . asarray ( positions ), ** kwargs )","title":"from_xyz_string()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.functional_groups","text":"Find all indices of atom groups which constitute subgraph isomorphisms with stored functional group data Parameters: Name Type Description Default kind str Find only matches of the given kind None Returns: Type Description Union[dict, List] Either a dict with keys as functional group type and values as list of lists of indices, or a list of lists of indices if kind is specified. Source code in chmpy/core/molecule.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def functional_groups ( self , kind = None ) -> Union [ dict , List ]: \"\"\" Find all indices of atom groups which constitute subgraph isomorphisms with stored functional group data Args: kind (str, optional):Find only matches of the given kind Returns: Either a dict with keys as functional group type and values as list of lists of indices, or a list of lists of indices if kind is specified. \"\"\" global _FUNCTIONAL_GROUP_SUBGRAPHS try : import graph_tool.topology as top # noqa: F401 except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) if not _FUNCTIONAL_GROUP_SUBGRAPHS : from chmpy.subgraphs import load_data _FUNCTIONAL_GROUP_SUBGRAPHS = load_data () if kind is not None : sub = _FUNCTIONAL_GROUP_SUBGRAPHS [ kind ] matches = self . matching_subgraph ( sub ) if kind == \"ring\" : matches = list ( set ( tuple ( sorted ( x )) for x in matches )) return matches matches = {} for n , sub in _FUNCTIONAL_GROUP_SUBGRAPHS . items (): m = self . matching_subgraph ( sub ) if n == \"ring\" : m = list ( set ( tuple ( sorted ( x )) for x in m )) matches [ n ] = m return matches","title":"functional_groups()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.guess_bonds","text":"Use geometric distances and covalent radii to determine bonding information for this molecule. Bonding is determined by the distance between sites being closer than the sum of covalent radii + tolerance Will set the bonds member. If the graph_tool library is available, this will call the bond_graph method to populate the connectivity graph. Parameters: Name Type Description Default tolerance float Additional tolerance for attributing two sites as 'bonded'. The default is 0.4 angstroms, which is recommended by the CCDC 0.4 Source code in chmpy/core/molecule.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def guess_bonds ( self , tolerance = 0.40 ): \"\"\" Use geometric distances and covalent radii to determine bonding information for this molecule. Bonding is determined by the distance between sites being closer than the sum of covalent radii + `tolerance` Will set the `bonds` member. If the `graph_tool` library is available, this will call the `bond_graph` method to populate the connectivity graph. Args: tolerance (float, optional): Additional tolerance for attributing two sites as 'bonded'. The default is 0.4 angstroms, which is recommended by the CCDC \"\"\" tree = KDTree ( self . positions ) covalent_radii = np . array ([ x . cov for x in self . elements ]) max_cov = np . max ( covalent_radii ) thresholds = ( covalent_radii [:, np . newaxis ] + covalent_radii [ np . newaxis , :] + tolerance ) max_distance = max_cov * 2 + tolerance dist = tree . sparse_distance_matrix ( tree , max_distance = max_distance ) . toarray () mask = ( dist > 0 ) & ( dist < thresholds ) self . bonds = np . zeros ( dist . shape ) self . bonds [ mask ] = dist [ mask ] self . bonds = dok_matrix ( self . bonds ) try : self . bond_graph () except Exception : pass","title":"guess_bonds()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.load","text":"Construct a molecule from the provided file. Parameters: Name Type Description Default filename str the path to the (xyz or SDF) file required kwargs keyword arguments passed ot the Molecule constructor {} Returns: Type Description Molecule A new Molecule object Source code in chmpy/core/molecule.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 @classmethod def load ( cls , filename , ** kwargs ): \"\"\" Construct a molecule from the provided file. Args: filename (str): the path to the (xyz or SDF) file kwargs: keyword arguments passed ot the `Molecule` constructor Returns: Molecule: A new `Molecule` object \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = cls . _fname_load_map () if n in fname_map : return fname_map [ n ]( filename ) extension_map = cls . _ext_load_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs )","title":"load()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.mask","text":"Convenience method to construct a new molecule from this molecule with the given mask array. Parameters: Name Type Description Default mask np.ndarray a numpy mask array used to filter which atoms to keep in the new molecule. required Returns: Type Description Molecule a new Molecule , with atoms filtered by the mask. Source code in chmpy/core/molecule.py 859 860 861 862 863 864 865 866 867 868 869 870 871 872 def mask ( self , mask , ** kwargs ): \"\"\" Convenience method to construct a new molecule from this molecule with the given mask array. Args: mask (np.ndarray): a numpy mask array used to filter which atoms to keep in the new molecule. Returns: Molecule: a new `Molecule`, with atoms filtered by the mask. \"\"\" return Molecule . from_arrays ( self . atomic_numbers [ mask ], self . positions [ mask ], ** kwargs )","title":"mask()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.matching_fragments","text":"Find the indices of a matching fragment to the given molecular fragment Parameters: Name Type Description Default fragment Molecule Molecule object containing the desired fragment required method str the method for matching 'connectivity' Returns: Type Description List[dict] List of maps between matching indices in this molecule and those in the fragment Source code in chmpy/core/molecule.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 def matching_fragments ( self , fragment , method = \"connectivity\" ): \"\"\" Find the indices of a matching fragment to the given molecular fragment Args: fragment (Molecule): Molecule object containing the desired fragment method (str, optional): the method for matching Returns: List[dict]: List of maps between matching indices in this molecule and those in the fragment \"\"\" try : import graph_tool.topology as top except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) sub = fragment . bond_graph () g = self . bond_graph () matches = top . subgraph_isomorphism ( sub , g , vertex_label = ( sub . vertex_properties [ \"element\" ], g . vertex_properties [ \"element\" ], ), ) return [ list ( x . a ) for x in matches ]","title":"matching_fragments()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.matching_subgraph","text":"Find all indices of atoms which match the given graph. Parameters: Name Type Description Default sub graph_tool.Graph the subgraph required Returns: Type Description List list of lists of atomic indices matching the atoms in sub to those in this molecule Source code in chmpy/core/molecule.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 def matching_subgraph ( self , sub ): \"\"\"Find all indices of atoms which match the given graph. Args: sub (graph_tool.Graph): the subgraph Returns: List: list of lists of atomic indices matching the atoms in sub to those in this molecule \"\"\" try : import graph_tool.topology as top except ImportError : raise RuntimeError ( \"Please install the graph_tool library for graph operations\" ) g = self . bond_graph () matches = top . subgraph_isomorphism ( sub , g , vertex_label = ( sub . vertex_properties [ \"element\" ], g . vertex_properties [ \"element\" ], ), ) return [ tuple ( x . a ) for x in matches ]","title":"matching_subgraph()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.promolecule_density_isosurface","text":"Calculate promolecule electron density isosurface for this molecule. Parameters: Name Type Description Default kwargs keyword arguments passed to promolecule_density_isosurface Options are: isovalue : float , optional level set value for the isosurface ( default = 0.002 ) in au . separation : float , optional separation between density grid used in the surface calculation ( default 0.2 ) in Angstroms . color : str , optional surface property to use for vertex coloring , one of ( 'd_norm_i' , 'd_i' , 'd_norm_e' , 'd_e' ) colormap : str , optional matplotlib colormap to use for surface coloring ( default 'viridis_r' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description trimesh.Trimesh A mesh representing the promolecule density isosurface Source code in chmpy/core/molecule.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def promolecule_density_isosurface ( self , ** kwargs ): \"\"\" Calculate promolecule electron density isosurface for this molecule. Args: kwargs: keyword arguments passed to `promolecule_density_isosurface` Options are: ``` isovalue: float, optional level set value for the isosurface (default=0.002) in au. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: trimesh.Trimesh: A mesh representing the promolecule density isosurface \"\"\" from chmpy import PromoleculeDensity from chmpy.surface import promolecule_density_isosurface from chmpy.util.color import property_to_color import trimesh isovalue = kwargs . get ( \"isovalue\" , 0.002 ) sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) vertex_color = kwargs . get ( \"color\" , \"d_norm_i\" ) extra_props = {} pro = PromoleculeDensity (( self . atomic_numbers , self . positions )) if vertex_color == \"esp\" : extra_props [ \"esp\" ] = self . electrostatic_potential iso = promolecule_density_isosurface ( pro , sep = sep , isovalue = isovalue , extra_props = extra_props ) prop = iso . vertex_prop [ vertex_color ] color = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , vertex_color )) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) return mesh","title":"promolecule_density_isosurface()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.rotate","text":"Convenience method to rotate this molecule by a given rotation matrix Parameters: Name Type Description Default rotation np.ndarray A (3, 3) rotation matrix required Source code in chmpy/core/molecule.py 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 def rotate ( self , rotation , origin = ( 0 , 0 , 0 )): \"\"\" Convenience method to rotate this molecule by a given rotation matrix Args: rotation (np.ndarray): A (3, 3) rotation matrix \"\"\" if np . allclose ( origin , ( 0 , 0 , 0 )): np . dot ( self . positions , rotation , out = self . positions ) else : self . positions -= origin np . dot ( self . positions , rotation , out = self . positions ) self . positions += origin","title":"rotate()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.rotated","text":"Convenience method to construct a new copy of thismolecule rotated by a given rotation matrix Parameters: Name Type Description Default rotation np.ndarray A (3, 3) rotation matrix required Returns: Type Description Molecule a new copy of this Molecule rotated by the given rotation matrix. Source code in chmpy/core/molecule.py 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 def rotated ( self , rotation , origin = ( 0 , 0 , 0 )): \"\"\" Convenience method to construct a new copy of thismolecule rotated by a given rotation matrix Args: rotation (np.ndarray): A (3, 3) rotation matrix Returns: Molecule: a new copy of this `Molecule` rotated by the given rotation matrix. \"\"\" from copy import deepcopy result = deepcopy ( self ) result . rotate ( rotation , origin = origin ) return result","title":"rotated()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.save","text":"Save this molecule to the destination file in xyz format, optionally discarding the typical header. Parameters: Name Type Description Default filename str path to the destination file required kwargs keyword arguments passed to the relevant method {} Source code in chmpy/core/molecule.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def save ( self , filename , ** kwargs ): \"\"\" Save this molecule to the destination file in xyz format, optionally discarding the typical header. Args: filename (str): path to the destination file kwargs: keyword arguments passed to the relevant method \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = self . _fname_save_map () if n in fname_map : return fname_map [ n ]( filename , ** kwargs ) extension_map = self . _ext_save_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs )","title":"save()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.shape_descriptors","text":"Calculate the molecular shape descriptors [1,2] for this molecule using the promolecule density. Parameters: Name Type Description Default kwargs keyword arguments passed to promolecule_density_descriptor Options are: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. with_property (str, optional): describe the combination of the radial shape function and a surface property in the real, imaginary channels of a complex function isovalue (float, optional): the isovalue for the promolecule density surface (default 0.0002 au) {} Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/core/molecule.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def shape_descriptors ( self , l_max = 5 , ** kwargs ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors`[1,2]` for this molecule using the promolecule density. Args: kwargs: keyword arguments passed to `promolecule_density_descriptor` Options are: ``` l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. with_property (str, optional): describe the combination of the radial shape function and a surface property in the real, imaginary channels of a complex function isovalue (float, optional): the isovalue for the promolecule density surface (default 0.0002 au) ``` Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , promolecule_density_descriptor sph = SHT ( l_max = l_max ) return promolecule_density_descriptor ( sph , self . atomic_numbers , self . positions , ** kwargs )","title":"shape_descriptors()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.to_mesh","text":"Convert this molecule to a mesh of spheres and cylinders, colored by element. The origins of the spheres will be at the corresponding atomic position, and all units will be Angstroms. Returns: Type Description dict a dictionary of trimesh.Trimesh objects representing this molecule. Source code in chmpy/core/molecule.py 818 819 820 821 822 823 824 825 826 827 828 829 830 def to_mesh ( self , ** kwargs ): \"\"\" Convert this molecule to a mesh of spheres and cylinders, colored by element. The origins of the spheres will be at the corresponding atomic position, and all units will be Angstroms. Returns: dict: a dictionary of `trimesh.Trimesh` objects representing this molecule. \"\"\" from chmpy.util.mesh import molecule_to_meshes return molecule_to_meshes ( self , ** kwargs )","title":"to_mesh()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.to_xyz_file","text":"Represent this molecule as an of an xmol .xyz file. Keyword arguments are passed to self.to_xyz_string . Parameters: Name Type Description Default filename str The path in which store this molecule required kwargs Keyword arguments to be passed to self.to_xyz_string {} Source code in chmpy/core/molecule.py 414 415 416 417 418 419 420 421 422 423 424 425 def to_xyz_file ( self , filename , ** kwargs ): \"\"\" Represent this molecule as an of an xmol .xyz file. Keyword arguments are passed to `self.to_xyz_string`. Args: filename (str): The path in which store this molecule kwargs: Keyword arguments to be passed to `self.to_xyz_string` \"\"\" Path ( filename ) . write_text ( self . to_xyz_string ( ** kwargs ))","title":"to_xyz_file()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.to_xyz_string","text":"Represent this molecule as a string in the format of an xmol .xyz file. Parameters: Name Type Description Default header bool toggle whether or not to return the 'header' of the xyz file i.e. the number of atoms line and the comment line True Returns: Type Description str contents (str) the contents of the .xyz file Source code in chmpy/core/molecule.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def to_xyz_string ( self , header = True ) -> str : \"\"\" Represent this molecule as a string in the format of an xmol .xyz file. Args: header (bool, optional):toggle whether or not to return the 'header' of the xyz file i.e. the number of atoms line and the comment line Returns: contents (str) the contents of the .xyz file \"\"\" if header : lines = [ f \" { len ( self ) } \" , self . properties . get ( \"comment\" , self . molecular_formula ), ] else : lines = [] for el , ( x , y , z ) in zip ( self . elements , self . positions ): lines . append ( f \" { el } { x : 20.12f } { y : 20.12f } { z : 20.12f } \" ) return \" \\n \" . join ( lines )","title":"to_xyz_string()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.transform","text":"Convenience method to transform this molecule by rotation and translation. Parameters: Name Type Description Default rotation np.ndarray A (3,3) rotation matrix None translation np.ndarray A (3,) vector of x, y, z coordinates of the translation None Source code in chmpy/core/molecule.py 934 935 936 937 938 939 940 941 942 943 944 945 946 947 def transform ( self , rotation = None , translation = None ): \"\"\" Convenience method to transform this molecule by rotation and translation. Args: rotation (np.ndarray): A (3,3) rotation matrix translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation \"\"\" if rotation is not None : self . rotate ( rotation , origin = ( 0 , 0 , 0 )) if translation is not None : self . translate ( translation )","title":"transform()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.transformed","text":"Convenience method to transform this molecule by rotation and translation. Parameters: Name Type Description Default rotation np.ndarray A (3,3) rotation matrix None translation np.ndarray A (3,) vector of x, y, z coordinates of the translation None Returns: Type Description Molecule a new copy of this Molecule transformed by the provided matrix and vector. Source code in chmpy/core/molecule.py 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 def transformed ( self , rotation = None , translation = None ): \"\"\" Convenience method to transform this molecule by rotation and translation. Args: rotation (np.ndarray): A (3,3) rotation matrix translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation Returns: Molecule: a new copy of this `Molecule` transformed by the provided matrix and vector. \"\"\" from copy import deepcopy result = deepcopy ( self ) result . transform ( rotation = rotation , translation = translation ) return result","title":"transformed()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.translate","text":"Convenience method to translate this molecule by a given translation vector Parameters: Name Type Description Default translation np.ndarray A (3,) vector of x, y, z coordinates of the translation required Source code in chmpy/core/molecule.py 907 908 909 910 911 912 913 914 915 def translate ( self , translation ): \"\"\" Convenience method to translate this molecule by a given translation vector Args: translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation \"\"\" self . positions += translation","title":"translate()"},{"location":"API/core/molecule/#chmpy.core.molecule.Molecule.translated","text":"Convenience method to construct a new copy of this molecule translated by a given translation vector Parameters: Name Type Description Default translation np.ndarray A (3,) vector of x, y, z coordinates of the translation required Returns: Type Description Molecule a new copy of this Molecule translated by the given vector. Source code in chmpy/core/molecule.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 def translated ( self , translation ): \"\"\" Convenience method to construct a new copy of this molecule translated by a given translation vector Args: translation (np.ndarray): A (3,) vector of x, y, z coordinates of the translation Returns: Molecule: a new copy of this `Molecule` translated by the given vector. \"\"\" import copy result = copy . deepcopy ( self ) result . positions += translation return result","title":"translated()"},{"location":"API/crystal/asymmetric_unit/","text":"AsymmetricUnit Storage class for the coordinates and labels in a crystal asymmetric unit Attributes: Name Type Description elements List[Element] N length list of elements associated with the sites in this asymmetric unit positions array_like (N, 3) array of site positions in fractional coordinates labels array_like N length array of string labels for each site formula property readonly Molecular formula for this asymmetric unit __init__ ( self , elements , positions , labels = None , ** kwargs ) special Create an asymmetric unit object from a list of Elements and an array of fractional coordinates. Parameters: Name Type Description Default elements List[Element] N length list of elements associated with the sites required positions array_like (N, 3) array of site positions in fractional coordinates required labels array_like labels (array_like): N length array of string labels for each site None **kwargs Additional properties (will populate the properties member) to store in this asymmetric unit {} Source code in chmpy/crystal/asymmetric_unit.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , elements , positions , labels = None , ** kwargs ): \"\"\" Create an asymmetric unit object from a list of Elements and an array of fractional coordinates. Arguments: elements (List[Element]): N length list of elements associated with the sites positions (array_like): (N, 3) array of site positions in fractional coordinates labels (array_like, optional): labels (array_like): N length array of string labels for each site **kwargs: Additional properties (will populate the properties member) to store in this asymmetric unit \"\"\" self . elements = elements self . atomic_numbers = np . asarray ([ x . atomic_number for x in elements ]) self . positions = np . asarray ( positions ) self . properties = {} self . properties . update ( kwargs ) if labels is None : self . labels = [] label_index = defaultdict ( int ) for el in self . elements : label_index [ el ] += 1 self . labels . append ( \" {}{} \" . format ( el , label_index [ el ])) else : self . labels = labels self . labels = np . array ( self . labels ) from_records ( records ) classmethod Initialize an AsymmetricUnit from a list of dictionary like objects Parameters: Name Type Description Default records iterable An iterable containing dict_like objects with label , element , position and optionally occupation stored. required Source code in chmpy/crystal/asymmetric_unit.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @classmethod def from_records ( cls , records ): \"\"\"Initialize an AsymmetricUnit from a list of dictionary like objects Arguments: records (iterable): An iterable containing dict_like objects with `label`, `element`, `position` and optionally `occupation` stored. \"\"\" labels = [] elements = [] positions = [] occupation = [] for r in records : labels . append ( r [ \"label\" ]) elements . append ( Element [ r [ \"element\" ]]) positions . append ( r [ \"position\" ]) occupation . append ( r . get ( \"occupation\" , 1.0 )) positions = np . asarray ( positions ) return AsymmetricUnit ( elements , positions , labels = labels , occupation = occupation )","title":"Asymmetric Unit"},{"location":"API/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit","text":"","title":"chmpy.crystal.asymmetric_unit"},{"location":"API/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit","text":"Storage class for the coordinates and labels in a crystal asymmetric unit Attributes: Name Type Description elements List[Element] N length list of elements associated with the sites in this asymmetric unit positions array_like (N, 3) array of site positions in fractional coordinates labels array_like N length array of string labels for each site","title":"AsymmetricUnit"},{"location":"API/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.formula","text":"Molecular formula for this asymmetric unit","title":"formula"},{"location":"API/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.__init__","text":"Create an asymmetric unit object from a list of Elements and an array of fractional coordinates. Parameters: Name Type Description Default elements List[Element] N length list of elements associated with the sites required positions array_like (N, 3) array of site positions in fractional coordinates required labels array_like labels (array_like): N length array of string labels for each site None **kwargs Additional properties (will populate the properties member) to store in this asymmetric unit {} Source code in chmpy/crystal/asymmetric_unit.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , elements , positions , labels = None , ** kwargs ): \"\"\" Create an asymmetric unit object from a list of Elements and an array of fractional coordinates. Arguments: elements (List[Element]): N length list of elements associated with the sites positions (array_like): (N, 3) array of site positions in fractional coordinates labels (array_like, optional): labels (array_like): N length array of string labels for each site **kwargs: Additional properties (will populate the properties member) to store in this asymmetric unit \"\"\" self . elements = elements self . atomic_numbers = np . asarray ([ x . atomic_number for x in elements ]) self . positions = np . asarray ( positions ) self . properties = {} self . properties . update ( kwargs ) if labels is None : self . labels = [] label_index = defaultdict ( int ) for el in self . elements : label_index [ el ] += 1 self . labels . append ( \" {}{} \" . format ( el , label_index [ el ])) else : self . labels = labels self . labels = np . array ( self . labels )","title":"__init__()"},{"location":"API/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.from_records","text":"Initialize an AsymmetricUnit from a list of dictionary like objects Parameters: Name Type Description Default records iterable An iterable containing dict_like objects with label , element , position and optionally occupation stored. required Source code in chmpy/crystal/asymmetric_unit.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @classmethod def from_records ( cls , records ): \"\"\"Initialize an AsymmetricUnit from a list of dictionary like objects Arguments: records (iterable): An iterable containing dict_like objects with `label`, `element`, `position` and optionally `occupation` stored. \"\"\" labels = [] elements = [] positions = [] occupation = [] for r in records : labels . append ( r [ \"label\" ]) elements . append ( Element [ r [ \"element\" ]]) positions . append ( r [ \"position\" ]) occupation . append ( r . get ( \"occupation\" , 1.0 )) positions = np . asarray ( positions ) return AsymmetricUnit ( elements , positions , labels = labels , occupation = occupation )","title":"from_records()"},{"location":"API/crystal/crystal/","text":"crystal Contains the Crystal objects, for 3D systems. Crystal Storage class for a molecular crystal structure. Attributes: Name Type Description unit_cell UnitCell the translational symmetry space_group SpaceGroup the symmetry within the unit cell asymmetric_unit AsymmetricUnit the symmetry unique set of sites in the crystal. Contains information on atomic positions, elements, labels etc. properties dict variable collection of named properties for this crystal asym: AsymmetricUnit property readonly short accessor for asymmetric_unit density property readonly Calculated density of this crystal structure in g/cm^3 id: str property readonly synonym for titl name: str property readonly synonym for titl nsites: int property readonly The number of sites in the asymmetric unit. sg: SpaceGroup property readonly short accessor for space_group site_atoms: ndarray property readonly Array of asymmetric unit atomic numbers site_labels property readonly array of labels for sites in the asymmetric_unit site_positions: ndarray property readonly Row major array of asymmetric unit atomic positions symmetry_operations: List [ chmpy . crystal . symmetry_operation . SymmetryOperation ] property readonly Symmetry operations belonging to the space group symmetry of this crystal. uc: UnitCell property readonly short accessor for unit_cell __init__ ( self , unit_cell , space_group , asymmetric_unit , ** kwargs ) special Construct a new crystal. Parameters: Name Type Description Default unit_cell UnitCell The unit cell for this crystal i.e. the translational symmetry of the crystal structure. required space_group SpaceGroup The space group symmetry of this crystal i.e. the generators for populating the unit cell given the asymmetric unit. required asymmetric_unit AsymmetricUnit The asymmetric unit of this crystal. The sites of this combined with the space group will generate all translationally equivalent positions. required **kwargs Optional properties to (will populate the properties member) store about the the crystal structure. {} Source code in chmpy/crystal/crystal.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , unit_cell : UnitCell , space_group : SpaceGroup , asymmetric_unit : AsymmetricUnit , ** kwargs , ): \"\"\" Construct a new crystal. Arguments: unit_cell: The unit cell for this crystal i.e. the translational symmetry of the crystal structure. space_group: The space group symmetry of this crystal i.e. the generators for populating the unit cell given the asymmetric unit. asymmetric_unit: The asymmetric unit of this crystal. The sites of this combined with the space group will generate all translationally equivalent positions. **kwargs: Optional properties to (will populate the properties member) store about the the crystal structure. \"\"\" self . space_group = space_group self . unit_cell = unit_cell self . asymmetric_unit = asymmetric_unit self . properties = {} self . properties . update ( kwargs ) as_P1 ( self ) Create a copy of this crystal in space group P 1, with the new asymmetric_unit consisting of self.unit_cell_molecules() Source code in chmpy/crystal/crystal.py 1628 1629 1630 1631 def as_P1 ( self ) -> \"Crystal\" : \"\"\"Create a copy of this crystal in space group P 1, with the new asymmetric_unit consisting of self.unit_cell_molecules()\"\"\" return self . as_P1_supercell (( 1 , 1 , 1 )) as_P1_supercell ( self , size ) Create a supercell of this crystal in space group P 1. Parameters: Name Type Description Default size Tuple[int] size of the P 1 supercell to be created required Returns: Type Description Crystal Crystal object of a supercell in space group P 1 Source code in chmpy/crystal/crystal.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 def as_P1_supercell ( self , size ) -> \"Crystal\" : \"\"\" Create a supercell of this crystal in space group P 1. Args: size (Tuple[int]): size of the P 1 supercell to be created Returns: Crystal object of a supercell in space group P 1 \"\"\" import itertools as it umax , vmax , wmax = size a , b , c = self . unit_cell . lengths sc = UnitCell . from_lengths_and_angles ( ( umax * a , vmax * b , wmax * c ), self . unit_cell . angles ) u = np . arange ( umax ) v = np . arange ( vmax ) w = np . arange ( wmax ) sc_mols = [] for q , r , s in it . product ( u , v , w ): for uc_mol in self . unit_cell_molecules (): sc_mols . append ( uc_mol . translated ( np . asarray ([ q , r , s ]) @ self . unit_cell . lattice ) ) asym_pos = np . vstack ([ x . positions for x in sc_mols ]) asym_nums = np . hstack ([ x . atomic_numbers for x in sc_mols ]) asymmetric_unit = AsymmetricUnit ( [ Element [ x ] for x in asym_nums ], sc . to_fractional ( asym_pos ) ) new_crystal = Crystal ( sc , SpaceGroup ( 1 ), asymmetric_unit ) new_crystal . properties [ \"titl\" ] = self . titl + \"-P1- {} - {} - {} \" . format ( * size ) return new_crystal asymmetric_unit_partial_charges ( self ) Calculate the partial charges for the asymmetric unit of this crystal using the EEM method. Returns: Type Description ndarray an ndarray of atomic partial charges. Source code in chmpy/crystal/crystal.py 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def asymmetric_unit_partial_charges ( self ) -> np . ndarray : \"\"\" Calculate the partial charges for the asymmetric unit of this crystal using the EEM method. Returns: an `ndarray` of atomic partial charges. \"\"\" mols = self . symmetry_unique_molecules () charges = np . empty ( len ( self . asymmetric_unit ), dtype = np . float32 ) for mol in mols : for idx , charge in zip ( mol . properties [ \"asymmetric_unit_atoms\" ], mol . partial_charges ): charges [ idx ] = charge return charges atom_group_shape_descriptors ( self , atoms , l_max = 5 , radius = 3.8 ) Calculate the shape descriptors[1,2] for the given atomic group in this crystal. Parameters: Name Type Description Default atoms Tuple atoms to include in the as the 'inside' of the shape description. required l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 3.8 Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 def atom_group_shape_descriptors ( self , atoms , l_max = 5 , radius = 3.8 ) -> np . ndarray : \"\"\"Calculate the shape descriptors[1,2] for the given atomic group in this crystal. Args: atoms (Tuple): atoms to include in the as the 'inside' of the shape description. l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) inside , outside = self . atom_group_surroundings ( atoms , radius = radius ) m = Molecule . from_arrays ( * inside ) c = np . array ( m . centroid , dtype = np . float32 ) dists = np . linalg . norm ( m . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 return np . asarray ( stockholder_weight_descriptor ( sph , * inside , * outside , origin = c , bounds = bounds ) ) atom_group_surroundings ( self , atoms , radius = 6.0 ) Calculate all atoms within the given radius of the specified group of atoms in the asymetric unit. Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion 6.0 Returns: Type Description Tuple A list of atomic number, Cartesian position for both the atomic sites in question and their surroundings (as an array) Source code in chmpy/crystal/crystal.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def atom_group_surroundings ( self , atoms , radius = 6.0 ) -> Tuple : \"\"\" Calculate all atoms within the given `radius` of the specified group of atoms in the asymetric unit. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion Returns: A list of atomic number, Cartesian position for both the atomic sites in question and their surroundings (as an array) \"\"\" hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) mol = self . symmetry_unique_molecules ()[ 0 ] central_positions = self . to_fractional ( mol . positions [ atoms ]) central_elements = mol . atomic_numbers [ atoms ] central_cart_positions = mol . positions [ atoms ] for pos in central_positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) this_mol = [] for pos in central_cart_positions : idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < 1e-3 : this_mol . append ( nn ) keep [ this_mol ] = False return ( ( central_elements , central_cart_positions ), ( elements [ keep ], positions [ keep ]), ) atomic_shape_descriptors ( self , l_max = 5 , radius = 3.8 ) Calculate the shape descriptors[1,2] for all symmetry unique atoms in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 3.8 Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 def atomic_shape_descriptors ( self , l_max = 5 , radius = 3.8 ) -> np . ndarray : \"\"\" Calculate the shape descriptors[1,2] for all symmetry unique atoms in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for n , pos , neighbour_els , neighbour_pos in self . atomic_surroundings ( radius = radius ): ubound = Element [ n ] . vdw_radius * 3 descriptors . append ( stockholder_weight_descriptor ( sph , [ n ], [ pos ], neighbour_els , neighbour_pos , bounds = ( 0.2 , ubound ) ) ) return np . asarray ( descriptors ) atomic_surroundings ( self , radius = 6.0 ) Calculate all atoms within the given radius of each atomic site in the asymmetric unit. Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion 6.0 Returns: Type Description List[Tuple] A list of atomic number, Cartesian position for both the atomic site in question and the surroundings (as an array) Source code in chmpy/crystal/crystal.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 def atomic_surroundings ( self , radius = 6.0 ) -> List [ Tuple ]: \"\"\" Calculate all atoms within the given `radius` of each atomic site in the asymmetric unit. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion Returns: A list of atomic number, Cartesian position for both the atomic site in question and the surroundings (as an array) \"\"\" cart_asym = self . to_cartesian ( self . asymmetric_unit . positions ) hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . asymmetric_unit . positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) tree = KDTree ( slab [ \"cart_pos\" ]) results = [] for n , pos in zip ( self . asymmetric_unit . elements , cart_asym ): idxs = tree . query_ball_point ( pos , radius ) positions = slab [ \"cart_pos\" ][ idxs ] elements = slab [ \"element\" ][ idxs ] d = np . linalg . norm ( positions - pos , axis = 1 ) keep = np . where ( d > 1e-3 )[ 0 ] results . append (( n . atomic_number , pos , elements [ keep ], positions [ keep ])) return results atoms_in_radius ( self , radius , origin = ( 0 , 0 , 0 )) Calculate all (periodic) atoms within the given radius of the specified origin . Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion required origin Tuple the origin in fractional coordinates (0, 0, 0) Returns: Type Description dict A dictionary mapping (see the the slab method), of those atoms within radius of the origin . Source code in chmpy/crystal/crystal.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 def atoms_in_radius ( self , radius , origin = ( 0 , 0 , 0 )) -> dict : \"\"\" Calculate all (periodic) atoms within the given `radius` of the specified `origin`. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion origin (Tuple, optional): the origin in fractional coordinates Returns: A dictionary mapping (see the the `slab` method), of those atoms within `radius` of the `origin`. \"\"\" frac_origin = self . to_fractional ( origin ) frac_radius = radius / np . array ( self . unit_cell . lengths ) hmax , kmax , lmax = np . ceil ( frac_radius + frac_origin ) . astype ( int ) hmin , kmin , lmin = np . floor ( frac_origin - frac_radius ) . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) tree = KDTree ( slab [ \"cart_pos\" ]) idxs = sorted ( tree . query_ball_point ( origin , radius )) result = { k : v [ idxs ] for k , v in slab . items () if isinstance ( v , np . ndarray )} result [ \"uc_atom\" ] = np . tile ( np . arange ( slab [ \"n_uc\" ]), slab [ \"n_cells\" ])[ idxs ] return result cartesian_symmetry_operations ( self ) Create a list of symmetry operations (rotation, translation) for evaluation of transformations in cartesian space. The rotation matrices are stored to be used as np.dot(x, R), (i.e. post-multiplicaiton on row-major coordinates) Returns: Type Description List[Tuple[np.ndarray, np.ndarray]] a list of (rotation, translation) Source code in chmpy/crystal/crystal.py 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 def cartesian_symmetry_operations ( self ): \"\"\" Create a list of symmetry operations (rotation, translation) for evaluation of transformations in cartesian space. The rotation matrices are stored to be used as np.dot(x, R), (i.e. post-multiplicaiton on row-major coordinates) Returns: List[Tuple[np.ndarray, np.ndarray]]: a list of (rotation, translation) \"\"\" cart_symops = [] d = self . unit_cell . direct i = self . unit_cell . inverse for symop in self . symmetry_operations : cart_symops . append ( ( np . dot ( d . T , np . dot ( symop . rotation , i . T )) . T , self . to_cartesian ( symop . translation ), ) ) return cart_symops choose_trigonal_lattice ( self , choice = 'H' ) Change the choice of lattice for this crystal to either rhombohedral or hexagonal cell Parameters: Name Type Description Default choice str The choice of the resulting lattice, either 'H' for hexagonal or 'R' for rhombohedral (default 'H'). 'H' Source code in chmpy/crystal/crystal.py 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 def choose_trigonal_lattice ( self , choice = \"H\" ): \"\"\" Change the choice of lattice for this crystal to either rhombohedral or hexagonal cell Args: choice (str, optional): The choice of the resulting lattice, either 'H' for hexagonal or 'R' for rhombohedral (default 'H'). \"\"\" if not self . space_group . has_hexagonal_rhombohedral_choices (): raise ValueError ( \"Invalid space group for choose_trigonal_lattice\" ) if self . space_group . choice == choice : return cart_asym_pos = self . to_cartesian ( self . asymmetric_unit . positions ) assert choice in ( \"H\" , \"R\" ), \"Valid choices are H, R\" if self . space_group . choice == \"R\" : T = np . array ((( - 1 , 1 , 0 ), ( 1 , 0 , - 1 ), ( 1 , 1 , 1 ))) else : T = 1 / 3 * np . array ((( - 1 , 1 , 1 ), ( 2 , 1 , 1 ), ( - 1 , - 2 , 1 ))) new_uc = UnitCell ( np . dot ( T , self . unit_cell . direct )) self . unit_cell = new_uc self . asymmetric_unit . positions = self . to_fractional ( cart_asym_pos ) self . space_group = SpaceGroup ( self . space_group . international_tables_number , choice = choice ) from_cif_data ( cif_data , titl = None ) classmethod Initialize a crystal structure from a dictionary of CIF data Source code in chmpy/crystal/crystal.py 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 @classmethod def from_cif_data ( cls , cif_data , titl = None ): \"\"\"Initialize a crystal structure from a dictionary of CIF data\"\"\" labels = cif_data . get ( \"atom_site_label\" , None ) symbols = cif_data . get ( \"atom_site_type_symbol\" , None ) if symbols is None : if labels is None : raise ValueError ( \"Unable to determine elements in CIF, \" \"need one of _atom_site_label or \" \"_atom_site_type_symbol present\" ) elements = [ Element [ x ] for x in labels ] else : elements = [ Element [ x ] for x in symbols ] x = np . asarray ( cif_data . get ( \"atom_site_fract_x\" , [])) y = np . asarray ( cif_data . get ( \"atom_site_fract_y\" , [])) z = np . asarray ( cif_data . get ( \"atom_site_fract_z\" , [])) occupation = np . asarray ( cif_data . get ( \"atom_site_occupancy\" , [ 1 ] * len ( x ))) frac_pos = np . array ([ x , y , z ]) . T asym = AsymmetricUnit ( elements = elements , positions = frac_pos , labels = labels , occupation = occupation ) lengths = [ cif_data [ f \"cell_length_ { x } \" ] for x in ( \"a\" , \"b\" , \"c\" )] angles = [ cif_data [ f \"cell_angle_ { x } \" ] for x in ( \"alpha\" , \"beta\" , \"gamma\" )] unit_cell = UnitCell . from_lengths_and_angles ( lengths , angles , unit = \"degrees\" ) space_group = SpaceGroup ( 1 ) symop_data_names = ( \"symmetry_equiv_pos_as_xyz\" , \"space_group_symop_operation_xyz\" , ) number = space_group . international_tables_number for k in ( \"space_group_IT_number\" , \"symmetry_Int_Tables_number\" ): if k in cif_data : number = cif_data [ k ] break for symop_data_block in symop_data_names : if symop_data_block in cif_data : symops = [ SymmetryOperation . from_string_code ( x ) for x in cif_data [ symop_data_block ] ] try : new_sg = SpaceGroup . from_symmetry_operations ( symops ) space_group = new_sg except ValueError : space_group . symmetry_operations = symops symbol = cif_data . get ( \"symmetry_space_group_name_H-M\" , \"Unknown\" ) space_group . international_tables_number = number space_group . symbol = symbol space_group . full_symbol = symbol LOG . warn ( \"Initializing non-standard spacegroup setting %s , \" \"some SG data may be missing\" , symbol , ) break else : # fall back to international tables number space_group = SpaceGroup ( number ) return Crystal ( unit_cell , space_group , asym , cif_data = cif_data , titl = titl ) from_cif_file ( filename , data_block_name = None ) classmethod Initialize a crystal structure from a CIF file Source code in chmpy/crystal/crystal.py 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 @classmethod def from_cif_file ( cls , filename , data_block_name = None ): \"\"\"Initialize a crystal structure from a CIF file\"\"\" cif = Cif . from_file ( filename ) if data_block_name is not None : return cls . from_cif_data ( cif . data [ data_block_name ], titl = data_block_name ) crystals = { name : cls . from_cif_data ( data , titl = name ) for name , data in cif . data . items () } keys = list ( crystals . keys ()) if len ( keys ) == 1 : return crystals [ keys [ 0 ]] return crystals from_shelx_file ( filename , ** kwargs ) classmethod Initialize a crystal structure from a shelx .res file Source code in chmpy/crystal/crystal.py 1393 1394 1395 1396 1397 1398 @classmethod def from_shelx_file ( cls , filename , ** kwargs ): \"\"\"Initialize a crystal structure from a shelx .res file\"\"\" p = Path ( filename ) titl = p . stem return cls . from_shelx_string ( p . read_text (), titl = titl , ** kwargs ) from_shelx_string ( file_content , ** kwargs ) classmethod Initialize a crystal structure from a shelx .res string Source code in chmpy/crystal/crystal.py 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 @classmethod def from_shelx_string ( cls , file_content , ** kwargs ): \"\"\"Initialize a crystal structure from a shelx .res string\"\"\" from chmpy.fmt.shelx import parse_shelx_file_content shelx_dict = parse_shelx_file_content ( file_content ) asymmetric_unit = AsymmetricUnit . from_records ( shelx_dict [ \"ATOM\" ]) space_group = SpaceGroup . from_symmetry_operations ( shelx_dict [ \"SYMM\" ], expand_latt = shelx_dict [ \"LATT\" ] ) unit_cell = UnitCell . from_lengths_and_angles ( shelx_dict [ \"CELL\" ][ \"lengths\" ], shelx_dict [ \"CELL\" ][ \"angles\" ], unit = \"degrees\" ) return cls ( unit_cell , space_group , asymmetric_unit , ** kwargs ) from_vasp_file ( filename , ** kwargs ) classmethod Initialize a crystal structure from a VASP POSCAR file Source code in chmpy/crystal/crystal.py 1292 1293 1294 1295 @classmethod def from_vasp_file ( cls , filename , ** kwargs ): \"Initialize a crystal structure from a VASP POSCAR file\" return cls . from_vasp_string ( Path ( filename ) . read_text (), ** kwargs ) from_vasp_string ( string , ** kwargs ) classmethod Initialize a crystal structure from a VASP POSCAR string Source code in chmpy/crystal/crystal.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 @classmethod def from_vasp_string ( cls , string , ** kwargs ): \"Initialize a crystal structure from a VASP POSCAR string\" from chmpy.fmt.vasp import parse_poscar vasp_data = parse_poscar ( string ) uc = UnitCell ( vasp_data [ \"direct\" ]) sg = SpaceGroup ( 1 ) coords = vasp_data [ \"positions\" ] if not vasp_data [ \"coord_type\" ] . startswith ( \"d\" ): coords = uc . to_fractional ( coords ) asym = AsymmetricUnit ( vasp_data [ \"elements\" ], coords ) return Crystal ( uc , sg , asym , titl = vasp_data [ \"name\" ]) functional_group_shape_descriptors ( self , l_max = 5 , radius = 6.0 , kind = 'carboxylic_acid' ) Calculate the shape descriptors [1,2] for the all atoms in the functional group given for all symmetry unique molecules in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. (default: 5) 5 radius float maximum distance (Angstroms) of neighbouring atoms to include in stockholder weight calculation (default: 5) 6.0 kind str Identifier for the functional group type (default: 'carboxylic_acid') 'carboxylic_acid' Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 def functional_group_shape_descriptors ( self , l_max = 5 , radius = 6.0 , kind = \"carboxylic_acid\" ) -> np . ndarray : \"\"\" Calculate the shape descriptors `[1,2]` for the all atoms in the functional group given for all symmetry unique molecules in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. (default: 5) radius (float, optional): maximum distance (Angstroms) of neighbouring atoms to include in stockholder weight calculation (default: 5) kind (str, optional): Identifier for the functional group type (default: 'carboxylic_acid') Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for ( in_els , in_pos , neighbour_els , neighbour_pos , ) in self . functional_group_surroundings ( kind = kind , radius = radius ): masses = np . asarray ([ Element [ x ] . mass for x in in_els ]) c = np . sum ( in_pos * masses [:, np . newaxis ] / np . sum ( masses ), axis = 0 ) . astype ( np . float32 ) dists = np . linalg . norm ( in_pos - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 descriptors . append ( stockholder_weight_descriptor ( sph , in_els , in_pos , neighbour_els , neighbour_pos , origin = c , bounds = bounds , ) ) return np . asarray ( descriptors ) functional_group_surroundings ( self , radius = 6.0 , kind = 'carboxylic_acid' ) Calculate the atomic information for all atoms surrounding each functional group in each symmetry unique molecule in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 kind str the functional group type 'carboxylic_acid' Returns: Type Description List A list of tuples of (func_el, func_pos, neigh_el, neigh_pos) where func_el and neigh_el are np.ndarray of atomic numbers, and func_pos and neigh_pos are np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 def functional_group_surroundings ( self , radius = 6.0 , kind = \"carboxylic_acid\" ) -> List : \"\"\" Calculate the atomic information for all atoms surrounding each functional group in each symmetry unique molecule in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms kind (str, optional): the functional group type Returns: A list of tuples of (func_el, func_pos, neigh_el, neigh_pos) where `func_el` and `neigh_el` are `np.ndarray` of atomic numbers, and `func_pos` and `neigh_pos` are `np.ndarray` of Cartesian atomic positions \"\"\" results = [] for mol in self . symmetry_unique_molecules (): hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . to_fractional ( mol . positions ): hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) groups = mol . functional_groups ( kind = kind ) for fg in groups : fg = list ( fg ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) inside = [] for pos in mol . positions [ fg ]: idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < 1e-3 : inside . append ( nn ) keep [ inside ] = False results . append ( ( mol . atomic_numbers [ fg ], mol . positions [ fg ], elements [ keep ], positions [ keep ], ) ) return results hirshfeld_surfaces ( self , ** kwargs ) Alias for self.stockholder_weight_isosurfaces Source code in chmpy/crystal/crystal.py 904 905 906 def hirshfeld_surfaces ( self , ** kwargs ): \"Alias for `self.stockholder_weight_isosurfaces`\" return self . stockholder_weight_isosurfaces ( ** kwargs ) load ( filename , ** kwargs ) classmethod Load a crystal structure from file (.res, .cif) Parameters: Name Type Description Default filename str the path to the crystal structure file required Returns: Type Description Union[Crystal, dict] the resulting crystal structure or dictionary of crystal structures Source code in chmpy/crystal/crystal.py 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 @classmethod def load ( cls , filename , ** kwargs ) -> Union [ \"Crystal\" , dict ]: \"\"\" Load a crystal structure from file (.res, .cif) Args: filename (str): the path to the crystal structure file Returns: the resulting crystal structure or dictionary of crystal structures \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = cls . _fname_load_map () if n in fname_map : return fname_map [ n ]( filename ) extension_map = cls . _ext_load_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs ) mesh_scene ( self , ** kwargs ) Calculate a scene of this meshes of unit cell molecules in this crystal, along with optional void surface. Parameters: Name Type Description Default kwargs optional arguments used in the generation of this scene. {} Returns: Type Description trimesh.scene.Scene trimesh scene object. Source code in chmpy/crystal/crystal.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 def mesh_scene ( self , ** kwargs ): \"\"\" Calculate a scene of this meshes of unit cell molecules in this crystal, along with optional void surface. Args: kwargs: optional arguments used in the generation of this scene. Returns: trimesh.scene.Scene: trimesh scene object. \"\"\" from trimesh import Scene meshes = {} for i , m in enumerate ( self . unit_cell_molecules ()): mesh = m . to_mesh ( representation = kwargs . get ( \"representation\" , \"ball_stick\" )) n = m . molecular_formula for k , v in mesh . items (): meshes [ f \"mol_ { i } _ { n } . { k } \" ] = v if kwargs . get ( \"void\" , False ): void_kwargs = kwargs . get ( \"void_kwargs\" , {}) meshes [ \"void_surface\" ] = self . void_surface ( ** void_kwargs ) if kwargs . get ( \"axes\" , False ): from trimesh.creation import axis meshes [ \"axes\" ] = axis ( transform = self . unit_cell . direct_homogeneous . T , axis_length = 1.0 ) return Scene ( meshes ) molecular_shape_descriptors ( self , l_max = 5 , radius = 6.0 , with_property = None ) Calculate the molecular shape descriptors[1,2] for all symmetry unique molecules in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 6.0 with_property str name of the surface property to include in the shape description None Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 def molecular_shape_descriptors ( self , l_max = 5 , radius = 6.0 , with_property = None ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors[1,2] for all symmetry unique molecules in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description with_property (str, optional): name of the surface property to include in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for mol , neighbour_els , neighbour_pos in self . molecule_environments ( radius = radius ): c = np . array ( mol . centroid , dtype = np . float32 ) dists = np . linalg . norm ( mol . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 descriptors . append ( stockholder_weight_descriptor ( sph , mol . atomic_numbers , mol . positions , neighbour_els , neighbour_pos , origin = c , bounds = bounds , with_property = with_property , ) ) return np . asarray ( descriptors ) molecular_shell ( self , mol_idx = 0 , radius = 3.8 , method = 'nearest_atom' ) Calculate the neighbouring molecules around the molecule with index mol_idx , within the given radius using the specified method . Parameters: Name Type Description Default mol_idx int The index (into symmetry_unique_molecules ) of the central molecule for the shell 0 radius float The maximum distance (Angstroms) between the central molecule and the neighbours. 3.8 method str the method to use when determining inclusion of neighbours. 'nearest_atom' Returns: Type Description List[chmpy.core.molecule.Molecule] A list of neighbouring molecules using the given method. Source code in chmpy/crystal/crystal.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def molecular_shell ( self , mol_idx = 0 , radius = 3.8 , method = \"nearest_atom\" ) -> List [ Molecule ]: \"\"\" Calculate the neighbouring molecules around the molecule with index `mol_idx`, within the given `radius` using the specified `method`. Arguments: mol_idx (int, optional): The index (into `symmetry_unique_molecules`) of the central molecule for the shell radius (float, optional): The maximum distance (Angstroms) between the central molecule and the neighbours. method (str, optional): the method to use when determining inclusion of neighbours. Returns: A list of neighbouring molecules using the given method. \"\"\" mol = self . symmetry_unique_molecules ()[ mol_idx ] frac_origin = self . to_fractional ( mol . center_of_mass ) frac_radius = radius / np . array ( self . unit_cell . lengths ) hmax , kmax , lmax = np . ceil ( frac_radius + frac_origin ) . astype ( int ) + 1 hmin , kmin , lmin = np . floor ( frac_origin - frac_radius ) . astype ( int ) - 1 uc_mols = self . unit_cell_molecules () shifts = self . to_cartesian ( cartesian_product ( np . arange ( hmin , hmax ), np . arange ( kmin , kmax ), np . arange ( lmin , lmax ) ) ) neighbours = [] for uc_mol in uc_mols : for shift in shifts : uc_mol_t = uc_mol . translated ( shift ) dist = mol . distance_to ( uc_mol_t , method = method ) if ( dist < radius ) and ( dist > 1e-2 ): neighbours . append ( uc_mol_t ) return neighbours molecule_dict ( self , ** kwargs ) A dictionary of symmetry_unique_molecules , grouped by their chemical formulae. Returns: Type Description dict the dictionary of molecules with chemical formula keys and list of molecule values. Source code in chmpy/crystal/crystal.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def molecule_dict ( self , ** kwargs ) -> dict : \"\"\" A dictionary of `symmetry_unique_molecules`, grouped by their chemical formulae. Returns: the dictionary of molecules with chemical formula keys and list of molecule values. \"\"\" result = {} mols = self . symmetry_unique_molecules () for m in mols : f = m . molecular_formula if f not in result : result [ f ] = [] result [ f ] . append ( m ) return result molecule_environment ( self , mol , radius = 6.0 , threshold = 0.001 ) Calculate the atomic information for all atoms surrounding the given molecule in this crystal within the given radius. Atoms closer than threshold to any atom in the provided molecule will be excluded and considered part of the molecule. Parameters: Name Type Description Default mol Molecule the molecule whose environment to calculate required radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 threshold float tolerance for detecting the neighbouring sites as part of the given molecule. 0.001 Returns: Type Description Tuple A list of tuples of (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 def molecule_environment ( self , mol , radius = 6.0 , threshold = 1e-3 ) -> Tuple : \"\"\" Calculate the atomic information for all atoms surrounding the given molecule in this crystal within the given radius. Atoms closer than `threshold` to any atom in the provided molecule will be excluded and considered part of the molecule. Args: mol (Molecule): the molecule whose environment to calculate radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms threshold (float, optional): tolerance for detecting the neighbouring sites as part of the given molecule. Returns: A list of tuples of (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . to_fractional ( mol . positions ): hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) this_mol = [] for pos in mol . positions : idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < threshold : this_mol . append ( nn ) keep [ this_mol ] = False return ( mol , elements [ keep ], positions [ keep ]) molecule_environments ( self , radius = 6.0 , threshold = 0.001 ) Calculate the atomic information for all atoms surrounding each symmetry unique molecule in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 threshold float tolerance for detecting the neighbouring sites as part of the given molecule. 0.001 Returns: Type Description List[Tuple] A list of tuples of (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 def molecule_environments ( self , radius = 6.0 , threshold = 1e-3 ) -> List [ Tuple ]: \"\"\" Calculate the atomic information for all atoms surrounding each symmetry unique molecule in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms threshold (float, optional): tolerance for detecting the neighbouring sites as part of the given molecule. Returns: A list of tuples of (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" return [ self . molecule_environment ( x , radius = radius , threshold = threshold ) for x in self . symmetry_unique_molecules () ] molecule_shape_descriptors ( self , mol , l_max = 5 , radius = 6.0 , with_property = None ) Calculate the molecular shape descriptors [1,2] for the provided molecule in the crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 6.0 with_property str name of the surface property to include in the shape description None Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 def molecule_shape_descriptors ( self , mol , l_max = 5 , radius = 6.0 , with_property = None ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors `[1,2]` for the provided molecule in the crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description with_property (str, optional): name of the surface property to include in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) mol , neighbour_els , neighbour_pos = self . molecule_environment ( mol , radius = radius ) c = np . array ( mol . centroid , dtype = np . float32 ) dists = np . linalg . norm ( mol . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 return stockholder_weight_descriptor ( sph , mol . atomic_numbers , mol . positions , neighbour_els , neighbour_pos , origin = c , bounds = bounds , with_property = with_property , ) promolecule_density_isosurfaces ( self , ** kwargs ) Calculate promolecule electron density isosurfaces for each symmetry unique molecule in this crystal. Parameters: Name Type Description Default kwargs Keyword arguments used by Molecule.promolecule_density_isosurface . Options are: isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. color (str, optional): surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap (str, optional): matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint (float, optional): midpoint of the segmented colormap (if applicable) {} Returns: Type Description List[trimesh.base.Trimesh] A list of meshes representing the promolecule density isosurfaces Source code in chmpy/crystal/crystal.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 def promolecule_density_isosurfaces ( self , ** kwargs ) -> List [ Trimesh ]: \"\"\" Calculate promolecule electron density isosurfaces for each symmetry unique molecule in this crystal. Args: kwargs: Keyword arguments used by `Molecule.promolecule_density_isosurface`. Options are: ``` isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. color (str, optional): surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap (str, optional): matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint (float, optional): midpoint of the segmented colormap (if applicable) ``` Returns: A list of meshes representing the promolecule density isosurfaces \"\"\" return [ mol . promolecule_density_isosurface ( ** kwargs ) for mol in self . symmetry_unique_molecules () ] save ( self , filename , ** kwargs ) Save this crystal structure to file (.cif, .res, POSCAR) Source code in chmpy/crystal/crystal.py 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def save ( self , filename , ** kwargs ): \"\"\"Save this crystal structure to file (.cif, .res, POSCAR)\"\"\" fpath = Path ( filename ) n = fpath . name fname_map = self . _fname_save_map () if n in fname_map : return fname_map [ n ]( filename , ** kwargs ) extension_map = self . _ext_save_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs ) slab ( self , bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) Calculate the atoms and associated information for a slab consisting of multiple unit cells. If unit cell atoms have not been calculated, this calculates their information and caches it. Parameters: Name Type Description Default bounds Tuple Tuple of upper and lower corners (hkl) describing the bounds of the slab. ((-1, -1, -1), (1, 1, 1)) Returns: Type Description dict A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 cell: (N,3) array of cell indices for each site n_uc: number of atoms in the unit cell n_cells: number of cells in this slab occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 Source code in chmpy/crystal/crystal.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 def slab ( self , bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) -> dict : \"\"\" Calculate the atoms and associated information for a slab consisting of multiple unit cells. If unit cell atoms have not been calculated, this calculates their information and caches it. Args: bounds (Tuple, optional): Tuple of upper and lower corners (hkl) describing the bounds of the slab. Returns: A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 cell: (N,3) array of cell indices for each site n_uc: number of atoms in the unit cell n_cells: number of cells in this slab occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 \"\"\" uc_atoms = self . unit_cell_atoms () ( hmin , kmin , lmin ), ( hmax , kmax , lmax ) = bounds h = np . arange ( hmin , hmax + 1 ) k = np . arange ( kmin , kmax + 1 ) l = np . arange ( lmin , lmax + 1 ) # noqa: E741 cells = cartesian_product ( h [ np . argsort ( np . abs ( h ))], k [ np . argsort ( np . abs ( k ))], l [ np . argsort ( np . abs ( l ))] ) ncells = len ( cells ) uc_pos = uc_atoms [ \"frac_pos\" ] n_uc = len ( uc_pos ) pos = np . empty (( ncells * n_uc , 3 ), dtype = np . float64 ) slab_cells = np . empty (( ncells * n_uc , 3 ), dtype = np . float64 ) for i , cell in enumerate ( cells ): pos [ i * n_uc : ( i + 1 ) * n_uc , :] = uc_pos + cell slab_cells [ i * n_uc : ( i + 1 ) * n_uc ] = cell slab_dict = { k : np . tile ( v , ncells ) for k , v in uc_atoms . items () if not k . endswith ( \"pos\" ) } slab_dict [ \"frac_pos\" ] = pos slab_dict [ \"cell\" ] = slab_cells slab_dict [ \"n_uc\" ] = n_uc slab_dict [ \"n_cells\" ] = ncells slab_dict [ \"cart_pos\" ] = self . to_cartesian ( pos ) return slab_dict stockholder_weight_isosurfaces ( self , kind = 'mol' , ** kwargs ) Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces) for each symmetry unique molecule or atom in this crystal. Parameters: Name Type Description Default kind str dictates whether we calculate surfaces for each unique molecule or for each unique atom 'mol' kwargs keyword arguments passed to stockholder_weight_isosurface . Options include: isovalue : float , optional level set value for the isosurface ( default = 0.5 ). Must be between 0 and 1 , but values other than 0.5 probably won 't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of (' d_norm_i ', ' d_i ', ' d_norm_e ', ' d_e ', ' d_norm ') colormap: str, optional matplotlib colormap to use for surface coloring (default ' viridis_r ' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description List[trimesh.base.Trimesh] A list of meshes representing the stockholder weight isosurfaces Source code in chmpy/crystal/crystal.py 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 def stockholder_weight_isosurfaces ( self , kind = \"mol\" , ** kwargs ) -> List [ Trimesh ]: \"\"\" Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces) for each symmetry unique molecule or atom in this crystal. Args: kind (str, optional): dictates whether we calculate surfaces for each unique molecule or for each unique atom kwargs: keyword arguments passed to `stockholder_weight_isosurface`. Options include: ``` isovalue: float, optional level set value for the isosurface (default=0.5). Must be between 0 and 1, but values other than 0.5 probably won't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e', 'd_norm') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: A list of meshes representing the stockholder weight isosurfaces \"\"\" from chmpy import StockholderWeight from chmpy.surface import stockholder_weight_isosurface from chmpy.util.color import property_to_color import trimesh sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) radius = kwargs . get ( \"radius\" , 12.0 ) vertex_color = kwargs . get ( \"color\" , \"d_norm\" ) isovalue = kwargs . get ( \"isovalue\" , 0.5 ) meshes = [] extra_props = {} isos = [] if kind == \"atom\" : for n , pos , neighbour_els , neighbour_pos in self . atomic_surroundings ( radius = radius ): s = StockholderWeight . from_arrays ( [ n ], [ pos ], neighbour_els , neighbour_pos ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) elif kind == \"mol\" : for mol , n_e , n_p in self . molecule_environments ( radius = radius ): if vertex_color == \"esp\" : extra_props [ \"esp\" ] = mol . electrostatic_potential s = StockholderWeight . from_arrays ( mol . atomic_numbers , mol . positions , n_e , n_p ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep , extra_props = extra_props ) isos . append ( iso ) else : for arr in self . functional_group_surroundings ( radius = radius , kind = kind ): s = StockholderWeight . from_arrays ( * arr ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) for iso in isos : prop = iso . vertex_prop [ vertex_color ] color = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , vertex_color )) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) meshes . append ( mesh ) return meshes symmetry_unique_dimers ( self , radius = 3.8 , distance_method = 'nearest_atom' ) Calculate the information for all molecule pairs surrounding the symmetry_unique_molecules in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 3.8 Returns: Type Description A dictionary of dimers (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 def symmetry_unique_dimers ( self , radius = 3.8 , distance_method = \"nearest_atom\" ): \"\"\" Calculate the information for all molecule pairs surrounding the symmetry_unique_molecules in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms Returns: A dictionary of dimers (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" from chmpy.core.dimer import Dimer from copy import deepcopy from collections import defaultdict hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . asymmetric_unit . positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) shifts_frac = cartesian_product ( np . arange ( hmin , hmax ), np . arange ( kmin , kmax ), np . arange ( lmin , lmax ) ) shifts = self . to_cartesian ( shifts_frac ) LOG . debug ( \"Looking in %d neighbouring cells: %s : %s \" , len ( shifts ), hklmin . astype ( int ), hklmax . astype ( int ), ) all_dimers = [] mol_dimers = [] for mol_a in self . symmetry_unique_molecules (): dimers_a = [] for mol_b in self . unit_cell_molecules (): for shift , shift_frac in zip ( shifts , shifts_frac ): # shift_frac assumes the molecule is generated from the [0, 0, 0] cell, it's not mol_bt = mol_b . translated ( shift ) r = mol_a . distance_to ( mol_bt , method = distance_method ) if r > 1e-1 and r < radius : d = Dimer ( mol_a , mol_bt , separation = r , transform_ab = \"calculate\" , frac_shift = shift_frac , ) for i , dimer in enumerate ( all_dimers ): if dimer . separation <= d . separation + 1e-3 : if d == dimer : dimers_a . append ( i ) break else : dimers_a . append ( len ( all_dimers )) all_dimers . append ( d ) all_dimers = sorted ( all_dimers , key = lambda x : x . separation ) mol_dimers . append ( dimers_a ) return all_dimers , mol_dimers symmetry_unique_molecules ( self , bond_tolerance = 0.4 ) Calculate a list of connected molecules which contain every site in the asymmetric_unit Populates the _symmetry_unique_molecules member, subsequent calls to this function will be a no-op. Parameters: Name Type Description Default bond_tolerance float Bonding tolerance (bonded if d < cov_a + cov_b + bond_tolerance) 0.4 Returns: Type Description List[chmpy.core.molecule.Molecule] List of all connected molecules in the asymmetric_unit of this crystal, i.e. the minimum list of connected molecules which contain all sites in the asymmetric unit. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit and the total number of atoms will be equal to the number of atoms in the asymmetric_unit Source code in chmpy/crystal/crystal.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def symmetry_unique_molecules ( self , bond_tolerance = 0.4 ) -> List [ Molecule ]: \"\"\" Calculate a list of connected molecules which contain every site in the asymmetric_unit Populates the _symmetry_unique_molecules member, subsequent calls to this function will be a no-op. Args: bond_tolerance (float, optional): Bonding tolerance (bonded if d < cov_a + cov_b + bond_tolerance) Returns: List of all connected molecules in the asymmetric_unit of this crystal, i.e. the minimum list of connected molecules which contain all sites in the asymmetric unit. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit and the total number of atoms will be equal to the number of atoms in the asymmetric_unit \"\"\" if hasattr ( self , \"_symmetry_unique_molecules\" ): return getattr ( self , \"_symmetry_unique_molecules\" ) uc_molecules = self . unit_cell_molecules () asym_atoms = np . zeros ( len ( self . asymmetric_unit ), dtype = bool ) molecules = [] # sort by % of identity symop def order ( x ): return len ( np . where ( x . asym_symops == 16484 )[ 0 ]) / len ( x ) for i , mol in enumerate ( sorted ( uc_molecules , key = order , reverse = True )): asym_atoms_in_g = np . unique ( mol . properties [ \"asymmetric_unit_atoms\" ]) if np . all ( asym_atoms [ asym_atoms_in_g ]): continue asym_atoms [ asym_atoms_in_g ] = True molecules . append ( mol ) if np . all ( asym_atoms ): break LOG . debug ( \" %d symmetry unique molecules\" , len ( molecules )) setattr ( self , \"_symmetry_unique_molecules\" , molecules ) for i , mol in enumerate ( molecules ): mol . properties [ \"asym_mol_idx\" ] = i ak = \"asymmetric_unit_atoms\" for mol in self . unit_cell_molecules (): if \"asym_mol_idx\" in mol . properties : continue else : for asym_mol in molecules : if np . all ( mol . properties [ ak ] == asym_mol . properties [ ak ]): mol . properties [ \"asym_mol_idx\" ] = asym_mol . properties [ \"asym_mol_idx\" ] break else : LOG . warn ( \"No equivalent asymmetric unit molecule found!? -- this should not happen!\" ) return molecules to_cartesian ( self , coords ) Convert coordinates (row major) from fractional to cartesian coordinates. Parameters: Name Type Description Default coords np.ndarray (N, 3) array of positions assumed to be in fractional coordinates required Returns: Type Description ndarray (N, 3) array of positions transformed to cartesian (orthogonal) coordinates by the unit cell of this crystal. Source code in chmpy/crystal/crystal.py 104 105 106 107 108 109 110 111 112 113 114 115 def to_cartesian ( self , coords ) -> np . ndarray : \"\"\" Convert coordinates (row major) from fractional to cartesian coordinates. Arguments: coords (np.ndarray): (N, 3) array of positions assumed to be in fractional coordinates Returns: (N, 3) array of positions transformed to cartesian (orthogonal) coordinates by the unit cell of this crystal. \"\"\" return self . unit_cell . to_cartesian ( coords ) to_cif_data ( self , data_block_name = None ) Convert this crystal structure to cif data dict Source code in chmpy/crystal/crystal.py 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 def to_cif_data ( self , data_block_name = None ) -> dict : \"Convert this crystal structure to cif data dict\" version = \"1.0a1\" if data_block_name is None : data_block_name = self . titl if \"cif_data\" in self . properties : cif_data = self . properties [ \"cif_data\" ] else : cif_data = { \"audit_creation_method\" : f \"chmpy python library version { version } \" , \"symmetry_equiv_pos_site_id\" : list ( range ( 1 , len ( self . symmetry_operations ) + 1 ) ), \"symmetry_equiv_pos_as_xyz\" : [ str ( x ) for x in self . symmetry_operations ], \"cell_length_a\" : self . unit_cell . a , \"cell_length_b\" : self . unit_cell . b , \"cell_length_c\" : self . unit_cell . c , \"cell_angle_alpha\" : self . unit_cell . alpha_deg , \"cell_angle_beta\" : self . unit_cell . beta_deg , \"cell_angle_gamma\" : self . unit_cell . gamma_deg , \"atom_site_label\" : self . asymmetric_unit . labels , \"atom_site_type_symbol\" : [ x . symbol for x in self . asymmetric_unit . elements ], \"atom_site_fract_x\" : self . asymmetric_unit . positions [:, 0 ], \"atom_site_fract_y\" : self . asymmetric_unit . positions [:, 1 ], \"atom_site_fract_z\" : self . asymmetric_unit . positions [:, 2 ], \"atom_site_occupancy\" : self . asymmetric_unit . properties . get ( \"occupation\" , np . ones ( len ( self . asymmetric_unit )) ), } return { data_block_name : cif_data } to_cif_file ( self , filename , ** kwargs ) save this crystal to a CIF formatted file Source code in chmpy/crystal/crystal.py 1540 1541 1542 1543 def to_cif_file ( self , filename , ** kwargs ): \"save this crystal to a CIF formatted file\" cif_data = self . to_cif_data ( ** kwargs ) return Cif ( cif_data ) . to_file ( filename ) to_cif_string ( self , ** kwargs ) save this crystal to a CIF formatted string Source code in chmpy/crystal/crystal.py 1545 1546 1547 1548 def to_cif_string ( self , ** kwargs ): \"save this crystal to a CIF formatted string\" cif_data = self . to_cif_data ( ** kwargs ) return Cif ( cif_data ) . to_string () to_fractional ( self , coords ) Convert coordinates (row major) from cartesian to fractional coordinates. Parameters: Name Type Description Default coords np.ndarray (N, 3) array of positions assumed to be in cartesian (orthogonal) coordinates required Returns: Type Description ndarray (N, 3) array of positions transformed to fractional coordinates by the unit cell of this crystal. Source code in chmpy/crystal/crystal.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def to_fractional ( self , coords ) -> np . ndarray : \"\"\" Convert coordinates (row major) from cartesian to fractional coordinates. Args: coords (np.ndarray): (N, 3) array of positions assumed to be in cartesian (orthogonal) coordinates Returns: (N, 3) array of positions transformed to fractional coordinates by the unit cell of this crystal. \"\"\" return self . unit_cell . to_fractional ( coords ) to_poscar_file ( self , filename , ** kwargs ) save this crystal to a VASP POSCAR formatted file Source code in chmpy/crystal/crystal.py 1556 1557 1558 def to_poscar_file ( self , filename , ** kwargs ): \"save this crystal to a VASP POSCAR formatted file\" Path ( filename ) . write_text ( self . to_poscar_string ( ** kwargs )) to_poscar_string ( self , ** kwargs ) save this crystal to a VASP POSCAR formatted string Source code in chmpy/crystal/crystal.py 1550 1551 1552 1553 1554 def to_poscar_string ( self , ** kwargs ): \"save this crystal to a VASP POSCAR formatted string\" from chmpy.ext.vasp import poscar_string return poscar_string ( self , name = self . titl ) to_shelx_file ( self , filename ) Write this crystal structure as a shelx .res formatted file Source code in chmpy/crystal/crystal.py 1560 1561 1562 def to_shelx_file ( self , filename ): \"\"\"Write this crystal structure as a shelx .res formatted file\"\"\" Path ( filename ) . write_text ( self . to_shelx_string ()) to_shelx_string ( self , titl = None ) Represent this crystal structure as a shelx .res formatted string Source code in chmpy/crystal/crystal.py 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 def to_shelx_string ( self , titl = None ): \"\"\"Represent this crystal structure as a shelx .res formatted string\"\"\" from chmpy.fmt.shelx import to_res_contents sfac = list ( np . unique ( self . site_atoms )) atom_sfac = [ sfac . index ( x ) + 1 for x in self . site_atoms ] shelx_data = { \"TITL\" : self . titl if titl is None else titl , \"CELL\" : self . unit_cell . parameters , \"SFAC\" : [ Element [ x ] . symbol for x in sfac ], \"SYMM\" : [ str ( s ) for s in self . space_group . reduced_symmetry_operations () if not s . is_identity () ], \"LATT\" : self . space_group . latt , \"ATOM\" : [ \" {:3} {:3} {: 20.12f} {: 20.12f} {: 20.12f} \" . format ( l , s , * pos ) for l , s , pos in zip ( self . asymmetric_unit . labels , atom_sfac , self . site_positions ) ], } return to_res_contents ( shelx_data ) to_translational_symmetry ( self , supercell = ( 1 , 1 , 1 )) Create a supercell of this crystal in space group P 1. Parameters: Name Type Description Default supercell Tuple[int] size of the supercell to be created (1, 1, 1) Returns: Type Description Crystal Crystal object of a supercell in space group P 1 Source code in chmpy/crystal/crystal.py 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 def to_translational_symmetry ( self , supercell = ( 1 , 1 , 1 )) -> \"Crystal\" : \"\"\" Create a supercell of this crystal in space group P 1. Args: supercell (Tuple[int]): size of the supercell to be created Returns: Crystal object of a supercell in space group P 1 \"\"\" from itertools import product hmax , kmax , lmax = supercell a , b , c = self . unit_cell . lengths sc = UnitCell . from_lengths_and_angles ( ( hmax * a , kmax * b , lmax * c ), self . unit_cell . angles ) h = np . arange ( hmax ) k = np . arange ( kmax ) l = np . arange ( lmax ) molecules = [] for q , r , s in product ( h , k , l ): for uc_mol in self . unit_cell_molecules (): molecules . append ( uc_mol . translated ( np . asarray ([ q , r , s ]) @ self . unit_cell . lattice ) ) asym_pos = np . vstack ([ x . positions for x in molecules ]) asym_nums = np . hstack ([ x . atomic_numbers for x in molecules ]) asymmetric_unit = AsymmetricUnit ( [ Element [ x ] for x in asym_nums ], sc . to_fractional ( asym_pos ) ) new_titl = self . titl + \"_P1_supercell_ {} _ {} _ {} \" . format ( * supercell ) new_crystal = Crystal ( sc , SpaceGroup ( 1 ), asymmetric_unit , titl = new_titl ) return new_crystal unit_cell_atoms ( self , tolerance = 0.01 ) Generate all atoms in the unit cell (i.e. with fractional coordinates in [0, 1]) along with associated information about symmetry operations, occupation, elements related asymmetric_unit atom etc. Will merge atom sites within tolerance of each other, and sum their occupation numbers. A warning will be logged if any atom site in the unit cell has > 1.0 occupancy after this. Sets the _unit_cell_atom_dict member as this is an expensive operation and is worth caching the result. Subsequent calls to this function will be a no-op. Parameters: Name Type Description Default tolerance float Minimum separation of sites in the unit cell, below which atoms/sites will be merged and their (partial) occupations added. 0.01 Returns: Type Description dict A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom : corresponding asymmetric unit atom indices for all sites . frac_pos : ( N , 3 ) array of fractional positions for all sites . cart_pos : ( N , 3 ) array of cartesian positions for all sites . element : ( N ) array of atomic numbers for all sites . symop : ( N ) array of indices corresponding to the generator symmetry operation for each site . label : ( N ) array of string labels corresponding to each site occupation : ( N ) array of occupation numbers for each site . Will warn if any of these are greater than 1.0 Source code in chmpy/crystal/crystal.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def unit_cell_atoms ( self , tolerance = 1e-2 ) -> dict : \"\"\" Generate all atoms in the unit cell (i.e. with fractional coordinates in [0, 1]) along with associated information about symmetry operations, occupation, elements related asymmetric_unit atom etc. Will merge atom sites within tolerance of each other, and sum their occupation numbers. A warning will be logged if any atom site in the unit cell has > 1.0 occupancy after this. Sets the `_unit_cell_atom_dict` member as this is an expensive operation and is worth caching the result. Subsequent calls to this function will be a no-op. Arguments: tolerance (float, optional): Minimum separation of sites in the unit cell, below which atoms/sites will be merged and their (partial) occupations added. Returns: A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 \"\"\" if hasattr ( self , \"_unit_cell_atom_dict\" ): return getattr ( self , \"_unit_cell_atom_dict\" ) pos = self . site_positions atoms = self . site_atoms natom = self . nsites nsymops = len ( self . space_group . symmetry_operations ) occupation = np . tile ( self . asymmetric_unit . properties . get ( \"occupation\" , np . ones ( natom )), nsymops ) labels = np . tile ( self . asymmetric_unit . labels , nsymops ) uc_nums = np . tile ( atoms , nsymops ) asym = np . arange ( len ( uc_nums )) % natom sym , uc_pos = self . space_group . apply_all_symops ( pos ) translated = np . fmod ( uc_pos + 7.0 , 1 ) tree = KDTree ( translated ) dist = tree . sparse_distance_matrix ( tree , max_distance = tolerance ) mask = np . ones ( len ( uc_pos ), dtype = bool ) # because crystals may have partially occupied sites # on special positions, we need to merge some sites # expected_natoms = np.sum(occupation) for ( i , j ), _ in dist . items (): if not ( i < j ): continue occupation [ i ] += occupation [ j ] mask [ j ] = False occupation = occupation [ mask ] if np . any ( occupation > 1.0 ): LOG . debug ( \"Some unit cell site occupations are > 1.0\" ) setattr ( self , \"_unit_cell_atom_dict\" , { \"asym_atom\" : asym [ mask ], \"frac_pos\" : translated [ mask ], \"element\" : uc_nums [ mask ], \"symop\" : sym [ mask ], \"label\" : labels [ mask ], \"occupation\" : occupation , \"cart_pos\" : self . to_cartesian ( translated [ mask ]), }, ) return getattr ( self , \"_unit_cell_atom_dict\" ) unit_cell_connectivity ( self , tolerance = 0.4 , neighbouring_cells = 1 ) Periodic connectiviy for the unit cell, populates _uc_graph with a networkx.Graph object, where nodes are indices into the _unit_cell_atom_dict arrays and the edges contain the translation (cell) for the image of the corresponding unit cell atom with the higher index to be bonded to the lower Bonding is determined by interatomic distances being less than the sum of covalent radii for the sites plus the tolerance (provided as a parameter) Parameters: Name Type Description Default tolerance float Bonding tolerance (bonded if d < cov_a + cov_b + tolerance) 0.4 neighbouring_cells int Number of neighbouring cells in which to look for bonded atoms. We start at the (0, 0, 0) cell, so a value of 1 will look in the (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells. 1 is typically sufficient for organic systems. 1 Returns: Type Description Tuple A tuple of (sparse_matrix in dict of keys format, dict) the (i, j) value in this matrix is the bond length from i,j the (i, j) value in the dict is the cell translation on j which bonds these two sites Source code in chmpy/crystal/crystal.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def unit_cell_connectivity ( self , tolerance = 0.4 , neighbouring_cells = 1 ) -> Tuple : \"\"\" Periodic connectiviy for the unit cell, populates _uc_graph with a networkx.Graph object, where nodes are indices into the _unit_cell_atom_dict arrays and the edges contain the translation (cell) for the image of the corresponding unit cell atom with the higher index to be bonded to the lower Bonding is determined by interatomic distances being less than the sum of covalent radii for the sites plus the tolerance (provided as a parameter) Arguments: tolerance (float, optional): Bonding tolerance (bonded if d < cov_a + cov_b + tolerance) neighbouring_cells (int, optional): Number of neighbouring cells in which to look for bonded atoms. We start at the (0, 0, 0) cell, so a value of 1 will look in the (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells. 1 is typically sufficient for organic systems. Returns: A tuple of (sparse_matrix in dict of keys format, dict) the (i, j) value in this matrix is the bond length from i,j the (i, j) value in the dict is the cell translation on j which bonds these two sites \"\"\" if hasattr ( self , \"_uc_graph\" ): return getattr ( self , \"_uc_graph\" ) slab = self . slab ( bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) n_uc = slab [ \"n_uc\" ] uc_pos = slab [ \"frac_pos\" ][: n_uc ] uc_nums = slab [ \"element\" ][: n_uc ] neighbour_pos = slab [ \"frac_pos\" ][ n_uc :] cart_uc_pos = self . to_cartesian ( uc_pos ) unique_elements = { x : Element . from_atomic_number ( x ) for x in np . unique ( uc_nums )} # first establish all connections in the unit cell covalent_radii = np . array ([ unique_elements [ x ] . cov for x in uc_nums ]) max_cov = np . max ( covalent_radii ) # TODO this needs to be sped up for large cells, tends to slow for > 1000 atoms # and the space storage will become a problem tree = KDTree ( cart_uc_pos ) dist = tree . sparse_distance_matrix ( tree , max_distance = 2 * max_cov + tolerance ) uc_edges = [] for ( i , j ), d in dist . items (): if not ( i < j ): continue if d > 1e-3 and d < ( covalent_radii [ i ] + covalent_radii [ j ] + tolerance ): uc_edges . append (( i , j , d , ( 0 , 0 , 0 ))) cart_neighbour_pos = self . unit_cell . to_cartesian ( neighbour_pos ) tree2 = KDTree ( cart_neighbour_pos ) dist = tree . sparse_distance_matrix ( tree2 , max_distance = 2 * max_cov + tolerance ) # could be sped up if done outside python cells = slab [ \"cell\" ][ n_uc :] for ( uc_atom , neighbour_atom ), d in dist . items (): uc_idx = neighbour_atom % n_uc if not ( uc_atom < uc_idx ): continue if d > 1e-3 and d < ( covalent_radii [ uc_atom ] + covalent_radii [ uc_idx ] + tolerance ): cell = cells [ neighbour_atom ] uc_edges . append (( uc_atom , uc_idx , d , tuple ( cell ))) properties = {} uc_graph = dok_matrix (( n_uc , n_uc )) for i , j , d , cell in uc_edges : uc_graph [ i , j ] = d properties [( i , j )] = cell setattr ( self , \"_uc_graph\" , ( uc_graph , properties )) return getattr ( self , \"_uc_graph\" ) unit_cell_molecules ( self ) Calculate the molecules for all sites in the unit cell, where the number of molecules will be equal to number of symmetry unique molecules times number of symmetry operations. Returns: Type Description List[chmpy.core.molecule.Molecule] A list of all connected molecules in this crystal, which when translated by the unit cell would produce the full crystal. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit * num_symm_operations Source code in chmpy/crystal/crystal.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def unit_cell_molecules ( self ) -> List [ Molecule ]: \"\"\" Calculate the molecules for all sites in the unit cell, where the number of molecules will be equal to number of symmetry unique molecules times number of symmetry operations. Returns: A list of all connected molecules in this crystal, which when translated by the unit cell would produce the full crystal. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit * num_symm_operations \"\"\" if hasattr ( self , \"_unit_cell_molecules\" ): return getattr ( self , \"_unit_cell_molecules\" ) uc_graph , edge_cells = self . unit_cell_connectivity () n_uc_mols , uc_mols = csgraph . connected_components ( csgraph = uc_graph , directed = False , return_labels = True ) uc_dict = getattr ( self , \"_unit_cell_atom_dict\" ) uc_frac = uc_dict [ \"frac_pos\" ] uc_elements = uc_dict [ \"element\" ] uc_asym = uc_dict [ \"asym_atom\" ] uc_symop = uc_dict [ \"symop\" ] molecules = [] n_uc = len ( uc_frac ) LOG . debug ( \" %d molecules in unit cell\" , n_uc_mols ) for i in range ( n_uc_mols ): nodes = np . where ( uc_mols == i )[ 0 ] root = nodes [ 0 ] elements = uc_elements [ nodes ] shifts = np . zeros (( n_uc , 3 )) ordered , pred = csgraph . breadth_first_order ( csgraph = uc_graph , i_start = root , directed = False ) for j in ordered [ 1 :]: i = pred [ j ] if j < i : shifts [ j , :] = shifts [ i , :] - edge_cells [( j , i )] else : shifts [ j , :] = shifts [ i , :] + edge_cells [( i , j )] positions = self . to_cartesian (( uc_frac + shifts )[ nodes ]) asym_atoms = uc_asym [ nodes ] reorder = np . argsort ( asym_atoms ) asym_atoms = asym_atoms [ reorder ] mol = Molecule . from_arrays ( elements = elements [ reorder ], positions = positions [ reorder ], guess_bonds = True , unit_cell_atoms = np . array ( nodes )[ reorder ], asymmetric_unit_atoms = asym_atoms , asymmetric_unit_labels = self . asymmetric_unit . labels [ asym_atoms ], generator_symop = uc_symop [ np . asarray ( nodes )[ reorder ]], ) centroid = mol . center_of_mass frac_centroid = self . to_fractional ( centroid ) new_centroid = np . fmod ( frac_centroid + 7.0 , 1.0 ) translation = self . to_cartesian ( new_centroid - frac_centroid ) mol . translate ( translation ) molecules . append ( mol ) setattr ( self , \"_unit_cell_molecules\" , molecules ) return molecules void_surface ( self , * args , ** kwargs ) Calculate void surface based on promolecule electron density for the unit cell of this crystal Parameters: Name Type Description Default kwargs Keyword arguments used in the evaluation of the surface. Options are: isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. {} Returns: Type Description Trimesh the mesh representing the promolecule density void isosurface Source code in chmpy/crystal/crystal.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def void_surface ( self , * args , ** kwargs ) -> Trimesh : \"\"\" Calculate void surface based on promolecule electron density for the unit cell of this crystal Args: kwargs: Keyword arguments used in the evaluation of the surface. Options are: ``` isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. ``` Returns: the mesh representing the promolecule density void isosurface \"\"\" from chmpy import PromoleculeDensity import trimesh from chmpy.mc import marching_cubes vertex_color = kwargs . get ( \"color\" , None ) atoms = self . slab ( bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) density = PromoleculeDensity (( atoms [ \"element\" ], atoms [ \"cart_pos\" ])) sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.5 )) isovalue = kwargs . get ( \"isovalue\" , 3e-4 ) grid_type = kwargs . get ( \"grid_type\" , \"uc\" ) if grid_type == \"uc\" : seps = sep / np . array ( self . unit_cell . lengths ) x_grid = np . arange ( 0 , 1.0 , seps [ 0 ], dtype = np . float32 ) y_grid = np . arange ( 0 , 1.0 , seps [ 1 ], dtype = np . float32 ) z_grid = np . arange ( 0 , 1.0 , seps [ 2 ], dtype = np . float32 ) x , y , z = np . meshgrid ( x_grid , y_grid , z_grid ) shape = x . shape pts = np . c_ [ x . ravel (), y . ravel (), z . ravel ()] pts = pts . astype ( np . float32 ) pts = self . to_cartesian ( pts ) elif grid_type == \"box\" : (( x0 , y0 , z0 ), ( x1 , y1 , z1 )) = kwargs . get ( \"box_corners\" , (( 0.0 , 0.0 , 0.0 ), ( 5.0 , 5.0 , 5.0 )) ) x , y , z = np . mgrid [ x0 : x1 : sep , y0 : y1 : sep , z0 : z1 : sep ] pts = np . c_ [ x . ravel (), y . ravel (), z . ravel ()] pts = pts . astype ( np . float32 ) shape = x . shape seps = ( sep , sep , sep ) else : raise NotImplementedError ( \"Only uc grid supported currently\" ) tree = KDTree ( atoms [ \"cart_pos\" ]) distances , _ = tree . query ( pts ) values = np . ones ( pts . shape [ 0 ], dtype = np . float32 ) mask = distances > 1.0 # minimum bigger than 1 angstrom rho = density . rho ( pts [ mask ]) values [ mask ] = rho values = values . reshape ( shape ) verts , faces , normals , _ = marching_cubes ( values , isovalue , spacing = seps , gradient_direction = \"ascent\" ) if grid_type == \"uc\" : verts = self . to_cartesian ( np . c_ [ verts [:, 1 ], verts [:, 0 ], verts [:, 2 ]]) mesh = trimesh . Trimesh ( vertices = verts , faces = faces , normals = normals ) if kwargs . get ( \"subdivide\" , False ): for _ in range ( int ( kwargs . get ( \"subdivide\" , False ))): mesh = mesh . subdivide () if vertex_color == \"esp\" : from chmpy.util.color import property_to_color asym_charges = self . asymmetric_unit_partial_charges () mol = Molecule . from_arrays ( atoms [ \"element\" ], atoms [ \"cart_pos\" ]) partial_charges = np . empty ( len ( mol ), dtype = np . float32 ) partial_charges = asym_charges [ atoms [ \"asym_atom\" ]] mol . _partial_charges = partial_charges prop = mol . electrostatic_potential ( mesh . vertices ) mesh . visual . vertex_colors = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , \"esp\" ) ) return mesh","title":"Crystal"},{"location":"API/crystal/crystal/#crystal","text":"Contains the Crystal objects, for 3D systems.","title":"crystal"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal","text":"","title":"chmpy.crystal.crystal"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal","text":"Storage class for a molecular crystal structure. Attributes: Name Type Description unit_cell UnitCell the translational symmetry space_group SpaceGroup the symmetry within the unit cell asymmetric_unit AsymmetricUnit the symmetry unique set of sites in the crystal. Contains information on atomic positions, elements, labels etc. properties dict variable collection of named properties for this crystal","title":"Crystal"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.asym","text":"short accessor for asymmetric_unit","title":"asym"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.density","text":"Calculated density of this crystal structure in g/cm^3","title":"density"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.id","text":"synonym for titl","title":"id"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.name","text":"synonym for titl","title":"name"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.nsites","text":"The number of sites in the asymmetric unit.","title":"nsites"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.sg","text":"short accessor for space_group","title":"sg"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_atoms","text":"Array of asymmetric unit atomic numbers","title":"site_atoms"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_labels","text":"array of labels for sites in the asymmetric_unit","title":"site_labels"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_positions","text":"Row major array of asymmetric unit atomic positions","title":"site_positions"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_operations","text":"Symmetry operations belonging to the space group symmetry of this crystal.","title":"symmetry_operations"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.uc","text":"short accessor for unit_cell","title":"uc"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.__init__","text":"Construct a new crystal. Parameters: Name Type Description Default unit_cell UnitCell The unit cell for this crystal i.e. the translational symmetry of the crystal structure. required space_group SpaceGroup The space group symmetry of this crystal i.e. the generators for populating the unit cell given the asymmetric unit. required asymmetric_unit AsymmetricUnit The asymmetric unit of this crystal. The sites of this combined with the space group will generate all translationally equivalent positions. required **kwargs Optional properties to (will populate the properties member) store about the the crystal structure. {} Source code in chmpy/crystal/crystal.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , unit_cell : UnitCell , space_group : SpaceGroup , asymmetric_unit : AsymmetricUnit , ** kwargs , ): \"\"\" Construct a new crystal. Arguments: unit_cell: The unit cell for this crystal i.e. the translational symmetry of the crystal structure. space_group: The space group symmetry of this crystal i.e. the generators for populating the unit cell given the asymmetric unit. asymmetric_unit: The asymmetric unit of this crystal. The sites of this combined with the space group will generate all translationally equivalent positions. **kwargs: Optional properties to (will populate the properties member) store about the the crystal structure. \"\"\" self . space_group = space_group self . unit_cell = unit_cell self . asymmetric_unit = asymmetric_unit self . properties = {} self . properties . update ( kwargs )","title":"__init__()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.as_P1","text":"Create a copy of this crystal in space group P 1, with the new asymmetric_unit consisting of self.unit_cell_molecules() Source code in chmpy/crystal/crystal.py 1628 1629 1630 1631 def as_P1 ( self ) -> \"Crystal\" : \"\"\"Create a copy of this crystal in space group P 1, with the new asymmetric_unit consisting of self.unit_cell_molecules()\"\"\" return self . as_P1_supercell (( 1 , 1 , 1 ))","title":"as_P1()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.as_P1_supercell","text":"Create a supercell of this crystal in space group P 1. Parameters: Name Type Description Default size Tuple[int] size of the P 1 supercell to be created required Returns: Type Description Crystal Crystal object of a supercell in space group P 1 Source code in chmpy/crystal/crystal.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 def as_P1_supercell ( self , size ) -> \"Crystal\" : \"\"\" Create a supercell of this crystal in space group P 1. Args: size (Tuple[int]): size of the P 1 supercell to be created Returns: Crystal object of a supercell in space group P 1 \"\"\" import itertools as it umax , vmax , wmax = size a , b , c = self . unit_cell . lengths sc = UnitCell . from_lengths_and_angles ( ( umax * a , vmax * b , wmax * c ), self . unit_cell . angles ) u = np . arange ( umax ) v = np . arange ( vmax ) w = np . arange ( wmax ) sc_mols = [] for q , r , s in it . product ( u , v , w ): for uc_mol in self . unit_cell_molecules (): sc_mols . append ( uc_mol . translated ( np . asarray ([ q , r , s ]) @ self . unit_cell . lattice ) ) asym_pos = np . vstack ([ x . positions for x in sc_mols ]) asym_nums = np . hstack ([ x . atomic_numbers for x in sc_mols ]) asymmetric_unit = AsymmetricUnit ( [ Element [ x ] for x in asym_nums ], sc . to_fractional ( asym_pos ) ) new_crystal = Crystal ( sc , SpaceGroup ( 1 ), asymmetric_unit ) new_crystal . properties [ \"titl\" ] = self . titl + \"-P1- {} - {} - {} \" . format ( * size ) return new_crystal","title":"as_P1_supercell()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.asymmetric_unit_partial_charges","text":"Calculate the partial charges for the asymmetric unit of this crystal using the EEM method. Returns: Type Description ndarray an ndarray of atomic partial charges. Source code in chmpy/crystal/crystal.py 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def asymmetric_unit_partial_charges ( self ) -> np . ndarray : \"\"\" Calculate the partial charges for the asymmetric unit of this crystal using the EEM method. Returns: an `ndarray` of atomic partial charges. \"\"\" mols = self . symmetry_unique_molecules () charges = np . empty ( len ( self . asymmetric_unit ), dtype = np . float32 ) for mol in mols : for idx , charge in zip ( mol . properties [ \"asymmetric_unit_atoms\" ], mol . partial_charges ): charges [ idx ] = charge return charges","title":"asymmetric_unit_partial_charges()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.atom_group_shape_descriptors","text":"Calculate the shape descriptors[1,2] for the given atomic group in this crystal. Parameters: Name Type Description Default atoms Tuple atoms to include in the as the 'inside' of the shape description. required l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 3.8 Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 def atom_group_shape_descriptors ( self , atoms , l_max = 5 , radius = 3.8 ) -> np . ndarray : \"\"\"Calculate the shape descriptors[1,2] for the given atomic group in this crystal. Args: atoms (Tuple): atoms to include in the as the 'inside' of the shape description. l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) inside , outside = self . atom_group_surroundings ( atoms , radius = radius ) m = Molecule . from_arrays ( * inside ) c = np . array ( m . centroid , dtype = np . float32 ) dists = np . linalg . norm ( m . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 return np . asarray ( stockholder_weight_descriptor ( sph , * inside , * outside , origin = c , bounds = bounds ) )","title":"atom_group_shape_descriptors()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.atom_group_surroundings","text":"Calculate all atoms within the given radius of the specified group of atoms in the asymetric unit. Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion 6.0 Returns: Type Description Tuple A list of atomic number, Cartesian position for both the atomic sites in question and their surroundings (as an array) Source code in chmpy/crystal/crystal.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def atom_group_surroundings ( self , atoms , radius = 6.0 ) -> Tuple : \"\"\" Calculate all atoms within the given `radius` of the specified group of atoms in the asymetric unit. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion Returns: A list of atomic number, Cartesian position for both the atomic sites in question and their surroundings (as an array) \"\"\" hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) mol = self . symmetry_unique_molecules ()[ 0 ] central_positions = self . to_fractional ( mol . positions [ atoms ]) central_elements = mol . atomic_numbers [ atoms ] central_cart_positions = mol . positions [ atoms ] for pos in central_positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) this_mol = [] for pos in central_cart_positions : idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < 1e-3 : this_mol . append ( nn ) keep [ this_mol ] = False return ( ( central_elements , central_cart_positions ), ( elements [ keep ], positions [ keep ]), )","title":"atom_group_surroundings()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.atomic_shape_descriptors","text":"Calculate the shape descriptors[1,2] for all symmetry unique atoms in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 3.8 Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 def atomic_shape_descriptors ( self , l_max = 5 , radius = 3.8 ) -> np . ndarray : \"\"\" Calculate the shape descriptors[1,2] for all symmetry unique atoms in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for n , pos , neighbour_els , neighbour_pos in self . atomic_surroundings ( radius = radius ): ubound = Element [ n ] . vdw_radius * 3 descriptors . append ( stockholder_weight_descriptor ( sph , [ n ], [ pos ], neighbour_els , neighbour_pos , bounds = ( 0.2 , ubound ) ) ) return np . asarray ( descriptors )","title":"atomic_shape_descriptors()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.atomic_surroundings","text":"Calculate all atoms within the given radius of each atomic site in the asymmetric unit. Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion 6.0 Returns: Type Description List[Tuple] A list of atomic number, Cartesian position for both the atomic site in question and the surroundings (as an array) Source code in chmpy/crystal/crystal.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 def atomic_surroundings ( self , radius = 6.0 ) -> List [ Tuple ]: \"\"\" Calculate all atoms within the given `radius` of each atomic site in the asymmetric unit. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion Returns: A list of atomic number, Cartesian position for both the atomic site in question and the surroundings (as an array) \"\"\" cart_asym = self . to_cartesian ( self . asymmetric_unit . positions ) hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . asymmetric_unit . positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) tree = KDTree ( slab [ \"cart_pos\" ]) results = [] for n , pos in zip ( self . asymmetric_unit . elements , cart_asym ): idxs = tree . query_ball_point ( pos , radius ) positions = slab [ \"cart_pos\" ][ idxs ] elements = slab [ \"element\" ][ idxs ] d = np . linalg . norm ( positions - pos , axis = 1 ) keep = np . where ( d > 1e-3 )[ 0 ] results . append (( n . atomic_number , pos , elements [ keep ], positions [ keep ])) return results","title":"atomic_surroundings()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.atoms_in_radius","text":"Calculate all (periodic) atoms within the given radius of the specified origin . Parameters: Name Type Description Default radius float the maximum distance (Angstroms) from the origin for inclusion required origin Tuple the origin in fractional coordinates (0, 0, 0) Returns: Type Description dict A dictionary mapping (see the the slab method), of those atoms within radius of the origin . Source code in chmpy/crystal/crystal.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 def atoms_in_radius ( self , radius , origin = ( 0 , 0 , 0 )) -> dict : \"\"\" Calculate all (periodic) atoms within the given `radius` of the specified `origin`. Arguments: radius (float): the maximum distance (Angstroms) from the origin for inclusion origin (Tuple, optional): the origin in fractional coordinates Returns: A dictionary mapping (see the the `slab` method), of those atoms within `radius` of the `origin`. \"\"\" frac_origin = self . to_fractional ( origin ) frac_radius = radius / np . array ( self . unit_cell . lengths ) hmax , kmax , lmax = np . ceil ( frac_radius + frac_origin ) . astype ( int ) hmin , kmin , lmin = np . floor ( frac_origin - frac_radius ) . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) tree = KDTree ( slab [ \"cart_pos\" ]) idxs = sorted ( tree . query_ball_point ( origin , radius )) result = { k : v [ idxs ] for k , v in slab . items () if isinstance ( v , np . ndarray )} result [ \"uc_atom\" ] = np . tile ( np . arange ( slab [ \"n_uc\" ]), slab [ \"n_cells\" ])[ idxs ] return result","title":"atoms_in_radius()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.cartesian_symmetry_operations","text":"Create a list of symmetry operations (rotation, translation) for evaluation of transformations in cartesian space. The rotation matrices are stored to be used as np.dot(x, R), (i.e. post-multiplicaiton on row-major coordinates) Returns: Type Description List[Tuple[np.ndarray, np.ndarray]] a list of (rotation, translation) Source code in chmpy/crystal/crystal.py 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 def cartesian_symmetry_operations ( self ): \"\"\" Create a list of symmetry operations (rotation, translation) for evaluation of transformations in cartesian space. The rotation matrices are stored to be used as np.dot(x, R), (i.e. post-multiplicaiton on row-major coordinates) Returns: List[Tuple[np.ndarray, np.ndarray]]: a list of (rotation, translation) \"\"\" cart_symops = [] d = self . unit_cell . direct i = self . unit_cell . inverse for symop in self . symmetry_operations : cart_symops . append ( ( np . dot ( d . T , np . dot ( symop . rotation , i . T )) . T , self . to_cartesian ( symop . translation ), ) ) return cart_symops","title":"cartesian_symmetry_operations()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.choose_trigonal_lattice","text":"Change the choice of lattice for this crystal to either rhombohedral or hexagonal cell Parameters: Name Type Description Default choice str The choice of the resulting lattice, either 'H' for hexagonal or 'R' for rhombohedral (default 'H'). 'H' Source code in chmpy/crystal/crystal.py 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 def choose_trigonal_lattice ( self , choice = \"H\" ): \"\"\" Change the choice of lattice for this crystal to either rhombohedral or hexagonal cell Args: choice (str, optional): The choice of the resulting lattice, either 'H' for hexagonal or 'R' for rhombohedral (default 'H'). \"\"\" if not self . space_group . has_hexagonal_rhombohedral_choices (): raise ValueError ( \"Invalid space group for choose_trigonal_lattice\" ) if self . space_group . choice == choice : return cart_asym_pos = self . to_cartesian ( self . asymmetric_unit . positions ) assert choice in ( \"H\" , \"R\" ), \"Valid choices are H, R\" if self . space_group . choice == \"R\" : T = np . array ((( - 1 , 1 , 0 ), ( 1 , 0 , - 1 ), ( 1 , 1 , 1 ))) else : T = 1 / 3 * np . array ((( - 1 , 1 , 1 ), ( 2 , 1 , 1 ), ( - 1 , - 2 , 1 ))) new_uc = UnitCell ( np . dot ( T , self . unit_cell . direct )) self . unit_cell = new_uc self . asymmetric_unit . positions = self . to_fractional ( cart_asym_pos ) self . space_group = SpaceGroup ( self . space_group . international_tables_number , choice = choice )","title":"choose_trigonal_lattice()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_cif_data","text":"Initialize a crystal structure from a dictionary of CIF data Source code in chmpy/crystal/crystal.py 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 @classmethod def from_cif_data ( cls , cif_data , titl = None ): \"\"\"Initialize a crystal structure from a dictionary of CIF data\"\"\" labels = cif_data . get ( \"atom_site_label\" , None ) symbols = cif_data . get ( \"atom_site_type_symbol\" , None ) if symbols is None : if labels is None : raise ValueError ( \"Unable to determine elements in CIF, \" \"need one of _atom_site_label or \" \"_atom_site_type_symbol present\" ) elements = [ Element [ x ] for x in labels ] else : elements = [ Element [ x ] for x in symbols ] x = np . asarray ( cif_data . get ( \"atom_site_fract_x\" , [])) y = np . asarray ( cif_data . get ( \"atom_site_fract_y\" , [])) z = np . asarray ( cif_data . get ( \"atom_site_fract_z\" , [])) occupation = np . asarray ( cif_data . get ( \"atom_site_occupancy\" , [ 1 ] * len ( x ))) frac_pos = np . array ([ x , y , z ]) . T asym = AsymmetricUnit ( elements = elements , positions = frac_pos , labels = labels , occupation = occupation ) lengths = [ cif_data [ f \"cell_length_ { x } \" ] for x in ( \"a\" , \"b\" , \"c\" )] angles = [ cif_data [ f \"cell_angle_ { x } \" ] for x in ( \"alpha\" , \"beta\" , \"gamma\" )] unit_cell = UnitCell . from_lengths_and_angles ( lengths , angles , unit = \"degrees\" ) space_group = SpaceGroup ( 1 ) symop_data_names = ( \"symmetry_equiv_pos_as_xyz\" , \"space_group_symop_operation_xyz\" , ) number = space_group . international_tables_number for k in ( \"space_group_IT_number\" , \"symmetry_Int_Tables_number\" ): if k in cif_data : number = cif_data [ k ] break for symop_data_block in symop_data_names : if symop_data_block in cif_data : symops = [ SymmetryOperation . from_string_code ( x ) for x in cif_data [ symop_data_block ] ] try : new_sg = SpaceGroup . from_symmetry_operations ( symops ) space_group = new_sg except ValueError : space_group . symmetry_operations = symops symbol = cif_data . get ( \"symmetry_space_group_name_H-M\" , \"Unknown\" ) space_group . international_tables_number = number space_group . symbol = symbol space_group . full_symbol = symbol LOG . warn ( \"Initializing non-standard spacegroup setting %s , \" \"some SG data may be missing\" , symbol , ) break else : # fall back to international tables number space_group = SpaceGroup ( number ) return Crystal ( unit_cell , space_group , asym , cif_data = cif_data , titl = titl )","title":"from_cif_data()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_cif_file","text":"Initialize a crystal structure from a CIF file Source code in chmpy/crystal/crystal.py 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 @classmethod def from_cif_file ( cls , filename , data_block_name = None ): \"\"\"Initialize a crystal structure from a CIF file\"\"\" cif = Cif . from_file ( filename ) if data_block_name is not None : return cls . from_cif_data ( cif . data [ data_block_name ], titl = data_block_name ) crystals = { name : cls . from_cif_data ( data , titl = name ) for name , data in cif . data . items () } keys = list ( crystals . keys ()) if len ( keys ) == 1 : return crystals [ keys [ 0 ]] return crystals","title":"from_cif_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_shelx_file","text":"Initialize a crystal structure from a shelx .res file Source code in chmpy/crystal/crystal.py 1393 1394 1395 1396 1397 1398 @classmethod def from_shelx_file ( cls , filename , ** kwargs ): \"\"\"Initialize a crystal structure from a shelx .res file\"\"\" p = Path ( filename ) titl = p . stem return cls . from_shelx_string ( p . read_text (), titl = titl , ** kwargs )","title":"from_shelx_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_shelx_string","text":"Initialize a crystal structure from a shelx .res string Source code in chmpy/crystal/crystal.py 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 @classmethod def from_shelx_string ( cls , file_content , ** kwargs ): \"\"\"Initialize a crystal structure from a shelx .res string\"\"\" from chmpy.fmt.shelx import parse_shelx_file_content shelx_dict = parse_shelx_file_content ( file_content ) asymmetric_unit = AsymmetricUnit . from_records ( shelx_dict [ \"ATOM\" ]) space_group = SpaceGroup . from_symmetry_operations ( shelx_dict [ \"SYMM\" ], expand_latt = shelx_dict [ \"LATT\" ] ) unit_cell = UnitCell . from_lengths_and_angles ( shelx_dict [ \"CELL\" ][ \"lengths\" ], shelx_dict [ \"CELL\" ][ \"angles\" ], unit = \"degrees\" ) return cls ( unit_cell , space_group , asymmetric_unit , ** kwargs )","title":"from_shelx_string()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_vasp_file","text":"Initialize a crystal structure from a VASP POSCAR file Source code in chmpy/crystal/crystal.py 1292 1293 1294 1295 @classmethod def from_vasp_file ( cls , filename , ** kwargs ): \"Initialize a crystal structure from a VASP POSCAR file\" return cls . from_vasp_string ( Path ( filename ) . read_text (), ** kwargs )","title":"from_vasp_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_vasp_string","text":"Initialize a crystal structure from a VASP POSCAR string Source code in chmpy/crystal/crystal.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 @classmethod def from_vasp_string ( cls , string , ** kwargs ): \"Initialize a crystal structure from a VASP POSCAR string\" from chmpy.fmt.vasp import parse_poscar vasp_data = parse_poscar ( string ) uc = UnitCell ( vasp_data [ \"direct\" ]) sg = SpaceGroup ( 1 ) coords = vasp_data [ \"positions\" ] if not vasp_data [ \"coord_type\" ] . startswith ( \"d\" ): coords = uc . to_fractional ( coords ) asym = AsymmetricUnit ( vasp_data [ \"elements\" ], coords ) return Crystal ( uc , sg , asym , titl = vasp_data [ \"name\" ])","title":"from_vasp_string()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.functional_group_shape_descriptors","text":"Calculate the shape descriptors [1,2] for the all atoms in the functional group given for all symmetry unique molecules in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. (default: 5) 5 radius float maximum distance (Angstroms) of neighbouring atoms to include in stockholder weight calculation (default: 5) 6.0 kind str Identifier for the functional group type (default: 'carboxylic_acid') 'carboxylic_acid' Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 def functional_group_shape_descriptors ( self , l_max = 5 , radius = 6.0 , kind = \"carboxylic_acid\" ) -> np . ndarray : \"\"\" Calculate the shape descriptors `[1,2]` for the all atoms in the functional group given for all symmetry unique molecules in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. (default: 5) radius (float, optional): maximum distance (Angstroms) of neighbouring atoms to include in stockholder weight calculation (default: 5) kind (str, optional): Identifier for the functional group type (default: 'carboxylic_acid') Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for ( in_els , in_pos , neighbour_els , neighbour_pos , ) in self . functional_group_surroundings ( kind = kind , radius = radius ): masses = np . asarray ([ Element [ x ] . mass for x in in_els ]) c = np . sum ( in_pos * masses [:, np . newaxis ] / np . sum ( masses ), axis = 0 ) . astype ( np . float32 ) dists = np . linalg . norm ( in_pos - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 descriptors . append ( stockholder_weight_descriptor ( sph , in_els , in_pos , neighbour_els , neighbour_pos , origin = c , bounds = bounds , ) ) return np . asarray ( descriptors )","title":"functional_group_shape_descriptors()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.functional_group_surroundings","text":"Calculate the atomic information for all atoms surrounding each functional group in each symmetry unique molecule in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 kind str the functional group type 'carboxylic_acid' Returns: Type Description List A list of tuples of (func_el, func_pos, neigh_el, neigh_pos) where func_el and neigh_el are np.ndarray of atomic numbers, and func_pos and neigh_pos are np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 def functional_group_surroundings ( self , radius = 6.0 , kind = \"carboxylic_acid\" ) -> List : \"\"\" Calculate the atomic information for all atoms surrounding each functional group in each symmetry unique molecule in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms kind (str, optional): the functional group type Returns: A list of tuples of (func_el, func_pos, neigh_el, neigh_pos) where `func_el` and `neigh_el` are `np.ndarray` of atomic numbers, and `func_pos` and `neigh_pos` are `np.ndarray` of Cartesian atomic positions \"\"\" results = [] for mol in self . symmetry_unique_molecules (): hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . to_fractional ( mol . positions ): hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) groups = mol . functional_groups ( kind = kind ) for fg in groups : fg = list ( fg ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) inside = [] for pos in mol . positions [ fg ]: idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < 1e-3 : inside . append ( nn ) keep [ inside ] = False results . append ( ( mol . atomic_numbers [ fg ], mol . positions [ fg ], elements [ keep ], positions [ keep ], ) ) return results","title":"functional_group_surroundings()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.hirshfeld_surfaces","text":"Alias for self.stockholder_weight_isosurfaces Source code in chmpy/crystal/crystal.py 904 905 906 def hirshfeld_surfaces ( self , ** kwargs ): \"Alias for `self.stockholder_weight_isosurfaces`\" return self . stockholder_weight_isosurfaces ( ** kwargs )","title":"hirshfeld_surfaces()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.load","text":"Load a crystal structure from file (.res, .cif) Parameters: Name Type Description Default filename str the path to the crystal structure file required Returns: Type Description Union[Crystal, dict] the resulting crystal structure or dictionary of crystal structures Source code in chmpy/crystal/crystal.py 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 @classmethod def load ( cls , filename , ** kwargs ) -> Union [ \"Crystal\" , dict ]: \"\"\" Load a crystal structure from file (.res, .cif) Args: filename (str): the path to the crystal structure file Returns: the resulting crystal structure or dictionary of crystal structures \"\"\" fpath = Path ( filename ) n = fpath . name fname_map = cls . _fname_load_map () if n in fname_map : return fname_map [ n ]( filename ) extension_map = cls . _ext_load_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs )","title":"load()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.mesh_scene","text":"Calculate a scene of this meshes of unit cell molecules in this crystal, along with optional void surface. Parameters: Name Type Description Default kwargs optional arguments used in the generation of this scene. {} Returns: Type Description trimesh.scene.Scene trimesh scene object. Source code in chmpy/crystal/crystal.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 def mesh_scene ( self , ** kwargs ): \"\"\" Calculate a scene of this meshes of unit cell molecules in this crystal, along with optional void surface. Args: kwargs: optional arguments used in the generation of this scene. Returns: trimesh.scene.Scene: trimesh scene object. \"\"\" from trimesh import Scene meshes = {} for i , m in enumerate ( self . unit_cell_molecules ()): mesh = m . to_mesh ( representation = kwargs . get ( \"representation\" , \"ball_stick\" )) n = m . molecular_formula for k , v in mesh . items (): meshes [ f \"mol_ { i } _ { n } . { k } \" ] = v if kwargs . get ( \"void\" , False ): void_kwargs = kwargs . get ( \"void_kwargs\" , {}) meshes [ \"void_surface\" ] = self . void_surface ( ** void_kwargs ) if kwargs . get ( \"axes\" , False ): from trimesh.creation import axis meshes [ \"axes\" ] = axis ( transform = self . unit_cell . direct_homogeneous . T , axis_length = 1.0 ) return Scene ( meshes )","title":"mesh_scene()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecular_shape_descriptors","text":"Calculate the molecular shape descriptors[1,2] for all symmetry unique molecules in this crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 6.0 with_property str name of the surface property to include in the shape description None Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 def molecular_shape_descriptors ( self , l_max = 5 , radius = 6.0 , with_property = None ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors[1,2] for all symmetry unique molecules in this crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description with_property (str, optional): name of the surface property to include in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" descriptors = [] from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) for mol , neighbour_els , neighbour_pos in self . molecule_environments ( radius = radius ): c = np . array ( mol . centroid , dtype = np . float32 ) dists = np . linalg . norm ( mol . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 descriptors . append ( stockholder_weight_descriptor ( sph , mol . atomic_numbers , mol . positions , neighbour_els , neighbour_pos , origin = c , bounds = bounds , with_property = with_property , ) ) return np . asarray ( descriptors )","title":"molecular_shape_descriptors()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecular_shell","text":"Calculate the neighbouring molecules around the molecule with index mol_idx , within the given radius using the specified method . Parameters: Name Type Description Default mol_idx int The index (into symmetry_unique_molecules ) of the central molecule for the shell 0 radius float The maximum distance (Angstroms) between the central molecule and the neighbours. 3.8 method str the method to use when determining inclusion of neighbours. 'nearest_atom' Returns: Type Description List[chmpy.core.molecule.Molecule] A list of neighbouring molecules using the given method. Source code in chmpy/crystal/crystal.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def molecular_shell ( self , mol_idx = 0 , radius = 3.8 , method = \"nearest_atom\" ) -> List [ Molecule ]: \"\"\" Calculate the neighbouring molecules around the molecule with index `mol_idx`, within the given `radius` using the specified `method`. Arguments: mol_idx (int, optional): The index (into `symmetry_unique_molecules`) of the central molecule for the shell radius (float, optional): The maximum distance (Angstroms) between the central molecule and the neighbours. method (str, optional): the method to use when determining inclusion of neighbours. Returns: A list of neighbouring molecules using the given method. \"\"\" mol = self . symmetry_unique_molecules ()[ mol_idx ] frac_origin = self . to_fractional ( mol . center_of_mass ) frac_radius = radius / np . array ( self . unit_cell . lengths ) hmax , kmax , lmax = np . ceil ( frac_radius + frac_origin ) . astype ( int ) + 1 hmin , kmin , lmin = np . floor ( frac_origin - frac_radius ) . astype ( int ) - 1 uc_mols = self . unit_cell_molecules () shifts = self . to_cartesian ( cartesian_product ( np . arange ( hmin , hmax ), np . arange ( kmin , kmax ), np . arange ( lmin , lmax ) ) ) neighbours = [] for uc_mol in uc_mols : for shift in shifts : uc_mol_t = uc_mol . translated ( shift ) dist = mol . distance_to ( uc_mol_t , method = method ) if ( dist < radius ) and ( dist > 1e-2 ): neighbours . append ( uc_mol_t ) return neighbours","title":"molecular_shell()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_dict","text":"A dictionary of symmetry_unique_molecules , grouped by their chemical formulae. Returns: Type Description dict the dictionary of molecules with chemical formula keys and list of molecule values. Source code in chmpy/crystal/crystal.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def molecule_dict ( self , ** kwargs ) -> dict : \"\"\" A dictionary of `symmetry_unique_molecules`, grouped by their chemical formulae. Returns: the dictionary of molecules with chemical formula keys and list of molecule values. \"\"\" result = {} mols = self . symmetry_unique_molecules () for m in mols : f = m . molecular_formula if f not in result : result [ f ] = [] result [ f ] . append ( m ) return result","title":"molecule_dict()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_environment","text":"Calculate the atomic information for all atoms surrounding the given molecule in this crystal within the given radius. Atoms closer than threshold to any atom in the provided molecule will be excluded and considered part of the molecule. Parameters: Name Type Description Default mol Molecule the molecule whose environment to calculate required radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 threshold float tolerance for detecting the neighbouring sites as part of the given molecule. 0.001 Returns: Type Description Tuple A list of tuples of (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 def molecule_environment ( self , mol , radius = 6.0 , threshold = 1e-3 ) -> Tuple : \"\"\" Calculate the atomic information for all atoms surrounding the given molecule in this crystal within the given radius. Atoms closer than `threshold` to any atom in the provided molecule will be excluded and considered part of the molecule. Args: mol (Molecule): the molecule whose environment to calculate radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms threshold (float, optional): tolerance for detecting the neighbouring sites as part of the given molecule. Returns: A list of tuples of (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . to_fractional ( mol . positions ): hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) slab = self . slab ( bounds = (( hmin , kmin , lmin ), ( hmax , kmax , lmax ))) elements = slab [ \"element\" ] positions = slab [ \"cart_pos\" ] tree = KDTree ( positions ) keep = np . zeros ( positions . shape [ 0 ], dtype = bool ) this_mol = [] for pos in mol . positions : idxs = tree . query_ball_point ( pos , radius ) d , nn = tree . query ( pos ) keep [ idxs ] = True if d < threshold : this_mol . append ( nn ) keep [ this_mol ] = False return ( mol , elements [ keep ], positions [ keep ])","title":"molecule_environment()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_environments","text":"Calculate the atomic information for all atoms surrounding each symmetry unique molecule in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 6.0 threshold float tolerance for detecting the neighbouring sites as part of the given molecule. 0.001 Returns: Type Description List[Tuple] A list of tuples of (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 def molecule_environments ( self , radius = 6.0 , threshold = 1e-3 ) -> List [ Tuple ]: \"\"\" Calculate the atomic information for all atoms surrounding each symmetry unique molecule in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms threshold (float, optional): tolerance for detecting the neighbouring sites as part of the given molecule. Returns: A list of tuples of (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" return [ self . molecule_environment ( x , radius = radius , threshold = threshold ) for x in self . symmetry_unique_molecules () ]","title":"molecule_environments()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_shape_descriptors","text":"Calculate the molecular shape descriptors [1,2] for the provided molecule in the crystal. Parameters: Name Type Description Default l_max int maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. 5 radius float maximum distance (Angstroms) to include surroundings in the shape description 6.0 with_property str name of the surface property to include in the shape description None Returns: Type Description ndarray shape description vector References: [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 Source code in chmpy/crystal/crystal.py 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 def molecule_shape_descriptors ( self , mol , l_max = 5 , radius = 6.0 , with_property = None ) -> np . ndarray : \"\"\" Calculate the molecular shape descriptors `[1,2]` for the provided molecule in the crystal. Args: l_max (int, optional): maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. radius (float, optional): maximum distance (Angstroms) to include surroundings in the shape description with_property (str, optional): name of the surface property to include in the shape description Returns: shape description vector References: ``` [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016) https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019) https://dx.doi.org/10.1002/anie.201906602 ``` \"\"\" from chmpy.shape import SHT , stockholder_weight_descriptor sph = SHT ( l_max = l_max ) mol , neighbour_els , neighbour_pos = self . molecule_environment ( mol , radius = radius ) c = np . array ( mol . centroid , dtype = np . float32 ) dists = np . linalg . norm ( mol . positions - c , axis = 1 ) bounds = np . min ( dists ) / 2 , np . max ( dists ) + 10.0 return stockholder_weight_descriptor ( sph , mol . atomic_numbers , mol . positions , neighbour_els , neighbour_pos , origin = c , bounds = bounds , with_property = with_property , )","title":"molecule_shape_descriptors()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.promolecule_density_isosurfaces","text":"Calculate promolecule electron density isosurfaces for each symmetry unique molecule in this crystal. Parameters: Name Type Description Default kwargs Keyword arguments used by Molecule.promolecule_density_isosurface . Options are: isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. color (str, optional): surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap (str, optional): matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint (float, optional): midpoint of the segmented colormap (if applicable) {} Returns: Type Description List[trimesh.base.Trimesh] A list of meshes representing the promolecule density isosurfaces Source code in chmpy/crystal/crystal.py 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 def promolecule_density_isosurfaces ( self , ** kwargs ) -> List [ Trimesh ]: \"\"\" Calculate promolecule electron density isosurfaces for each symmetry unique molecule in this crystal. Args: kwargs: Keyword arguments used by `Molecule.promolecule_density_isosurface`. Options are: ``` isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. color (str, optional): surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e') colormap (str, optional): matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint (float, optional): midpoint of the segmented colormap (if applicable) ``` Returns: A list of meshes representing the promolecule density isosurfaces \"\"\" return [ mol . promolecule_density_isosurface ( ** kwargs ) for mol in self . symmetry_unique_molecules () ]","title":"promolecule_density_isosurfaces()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.save","text":"Save this crystal structure to file (.cif, .res, POSCAR) Source code in chmpy/crystal/crystal.py 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def save ( self , filename , ** kwargs ): \"\"\"Save this crystal structure to file (.cif, .res, POSCAR)\"\"\" fpath = Path ( filename ) n = fpath . name fname_map = self . _fname_save_map () if n in fname_map : return fname_map [ n ]( filename , ** kwargs ) extension_map = self . _ext_save_map () extension = kwargs . pop ( \"fmt\" , fpath . suffix . lower ()) if not extension . startswith ( \".\" ): extension = \".\" + extension return extension_map [ extension ]( filename , ** kwargs )","title":"save()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.slab","text":"Calculate the atoms and associated information for a slab consisting of multiple unit cells. If unit cell atoms have not been calculated, this calculates their information and caches it. Parameters: Name Type Description Default bounds Tuple Tuple of upper and lower corners (hkl) describing the bounds of the slab. ((-1, -1, -1), (1, 1, 1)) Returns: Type Description dict A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 cell: (N,3) array of cell indices for each site n_uc: number of atoms in the unit cell n_cells: number of cells in this slab occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 Source code in chmpy/crystal/crystal.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 def slab ( self , bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) -> dict : \"\"\" Calculate the atoms and associated information for a slab consisting of multiple unit cells. If unit cell atoms have not been calculated, this calculates their information and caches it. Args: bounds (Tuple, optional): Tuple of upper and lower corners (hkl) describing the bounds of the slab. Returns: A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 cell: (N,3) array of cell indices for each site n_uc: number of atoms in the unit cell n_cells: number of cells in this slab occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 \"\"\" uc_atoms = self . unit_cell_atoms () ( hmin , kmin , lmin ), ( hmax , kmax , lmax ) = bounds h = np . arange ( hmin , hmax + 1 ) k = np . arange ( kmin , kmax + 1 ) l = np . arange ( lmin , lmax + 1 ) # noqa: E741 cells = cartesian_product ( h [ np . argsort ( np . abs ( h ))], k [ np . argsort ( np . abs ( k ))], l [ np . argsort ( np . abs ( l ))] ) ncells = len ( cells ) uc_pos = uc_atoms [ \"frac_pos\" ] n_uc = len ( uc_pos ) pos = np . empty (( ncells * n_uc , 3 ), dtype = np . float64 ) slab_cells = np . empty (( ncells * n_uc , 3 ), dtype = np . float64 ) for i , cell in enumerate ( cells ): pos [ i * n_uc : ( i + 1 ) * n_uc , :] = uc_pos + cell slab_cells [ i * n_uc : ( i + 1 ) * n_uc ] = cell slab_dict = { k : np . tile ( v , ncells ) for k , v in uc_atoms . items () if not k . endswith ( \"pos\" ) } slab_dict [ \"frac_pos\" ] = pos slab_dict [ \"cell\" ] = slab_cells slab_dict [ \"n_uc\" ] = n_uc slab_dict [ \"n_cells\" ] = ncells slab_dict [ \"cart_pos\" ] = self . to_cartesian ( pos ) return slab_dict","title":"slab()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.stockholder_weight_isosurfaces","text":"Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces) for each symmetry unique molecule or atom in this crystal. Parameters: Name Type Description Default kind str dictates whether we calculate surfaces for each unique molecule or for each unique atom 'mol' kwargs keyword arguments passed to stockholder_weight_isosurface . Options include: isovalue : float , optional level set value for the isosurface ( default = 0.5 ). Must be between 0 and 1 , but values other than 0.5 probably won 't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of (' d_norm_i ', ' d_i ', ' d_norm_e ', ' d_e ', ' d_norm ') colormap: str, optional matplotlib colormap to use for surface coloring (default ' viridis_r ' ) midpoint : float , optional , default 0.0 if using d_norm use the midpoint norm ( as is used in CrystalExplorer ) {} Returns: Type Description List[trimesh.base.Trimesh] A list of meshes representing the stockholder weight isosurfaces Source code in chmpy/crystal/crystal.py 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 def stockholder_weight_isosurfaces ( self , kind = \"mol\" , ** kwargs ) -> List [ Trimesh ]: \"\"\" Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces) for each symmetry unique molecule or atom in this crystal. Args: kind (str, optional): dictates whether we calculate surfaces for each unique molecule or for each unique atom kwargs: keyword arguments passed to `stockholder_weight_isosurface`. Options include: ``` isovalue: float, optional level set value for the isosurface (default=0.5). Must be between 0 and 1, but values other than 0.5 probably won't make sense anyway. separation: float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms. radius: float, optional maximum distance for contributing neighbours for the stockholder weight calculation color: str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e', 'd_norm') colormap: str, optional matplotlib colormap to use for surface coloring (default 'viridis_r') midpoint: float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer) ``` Returns: A list of meshes representing the stockholder weight isosurfaces \"\"\" from chmpy import StockholderWeight from chmpy.surface import stockholder_weight_isosurface from chmpy.util.color import property_to_color import trimesh sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.2 )) radius = kwargs . get ( \"radius\" , 12.0 ) vertex_color = kwargs . get ( \"color\" , \"d_norm\" ) isovalue = kwargs . get ( \"isovalue\" , 0.5 ) meshes = [] extra_props = {} isos = [] if kind == \"atom\" : for n , pos , neighbour_els , neighbour_pos in self . atomic_surroundings ( radius = radius ): s = StockholderWeight . from_arrays ( [ n ], [ pos ], neighbour_els , neighbour_pos ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) elif kind == \"mol\" : for mol , n_e , n_p in self . molecule_environments ( radius = radius ): if vertex_color == \"esp\" : extra_props [ \"esp\" ] = mol . electrostatic_potential s = StockholderWeight . from_arrays ( mol . atomic_numbers , mol . positions , n_e , n_p ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep , extra_props = extra_props ) isos . append ( iso ) else : for arr in self . functional_group_surroundings ( radius = radius , kind = kind ): s = StockholderWeight . from_arrays ( * arr ) iso = stockholder_weight_isosurface ( s , isovalue = isovalue , sep = sep ) isos . append ( iso ) for iso in isos : prop = iso . vertex_prop [ vertex_color ] color = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , vertex_color )) mesh = trimesh . Trimesh ( vertices = iso . vertices , faces = iso . faces , normals = iso . normals , vertex_colors = color , ) meshes . append ( mesh ) return meshes","title":"stockholder_weight_isosurfaces()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_unique_dimers","text":"Calculate the information for all molecule pairs surrounding the symmetry_unique_molecules in this crystal within the given radius. Parameters: Name Type Description Default radius float Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms 3.8 Returns: Type Description A dictionary of dimers (Molecule, elements, positions) where elements is an np.ndarray of atomic numbers, and positions is an np.ndarray of Cartesian atomic positions Source code in chmpy/crystal/crystal.py 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 def symmetry_unique_dimers ( self , radius = 3.8 , distance_method = \"nearest_atom\" ): \"\"\" Calculate the information for all molecule pairs surrounding the symmetry_unique_molecules in this crystal within the given radius. Args: radius (float, optional): Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms Returns: A dictionary of dimers (Molecule, elements, positions) where `elements` is an `np.ndarray` of atomic numbers, and `positions` is an `np.ndarray` of Cartesian atomic positions \"\"\" from chmpy.core.dimer import Dimer from copy import deepcopy from collections import defaultdict hklmax = np . array ([ - np . inf , - np . inf , - np . inf ]) hklmin = np . array ([ np . inf , np . inf , np . inf ]) frac_radius = radius / np . array ( self . unit_cell . lengths ) for pos in self . asymmetric_unit . positions : hklmax = np . maximum ( hklmax , np . ceil ( frac_radius + pos )) hklmin = np . minimum ( hklmin , np . floor ( pos - frac_radius )) hmax , kmax , lmax = hklmax . astype ( int ) hmin , kmin , lmin = hklmin . astype ( int ) shifts_frac = cartesian_product ( np . arange ( hmin , hmax ), np . arange ( kmin , kmax ), np . arange ( lmin , lmax ) ) shifts = self . to_cartesian ( shifts_frac ) LOG . debug ( \"Looking in %d neighbouring cells: %s : %s \" , len ( shifts ), hklmin . astype ( int ), hklmax . astype ( int ), ) all_dimers = [] mol_dimers = [] for mol_a in self . symmetry_unique_molecules (): dimers_a = [] for mol_b in self . unit_cell_molecules (): for shift , shift_frac in zip ( shifts , shifts_frac ): # shift_frac assumes the molecule is generated from the [0, 0, 0] cell, it's not mol_bt = mol_b . translated ( shift ) r = mol_a . distance_to ( mol_bt , method = distance_method ) if r > 1e-1 and r < radius : d = Dimer ( mol_a , mol_bt , separation = r , transform_ab = \"calculate\" , frac_shift = shift_frac , ) for i , dimer in enumerate ( all_dimers ): if dimer . separation <= d . separation + 1e-3 : if d == dimer : dimers_a . append ( i ) break else : dimers_a . append ( len ( all_dimers )) all_dimers . append ( d ) all_dimers = sorted ( all_dimers , key = lambda x : x . separation ) mol_dimers . append ( dimers_a ) return all_dimers , mol_dimers","title":"symmetry_unique_dimers()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_unique_molecules","text":"Calculate a list of connected molecules which contain every site in the asymmetric_unit Populates the _symmetry_unique_molecules member, subsequent calls to this function will be a no-op. Parameters: Name Type Description Default bond_tolerance float Bonding tolerance (bonded if d < cov_a + cov_b + bond_tolerance) 0.4 Returns: Type Description List[chmpy.core.molecule.Molecule] List of all connected molecules in the asymmetric_unit of this crystal, i.e. the minimum list of connected molecules which contain all sites in the asymmetric unit. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit and the total number of atoms will be equal to the number of atoms in the asymmetric_unit Source code in chmpy/crystal/crystal.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def symmetry_unique_molecules ( self , bond_tolerance = 0.4 ) -> List [ Molecule ]: \"\"\" Calculate a list of connected molecules which contain every site in the asymmetric_unit Populates the _symmetry_unique_molecules member, subsequent calls to this function will be a no-op. Args: bond_tolerance (float, optional): Bonding tolerance (bonded if d < cov_a + cov_b + bond_tolerance) Returns: List of all connected molecules in the asymmetric_unit of this crystal, i.e. the minimum list of connected molecules which contain all sites in the asymmetric unit. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit and the total number of atoms will be equal to the number of atoms in the asymmetric_unit \"\"\" if hasattr ( self , \"_symmetry_unique_molecules\" ): return getattr ( self , \"_symmetry_unique_molecules\" ) uc_molecules = self . unit_cell_molecules () asym_atoms = np . zeros ( len ( self . asymmetric_unit ), dtype = bool ) molecules = [] # sort by % of identity symop def order ( x ): return len ( np . where ( x . asym_symops == 16484 )[ 0 ]) / len ( x ) for i , mol in enumerate ( sorted ( uc_molecules , key = order , reverse = True )): asym_atoms_in_g = np . unique ( mol . properties [ \"asymmetric_unit_atoms\" ]) if np . all ( asym_atoms [ asym_atoms_in_g ]): continue asym_atoms [ asym_atoms_in_g ] = True molecules . append ( mol ) if np . all ( asym_atoms ): break LOG . debug ( \" %d symmetry unique molecules\" , len ( molecules )) setattr ( self , \"_symmetry_unique_molecules\" , molecules ) for i , mol in enumerate ( molecules ): mol . properties [ \"asym_mol_idx\" ] = i ak = \"asymmetric_unit_atoms\" for mol in self . unit_cell_molecules (): if \"asym_mol_idx\" in mol . properties : continue else : for asym_mol in molecules : if np . all ( mol . properties [ ak ] == asym_mol . properties [ ak ]): mol . properties [ \"asym_mol_idx\" ] = asym_mol . properties [ \"asym_mol_idx\" ] break else : LOG . warn ( \"No equivalent asymmetric unit molecule found!? -- this should not happen!\" ) return molecules","title":"symmetry_unique_molecules()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cartesian","text":"Convert coordinates (row major) from fractional to cartesian coordinates. Parameters: Name Type Description Default coords np.ndarray (N, 3) array of positions assumed to be in fractional coordinates required Returns: Type Description ndarray (N, 3) array of positions transformed to cartesian (orthogonal) coordinates by the unit cell of this crystal. Source code in chmpy/crystal/crystal.py 104 105 106 107 108 109 110 111 112 113 114 115 def to_cartesian ( self , coords ) -> np . ndarray : \"\"\" Convert coordinates (row major) from fractional to cartesian coordinates. Arguments: coords (np.ndarray): (N, 3) array of positions assumed to be in fractional coordinates Returns: (N, 3) array of positions transformed to cartesian (orthogonal) coordinates by the unit cell of this crystal. \"\"\" return self . unit_cell . to_cartesian ( coords )","title":"to_cartesian()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_data","text":"Convert this crystal structure to cif data dict Source code in chmpy/crystal/crystal.py 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 def to_cif_data ( self , data_block_name = None ) -> dict : \"Convert this crystal structure to cif data dict\" version = \"1.0a1\" if data_block_name is None : data_block_name = self . titl if \"cif_data\" in self . properties : cif_data = self . properties [ \"cif_data\" ] else : cif_data = { \"audit_creation_method\" : f \"chmpy python library version { version } \" , \"symmetry_equiv_pos_site_id\" : list ( range ( 1 , len ( self . symmetry_operations ) + 1 ) ), \"symmetry_equiv_pos_as_xyz\" : [ str ( x ) for x in self . symmetry_operations ], \"cell_length_a\" : self . unit_cell . a , \"cell_length_b\" : self . unit_cell . b , \"cell_length_c\" : self . unit_cell . c , \"cell_angle_alpha\" : self . unit_cell . alpha_deg , \"cell_angle_beta\" : self . unit_cell . beta_deg , \"cell_angle_gamma\" : self . unit_cell . gamma_deg , \"atom_site_label\" : self . asymmetric_unit . labels , \"atom_site_type_symbol\" : [ x . symbol for x in self . asymmetric_unit . elements ], \"atom_site_fract_x\" : self . asymmetric_unit . positions [:, 0 ], \"atom_site_fract_y\" : self . asymmetric_unit . positions [:, 1 ], \"atom_site_fract_z\" : self . asymmetric_unit . positions [:, 2 ], \"atom_site_occupancy\" : self . asymmetric_unit . properties . get ( \"occupation\" , np . ones ( len ( self . asymmetric_unit )) ), } return { data_block_name : cif_data }","title":"to_cif_data()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_file","text":"save this crystal to a CIF formatted file Source code in chmpy/crystal/crystal.py 1540 1541 1542 1543 def to_cif_file ( self , filename , ** kwargs ): \"save this crystal to a CIF formatted file\" cif_data = self . to_cif_data ( ** kwargs ) return Cif ( cif_data ) . to_file ( filename )","title":"to_cif_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_string","text":"save this crystal to a CIF formatted string Source code in chmpy/crystal/crystal.py 1545 1546 1547 1548 def to_cif_string ( self , ** kwargs ): \"save this crystal to a CIF formatted string\" cif_data = self . to_cif_data ( ** kwargs ) return Cif ( cif_data ) . to_string ()","title":"to_cif_string()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_fractional","text":"Convert coordinates (row major) from cartesian to fractional coordinates. Parameters: Name Type Description Default coords np.ndarray (N, 3) array of positions assumed to be in cartesian (orthogonal) coordinates required Returns: Type Description ndarray (N, 3) array of positions transformed to fractional coordinates by the unit cell of this crystal. Source code in chmpy/crystal/crystal.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def to_fractional ( self , coords ) -> np . ndarray : \"\"\" Convert coordinates (row major) from cartesian to fractional coordinates. Args: coords (np.ndarray): (N, 3) array of positions assumed to be in cartesian (orthogonal) coordinates Returns: (N, 3) array of positions transformed to fractional coordinates by the unit cell of this crystal. \"\"\" return self . unit_cell . to_fractional ( coords )","title":"to_fractional()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_poscar_file","text":"save this crystal to a VASP POSCAR formatted file Source code in chmpy/crystal/crystal.py 1556 1557 1558 def to_poscar_file ( self , filename , ** kwargs ): \"save this crystal to a VASP POSCAR formatted file\" Path ( filename ) . write_text ( self . to_poscar_string ( ** kwargs ))","title":"to_poscar_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_poscar_string","text":"save this crystal to a VASP POSCAR formatted string Source code in chmpy/crystal/crystal.py 1550 1551 1552 1553 1554 def to_poscar_string ( self , ** kwargs ): \"save this crystal to a VASP POSCAR formatted string\" from chmpy.ext.vasp import poscar_string return poscar_string ( self , name = self . titl )","title":"to_poscar_string()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_shelx_file","text":"Write this crystal structure as a shelx .res formatted file Source code in chmpy/crystal/crystal.py 1560 1561 1562 def to_shelx_file ( self , filename ): \"\"\"Write this crystal structure as a shelx .res formatted file\"\"\" Path ( filename ) . write_text ( self . to_shelx_string ())","title":"to_shelx_file()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_shelx_string","text":"Represent this crystal structure as a shelx .res formatted string Source code in chmpy/crystal/crystal.py 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 def to_shelx_string ( self , titl = None ): \"\"\"Represent this crystal structure as a shelx .res formatted string\"\"\" from chmpy.fmt.shelx import to_res_contents sfac = list ( np . unique ( self . site_atoms )) atom_sfac = [ sfac . index ( x ) + 1 for x in self . site_atoms ] shelx_data = { \"TITL\" : self . titl if titl is None else titl , \"CELL\" : self . unit_cell . parameters , \"SFAC\" : [ Element [ x ] . symbol for x in sfac ], \"SYMM\" : [ str ( s ) for s in self . space_group . reduced_symmetry_operations () if not s . is_identity () ], \"LATT\" : self . space_group . latt , \"ATOM\" : [ \" {:3} {:3} {: 20.12f} {: 20.12f} {: 20.12f} \" . format ( l , s , * pos ) for l , s , pos in zip ( self . asymmetric_unit . labels , atom_sfac , self . site_positions ) ], } return to_res_contents ( shelx_data )","title":"to_shelx_string()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_translational_symmetry","text":"Create a supercell of this crystal in space group P 1. Parameters: Name Type Description Default supercell Tuple[int] size of the supercell to be created (1, 1, 1) Returns: Type Description Crystal Crystal object of a supercell in space group P 1 Source code in chmpy/crystal/crystal.py 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 def to_translational_symmetry ( self , supercell = ( 1 , 1 , 1 )) -> \"Crystal\" : \"\"\" Create a supercell of this crystal in space group P 1. Args: supercell (Tuple[int]): size of the supercell to be created Returns: Crystal object of a supercell in space group P 1 \"\"\" from itertools import product hmax , kmax , lmax = supercell a , b , c = self . unit_cell . lengths sc = UnitCell . from_lengths_and_angles ( ( hmax * a , kmax * b , lmax * c ), self . unit_cell . angles ) h = np . arange ( hmax ) k = np . arange ( kmax ) l = np . arange ( lmax ) molecules = [] for q , r , s in product ( h , k , l ): for uc_mol in self . unit_cell_molecules (): molecules . append ( uc_mol . translated ( np . asarray ([ q , r , s ]) @ self . unit_cell . lattice ) ) asym_pos = np . vstack ([ x . positions for x in molecules ]) asym_nums = np . hstack ([ x . atomic_numbers for x in molecules ]) asymmetric_unit = AsymmetricUnit ( [ Element [ x ] for x in asym_nums ], sc . to_fractional ( asym_pos ) ) new_titl = self . titl + \"_P1_supercell_ {} _ {} _ {} \" . format ( * supercell ) new_crystal = Crystal ( sc , SpaceGroup ( 1 ), asymmetric_unit , titl = new_titl ) return new_crystal","title":"to_translational_symmetry()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_atoms","text":"Generate all atoms in the unit cell (i.e. with fractional coordinates in [0, 1]) along with associated information about symmetry operations, occupation, elements related asymmetric_unit atom etc. Will merge atom sites within tolerance of each other, and sum their occupation numbers. A warning will be logged if any atom site in the unit cell has > 1.0 occupancy after this. Sets the _unit_cell_atom_dict member as this is an expensive operation and is worth caching the result. Subsequent calls to this function will be a no-op. Parameters: Name Type Description Default tolerance float Minimum separation of sites in the unit cell, below which atoms/sites will be merged and their (partial) occupations added. 0.01 Returns: Type Description dict A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom : corresponding asymmetric unit atom indices for all sites . frac_pos : ( N , 3 ) array of fractional positions for all sites . cart_pos : ( N , 3 ) array of cartesian positions for all sites . element : ( N ) array of atomic numbers for all sites . symop : ( N ) array of indices corresponding to the generator symmetry operation for each site . label : ( N ) array of string labels corresponding to each site occupation : ( N ) array of occupation numbers for each site . Will warn if any of these are greater than 1.0 Source code in chmpy/crystal/crystal.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def unit_cell_atoms ( self , tolerance = 1e-2 ) -> dict : \"\"\" Generate all atoms in the unit cell (i.e. with fractional coordinates in [0, 1]) along with associated information about symmetry operations, occupation, elements related asymmetric_unit atom etc. Will merge atom sites within tolerance of each other, and sum their occupation numbers. A warning will be logged if any atom site in the unit cell has > 1.0 occupancy after this. Sets the `_unit_cell_atom_dict` member as this is an expensive operation and is worth caching the result. Subsequent calls to this function will be a no-op. Arguments: tolerance (float, optional): Minimum separation of sites in the unit cell, below which atoms/sites will be merged and their (partial) occupations added. Returns: A dictionary of arrays associated with all sites contained in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will warn if any of these are greater than 1.0 \"\"\" if hasattr ( self , \"_unit_cell_atom_dict\" ): return getattr ( self , \"_unit_cell_atom_dict\" ) pos = self . site_positions atoms = self . site_atoms natom = self . nsites nsymops = len ( self . space_group . symmetry_operations ) occupation = np . tile ( self . asymmetric_unit . properties . get ( \"occupation\" , np . ones ( natom )), nsymops ) labels = np . tile ( self . asymmetric_unit . labels , nsymops ) uc_nums = np . tile ( atoms , nsymops ) asym = np . arange ( len ( uc_nums )) % natom sym , uc_pos = self . space_group . apply_all_symops ( pos ) translated = np . fmod ( uc_pos + 7.0 , 1 ) tree = KDTree ( translated ) dist = tree . sparse_distance_matrix ( tree , max_distance = tolerance ) mask = np . ones ( len ( uc_pos ), dtype = bool ) # because crystals may have partially occupied sites # on special positions, we need to merge some sites # expected_natoms = np.sum(occupation) for ( i , j ), _ in dist . items (): if not ( i < j ): continue occupation [ i ] += occupation [ j ] mask [ j ] = False occupation = occupation [ mask ] if np . any ( occupation > 1.0 ): LOG . debug ( \"Some unit cell site occupations are > 1.0\" ) setattr ( self , \"_unit_cell_atom_dict\" , { \"asym_atom\" : asym [ mask ], \"frac_pos\" : translated [ mask ], \"element\" : uc_nums [ mask ], \"symop\" : sym [ mask ], \"label\" : labels [ mask ], \"occupation\" : occupation , \"cart_pos\" : self . to_cartesian ( translated [ mask ]), }, ) return getattr ( self , \"_unit_cell_atom_dict\" )","title":"unit_cell_atoms()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_connectivity","text":"Periodic connectiviy for the unit cell, populates _uc_graph with a networkx.Graph object, where nodes are indices into the _unit_cell_atom_dict arrays and the edges contain the translation (cell) for the image of the corresponding unit cell atom with the higher index to be bonded to the lower Bonding is determined by interatomic distances being less than the sum of covalent radii for the sites plus the tolerance (provided as a parameter) Parameters: Name Type Description Default tolerance float Bonding tolerance (bonded if d < cov_a + cov_b + tolerance) 0.4 neighbouring_cells int Number of neighbouring cells in which to look for bonded atoms. We start at the (0, 0, 0) cell, so a value of 1 will look in the (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells. 1 is typically sufficient for organic systems. 1 Returns: Type Description Tuple A tuple of (sparse_matrix in dict of keys format, dict) the (i, j) value in this matrix is the bond length from i,j the (i, j) value in the dict is the cell translation on j which bonds these two sites Source code in chmpy/crystal/crystal.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def unit_cell_connectivity ( self , tolerance = 0.4 , neighbouring_cells = 1 ) -> Tuple : \"\"\" Periodic connectiviy for the unit cell, populates _uc_graph with a networkx.Graph object, where nodes are indices into the _unit_cell_atom_dict arrays and the edges contain the translation (cell) for the image of the corresponding unit cell atom with the higher index to be bonded to the lower Bonding is determined by interatomic distances being less than the sum of covalent radii for the sites plus the tolerance (provided as a parameter) Arguments: tolerance (float, optional): Bonding tolerance (bonded if d < cov_a + cov_b + tolerance) neighbouring_cells (int, optional): Number of neighbouring cells in which to look for bonded atoms. We start at the (0, 0, 0) cell, so a value of 1 will look in the (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells. 1 is typically sufficient for organic systems. Returns: A tuple of (sparse_matrix in dict of keys format, dict) the (i, j) value in this matrix is the bond length from i,j the (i, j) value in the dict is the cell translation on j which bonds these two sites \"\"\" if hasattr ( self , \"_uc_graph\" ): return getattr ( self , \"_uc_graph\" ) slab = self . slab ( bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) n_uc = slab [ \"n_uc\" ] uc_pos = slab [ \"frac_pos\" ][: n_uc ] uc_nums = slab [ \"element\" ][: n_uc ] neighbour_pos = slab [ \"frac_pos\" ][ n_uc :] cart_uc_pos = self . to_cartesian ( uc_pos ) unique_elements = { x : Element . from_atomic_number ( x ) for x in np . unique ( uc_nums )} # first establish all connections in the unit cell covalent_radii = np . array ([ unique_elements [ x ] . cov for x in uc_nums ]) max_cov = np . max ( covalent_radii ) # TODO this needs to be sped up for large cells, tends to slow for > 1000 atoms # and the space storage will become a problem tree = KDTree ( cart_uc_pos ) dist = tree . sparse_distance_matrix ( tree , max_distance = 2 * max_cov + tolerance ) uc_edges = [] for ( i , j ), d in dist . items (): if not ( i < j ): continue if d > 1e-3 and d < ( covalent_radii [ i ] + covalent_radii [ j ] + tolerance ): uc_edges . append (( i , j , d , ( 0 , 0 , 0 ))) cart_neighbour_pos = self . unit_cell . to_cartesian ( neighbour_pos ) tree2 = KDTree ( cart_neighbour_pos ) dist = tree . sparse_distance_matrix ( tree2 , max_distance = 2 * max_cov + tolerance ) # could be sped up if done outside python cells = slab [ \"cell\" ][ n_uc :] for ( uc_atom , neighbour_atom ), d in dist . items (): uc_idx = neighbour_atom % n_uc if not ( uc_atom < uc_idx ): continue if d > 1e-3 and d < ( covalent_radii [ uc_atom ] + covalent_radii [ uc_idx ] + tolerance ): cell = cells [ neighbour_atom ] uc_edges . append (( uc_atom , uc_idx , d , tuple ( cell ))) properties = {} uc_graph = dok_matrix (( n_uc , n_uc )) for i , j , d , cell in uc_edges : uc_graph [ i , j ] = d properties [( i , j )] = cell setattr ( self , \"_uc_graph\" , ( uc_graph , properties )) return getattr ( self , \"_uc_graph\" )","title":"unit_cell_connectivity()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_molecules","text":"Calculate the molecules for all sites in the unit cell, where the number of molecules will be equal to number of symmetry unique molecules times number of symmetry operations. Returns: Type Description List[chmpy.core.molecule.Molecule] A list of all connected molecules in this crystal, which when translated by the unit cell would produce the full crystal. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit * num_symm_operations Source code in chmpy/crystal/crystal.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def unit_cell_molecules ( self ) -> List [ Molecule ]: \"\"\" Calculate the molecules for all sites in the unit cell, where the number of molecules will be equal to number of symmetry unique molecules times number of symmetry operations. Returns: A list of all connected molecules in this crystal, which when translated by the unit cell would produce the full crystal. If the asymmetric is molecular, the list will be of length num_molecules_in_asymmetric_unit * num_symm_operations \"\"\" if hasattr ( self , \"_unit_cell_molecules\" ): return getattr ( self , \"_unit_cell_molecules\" ) uc_graph , edge_cells = self . unit_cell_connectivity () n_uc_mols , uc_mols = csgraph . connected_components ( csgraph = uc_graph , directed = False , return_labels = True ) uc_dict = getattr ( self , \"_unit_cell_atom_dict\" ) uc_frac = uc_dict [ \"frac_pos\" ] uc_elements = uc_dict [ \"element\" ] uc_asym = uc_dict [ \"asym_atom\" ] uc_symop = uc_dict [ \"symop\" ] molecules = [] n_uc = len ( uc_frac ) LOG . debug ( \" %d molecules in unit cell\" , n_uc_mols ) for i in range ( n_uc_mols ): nodes = np . where ( uc_mols == i )[ 0 ] root = nodes [ 0 ] elements = uc_elements [ nodes ] shifts = np . zeros (( n_uc , 3 )) ordered , pred = csgraph . breadth_first_order ( csgraph = uc_graph , i_start = root , directed = False ) for j in ordered [ 1 :]: i = pred [ j ] if j < i : shifts [ j , :] = shifts [ i , :] - edge_cells [( j , i )] else : shifts [ j , :] = shifts [ i , :] + edge_cells [( i , j )] positions = self . to_cartesian (( uc_frac + shifts )[ nodes ]) asym_atoms = uc_asym [ nodes ] reorder = np . argsort ( asym_atoms ) asym_atoms = asym_atoms [ reorder ] mol = Molecule . from_arrays ( elements = elements [ reorder ], positions = positions [ reorder ], guess_bonds = True , unit_cell_atoms = np . array ( nodes )[ reorder ], asymmetric_unit_atoms = asym_atoms , asymmetric_unit_labels = self . asymmetric_unit . labels [ asym_atoms ], generator_symop = uc_symop [ np . asarray ( nodes )[ reorder ]], ) centroid = mol . center_of_mass frac_centroid = self . to_fractional ( centroid ) new_centroid = np . fmod ( frac_centroid + 7.0 , 1.0 ) translation = self . to_cartesian ( new_centroid - frac_centroid ) mol . translate ( translation ) molecules . append ( mol ) setattr ( self , \"_unit_cell_molecules\" , molecules ) return molecules","title":"unit_cell_molecules()"},{"location":"API/crystal/crystal/#chmpy.crystal.crystal.Crystal.void_surface","text":"Calculate void surface based on promolecule electron density for the unit cell of this crystal Parameters: Name Type Description Default kwargs Keyword arguments used in the evaluation of the surface. Options are: isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. {} Returns: Type Description Trimesh the mesh representing the promolecule density void isosurface Source code in chmpy/crystal/crystal.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def void_surface ( self , * args , ** kwargs ) -> Trimesh : \"\"\" Calculate void surface based on promolecule electron density for the unit cell of this crystal Args: kwargs: Keyword arguments used in the evaluation of the surface. Options are: ``` isovalue (float, optional): level set value for the isosurface (default=0.002) in au. separation (float, optional): separation between density grid used in the surface calculation (default 0.2) in Angstroms. ``` Returns: the mesh representing the promolecule density void isosurface \"\"\" from chmpy import PromoleculeDensity import trimesh from chmpy.mc import marching_cubes vertex_color = kwargs . get ( \"color\" , None ) atoms = self . slab ( bounds = (( - 1 , - 1 , - 1 ), ( 1 , 1 , 1 ))) density = PromoleculeDensity (( atoms [ \"element\" ], atoms [ \"cart_pos\" ])) sep = kwargs . get ( \"separation\" , kwargs . get ( \"resolution\" , 0.5 )) isovalue = kwargs . get ( \"isovalue\" , 3e-4 ) grid_type = kwargs . get ( \"grid_type\" , \"uc\" ) if grid_type == \"uc\" : seps = sep / np . array ( self . unit_cell . lengths ) x_grid = np . arange ( 0 , 1.0 , seps [ 0 ], dtype = np . float32 ) y_grid = np . arange ( 0 , 1.0 , seps [ 1 ], dtype = np . float32 ) z_grid = np . arange ( 0 , 1.0 , seps [ 2 ], dtype = np . float32 ) x , y , z = np . meshgrid ( x_grid , y_grid , z_grid ) shape = x . shape pts = np . c_ [ x . ravel (), y . ravel (), z . ravel ()] pts = pts . astype ( np . float32 ) pts = self . to_cartesian ( pts ) elif grid_type == \"box\" : (( x0 , y0 , z0 ), ( x1 , y1 , z1 )) = kwargs . get ( \"box_corners\" , (( 0.0 , 0.0 , 0.0 ), ( 5.0 , 5.0 , 5.0 )) ) x , y , z = np . mgrid [ x0 : x1 : sep , y0 : y1 : sep , z0 : z1 : sep ] pts = np . c_ [ x . ravel (), y . ravel (), z . ravel ()] pts = pts . astype ( np . float32 ) shape = x . shape seps = ( sep , sep , sep ) else : raise NotImplementedError ( \"Only uc grid supported currently\" ) tree = KDTree ( atoms [ \"cart_pos\" ]) distances , _ = tree . query ( pts ) values = np . ones ( pts . shape [ 0 ], dtype = np . float32 ) mask = distances > 1.0 # minimum bigger than 1 angstrom rho = density . rho ( pts [ mask ]) values [ mask ] = rho values = values . reshape ( shape ) verts , faces , normals , _ = marching_cubes ( values , isovalue , spacing = seps , gradient_direction = \"ascent\" ) if grid_type == \"uc\" : verts = self . to_cartesian ( np . c_ [ verts [:, 1 ], verts [:, 0 ], verts [:, 2 ]]) mesh = trimesh . Trimesh ( vertices = verts , faces = faces , normals = normals ) if kwargs . get ( \"subdivide\" , False ): for _ in range ( int ( kwargs . get ( \"subdivide\" , False ))): mesh = mesh . subdivide () if vertex_color == \"esp\" : from chmpy.util.color import property_to_color asym_charges = self . asymmetric_unit_partial_charges () mol = Molecule . from_arrays ( atoms [ \"element\" ], atoms [ \"cart_pos\" ]) partial_charges = np . empty ( len ( mol ), dtype = np . float32 ) partial_charges = asym_charges [ atoms [ \"asym_atom\" ]] mol . _partial_charges = partial_charges prop = mol . electrostatic_potential ( mesh . vertices ) mesh . visual . vertex_colors = property_to_color ( prop , cmap = kwargs . get ( \"cmap\" , \"esp\" ) ) return mesh","title":"void_surface()"},{"location":"API/crystal/space_group/","text":"SpaceGroup Represent a crystallographic space group, including all necessary symmetry operations in fractional coordinates, the international tables number from 1-230, and the international tables symbol. Attributes: Name Type Description symbol str The international tables short space group symbol full_symbol str The full international tables space group symbol choice str The space group choice (if applicable) centering str The space group centering (if applicable) schoenflies str The Schoenflies space group symbol centrosymmetric bool Whether or not the space group is centrosymmetric symmetry_operations List[SymmetryOperation] List of symmetry operations making up this space group cif_section: str property readonly Representation of the SpaceGroup in CIF files crystal_system: str property readonly The crystal system of the space group e.g. triclinic, monoclinic etc. latt: int property readonly The SHELX LATT number associated with this space group. Returns a negative if there is no inversion. Options are 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C Examples: 1 2 3 4 5 6 7 8 9 10 >>> P1 = SpaceGroup ( 1 ) >>> P21c = SpaceGroup ( 14 ) >>> I41 = SpaceGroup ( 14 ) >>> R3bar = SpaceGroup ( 148 ) >>> P1 . latt - 1 >>> P21c . latt 1 >>> R3bar . latt 3 Returns: Type Description int int: the SHELX LATT number of this space group lattice_type: str property readonly the lattice type of this space group e.g. rhombohedral, hexagonal etc. laue_class: str property readonly the Laue class of the point group associated with this space group pg property readonly alias for self.point_group point_group property readonly the point group of this space group sym: str property readonly alias for self.symbol symbol_unicode: str property readonly the space group symbol with unicode subscripts symops property readonly alias for self.symmetry_operations apply_all_symops ( self , coordinates ) For a given set of coordinates, apply all symmetry operations in this space group, yielding a set subject to only translational symmetry (i.e. a unit cell). Assumes the input coordinates are fractional. Parameters: Name Type Description Default coordinates ndarray (N, 3) set of fractional coordinates required Returns: Type Description Tuple[np.ndarray, np.ndarray] a (MxN) array of generator symop integers and an (MxN, 3) array of coordinates where M is the number of symmetry operations in this space group. Source code in chmpy/crystal/space_group.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def apply_all_symops ( self , coordinates : np . ndarray ): \"\"\" For a given set of coordinates, apply all symmetry operations in this space group, yielding a set subject to only translational symmetry (i.e. a unit cell). Assumes the input coordinates are fractional. Args: coordinates (np.ndarray): (N, 3) set of fractional coordinates Returns: Tuple[np.ndarray, np.ndarray]: a (MxN) array of generator symop integers and an (MxN, 3) array of coordinates where M is the number of symmetry operations in this space group. \"\"\" nsites = len ( coordinates ) transformed = np . empty (( nsites * len ( self ), 3 )) generator_symop = np . empty ( nsites * len ( self ), dtype = np . int32 ) # make sure we do the unit symop first unity = 0 for i , s in enumerate ( self . symmetry_operations ): if s . integer_code == 16484 : unity = i break transformed [ 0 : nsites ] = coordinates generator_symop [ 0 : nsites ] = 16484 other_symops = ( self . symmetry_operations [: unity ] + self . symmetry_operations [ unity + 1 :] ) for i , s in enumerate ( other_symops , start = 1 ): transformed [ i * nsites : ( i + 1 ) * nsites ] = s ( coordinates ) generator_symop [ i * nsites : ( i + 1 ) * nsites ] = s . integer_code return generator_symop , transformed from_symmetry_operations ( symops , expand_latt = None ) classmethod Find a matching spacegroup for a given set of symmetry operations, optionally treating them as a reduced set of symmetry operations and expanding them based on the lattice type. Parameters: Name Type Description Default symops List[SymmetryOperation] a reduced or full list of symmetry operations required expand_latt int the SHELX LATT number to expand this list of symmetry operations None Returns: Type Description SpaceGroup the matching SpaceGroup for the provided symmetry operations and LATT Source code in chmpy/crystal/space_group.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @classmethod def from_symmetry_operations ( cls , symops , expand_latt = None ): \"\"\" Find a matching spacegroup for a given set of symmetry operations, optionally treating them as a reduced set of symmetry operations and expanding them based on the lattice type. Args: symops (List[SymmetryOperation]): a reduced or full list of symmetry operations expand_latt (int, optional): the SHELX LATT number to expand this list of symmetry operations Returns: SpaceGroup: the matching `SpaceGroup` for the provided symmetry operations and LATT \"\"\" if expand_latt is not None : if not - 8 < expand_latt < 8 : raise ValueError ( \"expand_latt must be between [-7, 7]\" ) symops = expanded_symmetry_list ( symops , expand_latt ) encoded = tuple ( sorted ( s . integer_code for s in symops )) if encoded not in SG_FROM_SYMOPS : raise ValueError ( \"Could not find matching spacegroup for \" \"the following symops: \\n {} \" . format ( \" \\n \" . join ( str ( s ) for s in sorted ( symops )) ) ) else : sgdata = SG_FROM_SYMOPS [ encoded ] return SpaceGroup ( sgdata . number , choice = sgdata . choice ) has_hexagonal_rhombohedral_choices ( self ) returns true if this space group could be represented as hexagonal or rhombohedral Source code in chmpy/crystal/space_group.py 275 276 277 def has_hexagonal_rhombohedral_choices ( self ) -> bool : \"returns true if this space group could be represented as hexagonal or rhombohedral\" return self . international_tables_number in ( 146 , 148 , 155 , 160 , 161 , 166 , 167 ) ordered_symmetry_operations ( self ) The symmetry operations of this space group in order (with identiy first) Source code in chmpy/crystal/space_group.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def ordered_symmetry_operations ( self ): \"The symmetry operations of this space group in order (with identiy first)\" # make sure we do the unit symop first unity = 0 for i , s in enumerate ( self . symmetry_operations ): if s . is_identity (): unity = i break else : raise ValueError ( \"Could not find identity symmetry_operation -- invalide space group\" ) other_symops = ( self . symmetry_operations [: unity ] + self . symmetry_operations [ unity + 1 :] ) return [ self . symmetry_operations [ unity ]] + other_symops reduced_symmetry_operations ( self ) returns a reduced list of symmetry operations Source code in chmpy/crystal/space_group.py 271 272 273 def reduced_symmetry_operations ( self ): \"returns a reduced list of symmetry operations\" return reduced_symmetry_list ( self . symmetry_operations , self . latt )","title":"Space Groups"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group","text":"","title":"chmpy.crystal.space_group"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup","text":"Represent a crystallographic space group, including all necessary symmetry operations in fractional coordinates, the international tables number from 1-230, and the international tables symbol. Attributes: Name Type Description symbol str The international tables short space group symbol full_symbol str The full international tables space group symbol choice str The space group choice (if applicable) centering str The space group centering (if applicable) schoenflies str The Schoenflies space group symbol centrosymmetric bool Whether or not the space group is centrosymmetric symmetry_operations List[SymmetryOperation] List of symmetry operations making up this space group","title":"SpaceGroup"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.cif_section","text":"Representation of the SpaceGroup in CIF files","title":"cif_section"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.crystal_system","text":"The crystal system of the space group e.g. triclinic, monoclinic etc.","title":"crystal_system"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.latt","text":"The SHELX LATT number associated with this space group. Returns a negative if there is no inversion. Options are 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C Examples: 1 2 3 4 5 6 7 8 9 10 >>> P1 = SpaceGroup ( 1 ) >>> P21c = SpaceGroup ( 14 ) >>> I41 = SpaceGroup ( 14 ) >>> R3bar = SpaceGroup ( 148 ) >>> P1 . latt - 1 >>> P21c . latt 1 >>> R3bar . latt 3 Returns: Type Description int int: the SHELX LATT number of this space group","title":"latt"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.lattice_type","text":"the lattice type of this space group e.g. rhombohedral, hexagonal etc.","title":"lattice_type"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.laue_class","text":"the Laue class of the point group associated with this space group","title":"laue_class"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.pg","text":"alias for self.point_group","title":"pg"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.point_group","text":"the point group of this space group","title":"point_group"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.sym","text":"alias for self.symbol","title":"sym"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.symbol_unicode","text":"the space group symbol with unicode subscripts","title":"symbol_unicode"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.symops","text":"alias for self.symmetry_operations","title":"symops"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.apply_all_symops","text":"For a given set of coordinates, apply all symmetry operations in this space group, yielding a set subject to only translational symmetry (i.e. a unit cell). Assumes the input coordinates are fractional. Parameters: Name Type Description Default coordinates ndarray (N, 3) set of fractional coordinates required Returns: Type Description Tuple[np.ndarray, np.ndarray] a (MxN) array of generator symop integers and an (MxN, 3) array of coordinates where M is the number of symmetry operations in this space group. Source code in chmpy/crystal/space_group.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def apply_all_symops ( self , coordinates : np . ndarray ): \"\"\" For a given set of coordinates, apply all symmetry operations in this space group, yielding a set subject to only translational symmetry (i.e. a unit cell). Assumes the input coordinates are fractional. Args: coordinates (np.ndarray): (N, 3) set of fractional coordinates Returns: Tuple[np.ndarray, np.ndarray]: a (MxN) array of generator symop integers and an (MxN, 3) array of coordinates where M is the number of symmetry operations in this space group. \"\"\" nsites = len ( coordinates ) transformed = np . empty (( nsites * len ( self ), 3 )) generator_symop = np . empty ( nsites * len ( self ), dtype = np . int32 ) # make sure we do the unit symop first unity = 0 for i , s in enumerate ( self . symmetry_operations ): if s . integer_code == 16484 : unity = i break transformed [ 0 : nsites ] = coordinates generator_symop [ 0 : nsites ] = 16484 other_symops = ( self . symmetry_operations [: unity ] + self . symmetry_operations [ unity + 1 :] ) for i , s in enumerate ( other_symops , start = 1 ): transformed [ i * nsites : ( i + 1 ) * nsites ] = s ( coordinates ) generator_symop [ i * nsites : ( i + 1 ) * nsites ] = s . integer_code return generator_symop , transformed","title":"apply_all_symops()"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.from_symmetry_operations","text":"Find a matching spacegroup for a given set of symmetry operations, optionally treating them as a reduced set of symmetry operations and expanding them based on the lattice type. Parameters: Name Type Description Default symops List[SymmetryOperation] a reduced or full list of symmetry operations required expand_latt int the SHELX LATT number to expand this list of symmetry operations None Returns: Type Description SpaceGroup the matching SpaceGroup for the provided symmetry operations and LATT Source code in chmpy/crystal/space_group.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @classmethod def from_symmetry_operations ( cls , symops , expand_latt = None ): \"\"\" Find a matching spacegroup for a given set of symmetry operations, optionally treating them as a reduced set of symmetry operations and expanding them based on the lattice type. Args: symops (List[SymmetryOperation]): a reduced or full list of symmetry operations expand_latt (int, optional): the SHELX LATT number to expand this list of symmetry operations Returns: SpaceGroup: the matching `SpaceGroup` for the provided symmetry operations and LATT \"\"\" if expand_latt is not None : if not - 8 < expand_latt < 8 : raise ValueError ( \"expand_latt must be between [-7, 7]\" ) symops = expanded_symmetry_list ( symops , expand_latt ) encoded = tuple ( sorted ( s . integer_code for s in symops )) if encoded not in SG_FROM_SYMOPS : raise ValueError ( \"Could not find matching spacegroup for \" \"the following symops: \\n {} \" . format ( \" \\n \" . join ( str ( s ) for s in sorted ( symops )) ) ) else : sgdata = SG_FROM_SYMOPS [ encoded ] return SpaceGroup ( sgdata . number , choice = sgdata . choice )","title":"from_symmetry_operations()"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.has_hexagonal_rhombohedral_choices","text":"returns true if this space group could be represented as hexagonal or rhombohedral Source code in chmpy/crystal/space_group.py 275 276 277 def has_hexagonal_rhombohedral_choices ( self ) -> bool : \"returns true if this space group could be represented as hexagonal or rhombohedral\" return self . international_tables_number in ( 146 , 148 , 155 , 160 , 161 , 166 , 167 )","title":"has_hexagonal_rhombohedral_choices()"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.ordered_symmetry_operations","text":"The symmetry operations of this space group in order (with identiy first) Source code in chmpy/crystal/space_group.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def ordered_symmetry_operations ( self ): \"The symmetry operations of this space group in order (with identiy first)\" # make sure we do the unit symop first unity = 0 for i , s in enumerate ( self . symmetry_operations ): if s . is_identity (): unity = i break else : raise ValueError ( \"Could not find identity symmetry_operation -- invalide space group\" ) other_symops = ( self . symmetry_operations [: unity ] + self . symmetry_operations [ unity + 1 :] ) return [ self . symmetry_operations [ unity ]] + other_symops","title":"ordered_symmetry_operations()"},{"location":"API/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.reduced_symmetry_operations","text":"returns a reduced list of symmetry operations Source code in chmpy/crystal/space_group.py 271 272 273 def reduced_symmetry_operations ( self ): \"returns a reduced list of symmetry operations\" return reduced_symmetry_list ( self . symmetry_operations , self . latt )","title":"reduced_symmetry_operations()"},{"location":"API/crystal/symmetry_operation/","text":"SymmetryOperation Class to represent a crystallographic symmetry operation, composed of a rotation and a translation. Attributes: Name Type Description rotation np.ndarray (3, 3) rotation matrix in fractional coordinates translation np.ndarray (3) translation vector in fractional coordinates cif_form: str property readonly Represent this SymmetryOperation in string form e.g. '+x,+y,+z' integer_code: int property readonly Represent this SymmetryOperation as a packed integer seitz_matrix: ndarray property readonly The Seitz matrix form of this SymmetryOperation __add__ ( self , value ) special Add a vector to this symmetry operation's translation vector. Returns: Type Description SymmetryOperation a copy of this symmetry operation under additional translation\" Source code in chmpy/crystal/symmetry_operation.py 254 255 256 257 258 259 260 261 def __add__ ( self , value : np . ndarray ): \"\"\" Add a vector to this symmetry operation's translation vector. Returns: SymmetryOperation: a copy of this symmetry operation under additional translation\" \"\"\" return SymmetryOperation ( self . rotation , self . translation + value ) __init__ ( self , rotation , translation ) special Construct a new symmetry operation from a rotation matrix and a translation vector Parameters: Name Type Description Default rotation np.ndarray (3, 3) rotation matrix required translation np.ndarray (3) translation vector required Returns: Type Description SymmetryOperation a new SymmetryOperation Source code in chmpy/crystal/symmetry_operation.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def __init__ ( self , rotation , translation ): \"\"\" Construct a new symmetry operation from a rotation matrix and a translation vector Arguments: rotation (np.ndarray): (3, 3) rotation matrix translation (np.ndarray): (3) translation vector Returns: SymmetryOperation: a new SymmetryOperation \"\"\" self . rotation = rotation self . translation = translation % 1 __sub__ ( self , value ) special Subtract a vector from this symmetry operation's translation. Returns: Type Description SymmetryOperation a copy of this symmetry operation under additional translation\" Source code in chmpy/crystal/symmetry_operation.py 263 264 265 266 267 268 269 270 def __sub__ ( self , value : np . ndarray ): \"\"\" Subtract a vector from this symmetry operation's translation. Returns: SymmetryOperation: a copy of this symmetry operation under additional translation\" \"\"\" return SymmetryOperation ( self . rotation , self . translation - value ) apply ( self , coordinates ) Apply this symmetry operation to a set of fractional coordinates. Parameters: Name Type Description Default coordinates ndarray (N,3) or (N,4) array of fractional coordinates or homogeneous fractional coordinates. required Returns: Type Description ndarray np.ndarray: (N, 3) array of transformed coordinates Source code in chmpy/crystal/symmetry_operation.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply this symmetry operation to a set of fractional coordinates. Args: coordinates (np.ndarray): (N,3) or (N,4) array of fractional coordinates or homogeneous fractional coordinates. Returns: np.ndarray: (N, 3) array of transformed coordinates \"\"\" if coordinates . shape [ 1 ] == 4 : return np . dot ( coordinates , self . seitz_matrix . T ) else : return np . dot ( coordinates , self . rotation . T ) + self . translation from_integer_code ( code ) classmethod Alternative constructor from an integer-encoded symmetry operation e.g. 16484 See also the encode_symm_int , decode_symm_int methods. Parameters: Name Type Description Default code int integer-encoded symmetry operation required Returns: Type Description SymmetryOperation a new symmetry operation from the provided integer code Source code in chmpy/crystal/symmetry_operation.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @classmethod def from_integer_code ( cls , code : int ): \"\"\" Alternative constructor from an integer-encoded symmetry operation e.g. 16484 See also the `encode_symm_int`, `decode_symm_int` methods. Args: code (int): integer-encoded symmetry operation Returns: SymmetryOperation: a new symmetry operation from the provided integer code \"\"\" rot , trans = decode_symm_int ( code ) s = SymmetryOperation ( rot , trans ) setattr ( s , \"_integer_code\" , code ) return s from_string_code ( code ) classmethod Alternative constructor from a string encoded symmetry operation e.g. '+x,+y,+z'. See also the encode_symm_str , decode_symm_str methods. Parameters: Name Type Description Default code str string-encoded symmetry operation required Returns: Type Description SymmetryOperation a new symmetry operation from the provided string code Source code in chmpy/crystal/symmetry_operation.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @classmethod def from_string_code ( cls , code : str ): \"\"\" Alternative constructor from a string encoded symmetry operation e.g. '+x,+y,+z'. See also the `encode_symm_str`, `decode_symm_str` methods. Args: code (str): string-encoded symmetry operation Returns: SymmetryOperation: a new symmetry operation from the provided string code \"\"\" rot , trans = decode_symm_str ( code ) s = SymmetryOperation ( rot , trans ) setattr ( s , \"_string_code\" , code ) return s identity () classmethod Alternative constructor for the the identity symop i.e. x,y,z Source code in chmpy/crystal/symmetry_operation.py 353 354 355 356 @classmethod def identity ( cls ): \"Alternative constructor for the the identity symop i.e. x,y,z\" return cls . from_integer_code ( 16484 ) inverted ( self ) \" A copy of this symmetry operation under inversion Returns: Type Description SymmetryOperation an inverted copy of this symmetry operation Source code in chmpy/crystal/symmetry_operation.py 245 246 247 248 249 250 251 252 def inverted ( self ): \"\"\"\" A copy of this symmetry operation under inversion Returns: SymmetryOperation: an inverted copy of this symmetry operation \"\"\" return SymmetryOperation ( - self . rotation , - self . translation ) is_identity ( self ) Returns true if this is the identity symmetry operation '+x,+y,+z' Source code in chmpy/crystal/symmetry_operation.py 349 350 351 def is_identity ( self ) -> bool : \"Returns true if this is the identity symmetry operation '+x,+y,+z'\" return self . integer_code == 16484 decode_symm_int ( coded_integer ) Decode an integer encoded symmetry operation. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. encode_symm_str(*decode_symm_int(16484)) '+x,+y,+z' Parameters: Name Type Description Default coded_integer int integer encoding a symmetry operation required Returns: Type Description Tuple[np.ndarray, np.ndarray] (3,3) rotation matrix, (3) translation vector Source code in chmpy/crystal/symmetry_operation.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def decode_symm_int ( coded_integer ): \"\"\" Decode an integer encoded symmetry operation. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. >>> encode_symm_str(*decode_symm_int(16484)) '+x,+y,+z' Args: coded_integer (int): integer encoding a symmetry operation Returns: Tuple[np.ndarray, np.ndarray]: (3,3) rotation matrix, (3) translation vector \"\"\" r = coded_integer % 19683 # 19683 = 3**9 shift = 6561 # 6561 = 3**8 rotation = np . empty (( 3 , 3 ), dtype = np . float64 ) translation = np . empty ( 3 , dtype = np . float64 ) for i in ( 0 , 1 , 2 ): for j in ( 0 , 1 , 2 ): # we need integer division here rotation [ i , j ] = ( r % ( shift * 3 )) // shift - 1 shift //= 3 t = coded_integer // 19683 shift = 144 for i in ( 0 , 1 , 2 ): # we need integer division here by shift translation [ i ] = (( t % ( shift * 12 )) // shift ) / 12 shift //= 12 return rotation , translation decode_symm_str ( s ) Decode a symmetry operation represented in the string form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix and translation vector. encode_symm_str( decode_symm_str(\"x,y,z\")) '+x,+y,+z' encode_symm_str( decode_symm_str(\"1/2 - x,y-0.3333333,z\")) '1/2-x,2/3+y,+z' Parameters: Name Type Description Default s str the encoded symmetry operation string required Returns: Type Description Tuple[np.ndarray, np.ndarray] a (3,3) rotation matrix and a (3) translation vector Source code in chmpy/crystal/symmetry_operation.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def decode_symm_str ( s ): \"\"\" Decode a symmetry operation represented in the string form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix and translation vector. >>> encode_symm_str(*decode_symm_str(\"x,y,z\")) '+x,+y,+z' >>> encode_symm_str(*decode_symm_str(\"1/2 - x,y-0.3333333,z\")) '1/2-x,2/3+y,+z' Args: s (str): the encoded symmetry operation string Returns: Tuple[np.ndarray, np.ndarray]: a (3,3) rotation matrix and a (3) translation vector \"\"\" rotation = np . zeros (( 3 , 3 ), dtype = np . float64 ) translation = np . zeros (( 3 ,), dtype = np . float64 ) tokens = s . lower () . replace ( \" \" , \"\" ) . split ( \",\" ) for i , row in enumerate ( tokens ): fac = 1 row = row . strip () symbols = re . findall ( SYMM_STR_SYMBOL_REGEX , row ) for symbol in symbols : if \"x\" in symbol : idx = 0 fac = - 1 if \"-x\" in symbol else 1 rotation [ i , idx ] = fac elif \"y\" in symbol : idx = 1 fac = - 1 if \"-y\" in symbol else 1 rotation [ i , idx ] = fac elif \"z\" in symbol : idx = 2 fac = - 1 if \"-z\" in symbol else 1 rotation [ i , idx ] = fac else : if \"/\" in symbol : numerator , denominator = symbol . split ( \"/\" ) translation [ i ] = Fraction ( Fraction ( numerator ), Fraction ( denominator ) ) else : translation [ i ] += float ( Fraction ( symbol )) translation = translation % 1 return rotation , translation encode_symm_int ( rotation , translation ) Encode an integer encoded symmetry from a rotation matrix and translation vector. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0)) 16484 encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0)) 1433663 Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: Type Description int the encoded symmetry operation Source code in chmpy/crystal/symmetry_operation.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def encode_symm_int ( rotation , translation ): \"\"\" Encode an integer encoded symmetry from a rotation matrix and translation vector. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. >>> encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0)) 16484 >>> encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0)) 1433663 Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: int: the encoded symmetry operation \"\"\" r = 0 shift = 1 # encode rotation component rotation = np . round ( np . array ( rotation )) . astype ( int ) + 1 for i in ( 2 , 1 , 0 ): for j in ( 2 , 1 , 0 ): r += rotation [ i , j ] * shift shift *= 3 t = 0 shift = 1 translation = np . round ( np . array ( translation ) * 12 ) . astype ( int ) for i in ( 2 , 1 , 0 ): t += translation [ i ] * shift shift *= 12 return r + t * 19683 encode_symm_str ( rotation , translation ) Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector into string form e.g. 1/2-x,z-1/3,-y-1/6 encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '-x,1/2+z,1/3+y' encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '+x+y+z,1/2+x+z,1/3+y' Parameters: Name Type Description Default rotation array_like (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation required translation array_like (3) vector of rational numbers encoding the translation component of the symmetry operation required Returns: Type Description str the encoded symmetry operation Source code in chmpy/crystal/symmetry_operation.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def encode_symm_str ( rotation , translation ): \"\"\" Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector into string form e.g. 1/2-x,z-1/3,-y-1/6 >>> encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '-x,1/2+z,1/3+y' >>> encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '+x+y+z,1/2+x+z,1/3+y' Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: str: the encoded symmetry operation \"\"\" symbols = \"xyz\" res = [] for i in ( 0 , 1 , 2 ): t = Fraction ( translation [ i ]) . limit_denominator ( 12 ) v = \"\" if t != 0 : v += str ( t ) for j in range ( 0 , 3 ): c = rotation [ i ][ j ] if c != 0 : s = \"-\" if c < 0 else \"+\" v += s + symbols [ j ] res . append ( v ) res = \",\" . join ( res ) return res expanded_symmetry_list ( reduced_symops , lattice_type ) Create an expanded list of symmetry operations from the minimum specification given a certain lattice type. Parameters: Name Type Description Default reduced_symops List[SymmetryOperation] reduced list of symmetry operations required lattice_type int integer encoded lattice type with SHELX conventions, i.e. 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C required Returns: Type Description List[SymmetryOperation] an expanded list of symmetry operations given lattice type Source code in chmpy/crystal/symmetry_operation.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def expanded_symmetry_list ( reduced_symops , lattice_type ): \"\"\" Create an expanded list of symmetry operations from the minimum specification given a certain lattice type. Args: reduced_symops (List[SymmetryOperation]): reduced list of symmetry operations lattice_type (int): integer encoded lattice type with SHELX conventions, i.e. ``` 1: P, 2: I, 3: rhombohedral obverse on hexagonal axes, 4: F, 5: A, 6: B, 7: C ``` Returns: List[SymmetryOperation]: an expanded list of symmetry operations given lattice type \"\"\" lattice_type_value = abs ( lattice_type ) translations = LATTICE_TYPE_TRANSLATIONS [ lattice_type_value ] identity = SymmetryOperation . identity () if identity not in reduced_symops : LOG . debug ( \"Appending identity symop %s to reduced_symops\" ) reduced_symops . append ( identity ) LOG . debug ( \"Reduced symmetry list contains %d symops\" , len ( reduced_symops )) full_symops = [] for symop in reduced_symops : full_symops . append ( symop ) for t in translations : full_symops . append ( symop + t ) if lattice_type > 0 : full_symops += [ x . inverted () for x in full_symops ] LOG . debug ( \"Expanded symmetry list contains %d symops\" , len ( full_symops )) return full_symops reduced_symmetry_list ( full_symops , lattice_type ) Reduce an expanded list of symmetry operations to the minimum specification given a certain lattice type. Parameters: Name Type Description Default full_symops List[SymmetryOperation] list of symmetry operations required lattice_type int integer encoded lattice type with SHELX conventions, i.e. 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C required Returns: Type Description List[SymmetryOperation] minimal list of symmetry operations given lattice type Source code in chmpy/crystal/symmetry_operation.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def reduced_symmetry_list ( full_symops , lattice_type ): \"\"\" Reduce an expanded list of symmetry operations to the minimum specification given a certain lattice type. Args: full_symops (List[SymmetryOperation]): list of symmetry operations lattice_type (int): integer encoded lattice type with SHELX conventions, i.e. ``` 1: P, 2: I, 3: rhombohedral obverse on hexagonal axes, 4: F, 5: A, 6: B, 7: C ``` Returns: List[SymmetryOperation]: minimal list of symmetry operations given lattice type \"\"\" lattice_type_value = abs ( lattice_type ) translations = LATTICE_TYPE_TRANSLATIONS [ lattice_type_value ] reduced_symops = [ SymmetryOperation . identity ()] symops_to_process = list ( full_symops ) inversion = lattice_type > 0 while symops_to_process : next_symop = symops_to_process . pop ( 0 ) if next_symop in reduced_symops : continue if inversion and next_symop . inverted () in reduced_symops : continue for t in translations : x = next_symop + t if inversion and x . inverted () in reduced_symops : break if x in reduced_symops : break else : reduced_symops . append ( next_symop ) LOG . debug ( \"Reduced symmetry list contains %d symops\" , len ( reduced_symops )) return reduced_symops","title":"Symmetry Operations"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation","text":"","title":"chmpy.crystal.symmetry_operation"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation","text":"Class to represent a crystallographic symmetry operation, composed of a rotation and a translation. Attributes: Name Type Description rotation np.ndarray (3, 3) rotation matrix in fractional coordinates translation np.ndarray (3) translation vector in fractional coordinates","title":"SymmetryOperation"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.cif_form","text":"Represent this SymmetryOperation in string form e.g. '+x,+y,+z'","title":"cif_form"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.integer_code","text":"Represent this SymmetryOperation as a packed integer","title":"integer_code"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.seitz_matrix","text":"The Seitz matrix form of this SymmetryOperation","title":"seitz_matrix"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__add__","text":"Add a vector to this symmetry operation's translation vector. Returns: Type Description SymmetryOperation a copy of this symmetry operation under additional translation\" Source code in chmpy/crystal/symmetry_operation.py 254 255 256 257 258 259 260 261 def __add__ ( self , value : np . ndarray ): \"\"\" Add a vector to this symmetry operation's translation vector. Returns: SymmetryOperation: a copy of this symmetry operation under additional translation\" \"\"\" return SymmetryOperation ( self . rotation , self . translation + value )","title":"__add__()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__init__","text":"Construct a new symmetry operation from a rotation matrix and a translation vector Parameters: Name Type Description Default rotation np.ndarray (3, 3) rotation matrix required translation np.ndarray (3) translation vector required Returns: Type Description SymmetryOperation a new SymmetryOperation Source code in chmpy/crystal/symmetry_operation.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def __init__ ( self , rotation , translation ): \"\"\" Construct a new symmetry operation from a rotation matrix and a translation vector Arguments: rotation (np.ndarray): (3, 3) rotation matrix translation (np.ndarray): (3) translation vector Returns: SymmetryOperation: a new SymmetryOperation \"\"\" self . rotation = rotation self . translation = translation % 1","title":"__init__()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__sub__","text":"Subtract a vector from this symmetry operation's translation. Returns: Type Description SymmetryOperation a copy of this symmetry operation under additional translation\" Source code in chmpy/crystal/symmetry_operation.py 263 264 265 266 267 268 269 270 def __sub__ ( self , value : np . ndarray ): \"\"\" Subtract a vector from this symmetry operation's translation. Returns: SymmetryOperation: a copy of this symmetry operation under additional translation\" \"\"\" return SymmetryOperation ( self . rotation , self . translation - value )","title":"__sub__()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.apply","text":"Apply this symmetry operation to a set of fractional coordinates. Parameters: Name Type Description Default coordinates ndarray (N,3) or (N,4) array of fractional coordinates or homogeneous fractional coordinates. required Returns: Type Description ndarray np.ndarray: (N, 3) array of transformed coordinates Source code in chmpy/crystal/symmetry_operation.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply this symmetry operation to a set of fractional coordinates. Args: coordinates (np.ndarray): (N,3) or (N,4) array of fractional coordinates or homogeneous fractional coordinates. Returns: np.ndarray: (N, 3) array of transformed coordinates \"\"\" if coordinates . shape [ 1 ] == 4 : return np . dot ( coordinates , self . seitz_matrix . T ) else : return np . dot ( coordinates , self . rotation . T ) + self . translation","title":"apply()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.from_integer_code","text":"Alternative constructor from an integer-encoded symmetry operation e.g. 16484 See also the encode_symm_int , decode_symm_int methods. Parameters: Name Type Description Default code int integer-encoded symmetry operation required Returns: Type Description SymmetryOperation a new symmetry operation from the provided integer code Source code in chmpy/crystal/symmetry_operation.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @classmethod def from_integer_code ( cls , code : int ): \"\"\" Alternative constructor from an integer-encoded symmetry operation e.g. 16484 See also the `encode_symm_int`, `decode_symm_int` methods. Args: code (int): integer-encoded symmetry operation Returns: SymmetryOperation: a new symmetry operation from the provided integer code \"\"\" rot , trans = decode_symm_int ( code ) s = SymmetryOperation ( rot , trans ) setattr ( s , \"_integer_code\" , code ) return s","title":"from_integer_code()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.from_string_code","text":"Alternative constructor from a string encoded symmetry operation e.g. '+x,+y,+z'. See also the encode_symm_str , decode_symm_str methods. Parameters: Name Type Description Default code str string-encoded symmetry operation required Returns: Type Description SymmetryOperation a new symmetry operation from the provided string code Source code in chmpy/crystal/symmetry_operation.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @classmethod def from_string_code ( cls , code : str ): \"\"\" Alternative constructor from a string encoded symmetry operation e.g. '+x,+y,+z'. See also the `encode_symm_str`, `decode_symm_str` methods. Args: code (str): string-encoded symmetry operation Returns: SymmetryOperation: a new symmetry operation from the provided string code \"\"\" rot , trans = decode_symm_str ( code ) s = SymmetryOperation ( rot , trans ) setattr ( s , \"_string_code\" , code ) return s","title":"from_string_code()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.identity","text":"Alternative constructor for the the identity symop i.e. x,y,z Source code in chmpy/crystal/symmetry_operation.py 353 354 355 356 @classmethod def identity ( cls ): \"Alternative constructor for the the identity symop i.e. x,y,z\" return cls . from_integer_code ( 16484 )","title":"identity()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.inverted","text":"\" A copy of this symmetry operation under inversion Returns: Type Description SymmetryOperation an inverted copy of this symmetry operation Source code in chmpy/crystal/symmetry_operation.py 245 246 247 248 249 250 251 252 def inverted ( self ): \"\"\"\" A copy of this symmetry operation under inversion Returns: SymmetryOperation: an inverted copy of this symmetry operation \"\"\" return SymmetryOperation ( - self . rotation , - self . translation )","title":"inverted()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.is_identity","text":"Returns true if this is the identity symmetry operation '+x,+y,+z' Source code in chmpy/crystal/symmetry_operation.py 349 350 351 def is_identity ( self ) -> bool : \"Returns true if this is the identity symmetry operation '+x,+y,+z'\" return self . integer_code == 16484","title":"is_identity()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.decode_symm_int","text":"Decode an integer encoded symmetry operation. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. encode_symm_str(*decode_symm_int(16484)) '+x,+y,+z' Parameters: Name Type Description Default coded_integer int integer encoding a symmetry operation required Returns: Type Description Tuple[np.ndarray, np.ndarray] (3,3) rotation matrix, (3) translation vector Source code in chmpy/crystal/symmetry_operation.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def decode_symm_int ( coded_integer ): \"\"\" Decode an integer encoded symmetry operation. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. >>> encode_symm_str(*decode_symm_int(16484)) '+x,+y,+z' Args: coded_integer (int): integer encoding a symmetry operation Returns: Tuple[np.ndarray, np.ndarray]: (3,3) rotation matrix, (3) translation vector \"\"\" r = coded_integer % 19683 # 19683 = 3**9 shift = 6561 # 6561 = 3**8 rotation = np . empty (( 3 , 3 ), dtype = np . float64 ) translation = np . empty ( 3 , dtype = np . float64 ) for i in ( 0 , 1 , 2 ): for j in ( 0 , 1 , 2 ): # we need integer division here rotation [ i , j ] = ( r % ( shift * 3 )) // shift - 1 shift //= 3 t = coded_integer // 19683 shift = 144 for i in ( 0 , 1 , 2 ): # we need integer division here by shift translation [ i ] = (( t % ( shift * 12 )) // shift ) / 12 shift //= 12 return rotation , translation","title":"decode_symm_int()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.decode_symm_str","text":"Decode a symmetry operation represented in the string form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix and translation vector. encode_symm_str( decode_symm_str(\"x,y,z\")) '+x,+y,+z' encode_symm_str( decode_symm_str(\"1/2 - x,y-0.3333333,z\")) '1/2-x,2/3+y,+z' Parameters: Name Type Description Default s str the encoded symmetry operation string required Returns: Type Description Tuple[np.ndarray, np.ndarray] a (3,3) rotation matrix and a (3) translation vector Source code in chmpy/crystal/symmetry_operation.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def decode_symm_str ( s ): \"\"\" Decode a symmetry operation represented in the string form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix and translation vector. >>> encode_symm_str(*decode_symm_str(\"x,y,z\")) '+x,+y,+z' >>> encode_symm_str(*decode_symm_str(\"1/2 - x,y-0.3333333,z\")) '1/2-x,2/3+y,+z' Args: s (str): the encoded symmetry operation string Returns: Tuple[np.ndarray, np.ndarray]: a (3,3) rotation matrix and a (3) translation vector \"\"\" rotation = np . zeros (( 3 , 3 ), dtype = np . float64 ) translation = np . zeros (( 3 ,), dtype = np . float64 ) tokens = s . lower () . replace ( \" \" , \"\" ) . split ( \",\" ) for i , row in enumerate ( tokens ): fac = 1 row = row . strip () symbols = re . findall ( SYMM_STR_SYMBOL_REGEX , row ) for symbol in symbols : if \"x\" in symbol : idx = 0 fac = - 1 if \"-x\" in symbol else 1 rotation [ i , idx ] = fac elif \"y\" in symbol : idx = 1 fac = - 1 if \"-y\" in symbol else 1 rotation [ i , idx ] = fac elif \"z\" in symbol : idx = 2 fac = - 1 if \"-z\" in symbol else 1 rotation [ i , idx ] = fac else : if \"/\" in symbol : numerator , denominator = symbol . split ( \"/\" ) translation [ i ] = Fraction ( Fraction ( numerator ), Fraction ( denominator ) ) else : translation [ i ] += float ( Fraction ( symbol )) translation = translation % 1 return rotation , translation","title":"decode_symm_str()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.encode_symm_int","text":"Encode an integer encoded symmetry from a rotation matrix and translation vector. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0)) 16484 encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0)) 1433663 Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: Type Description int the encoded symmetry operation Source code in chmpy/crystal/symmetry_operation.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def encode_symm_int ( rotation , translation ): \"\"\" Encode an integer encoded symmetry from a rotation matrix and translation vector. A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12. Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient. >>> encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0)) 16484 >>> encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0)) 1433663 Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: int: the encoded symmetry operation \"\"\" r = 0 shift = 1 # encode rotation component rotation = np . round ( np . array ( rotation )) . astype ( int ) + 1 for i in ( 2 , 1 , 0 ): for j in ( 2 , 1 , 0 ): r += rotation [ i , j ] * shift shift *= 3 t = 0 shift = 1 translation = np . round ( np . array ( translation ) * 12 ) . astype ( int ) for i in ( 2 , 1 , 0 ): t += translation [ i ] * shift shift *= 12 return r + t * 19683","title":"encode_symm_int()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.encode_symm_str","text":"Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector into string form e.g. 1/2-x,z-1/3,-y-1/6 encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '-x,1/2+z,1/3+y' encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '+x+y+z,1/2+x+z,1/3+y' Parameters: Name Type Description Default rotation array_like (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation required translation array_like (3) vector of rational numbers encoding the translation component of the symmetry operation required Returns: Type Description str the encoded symmetry operation Source code in chmpy/crystal/symmetry_operation.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def encode_symm_str ( rotation , translation ): \"\"\" Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector into string form e.g. 1/2-x,z-1/3,-y-1/6 >>> encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '-x,1/2+z,1/3+y' >>> encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1/3)) '+x+y+z,1/2+x+z,1/3+y' Args: rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation translation (array_like): (3) vector of rational numbers encoding the translation component of the symmetry operation Returns: str: the encoded symmetry operation \"\"\" symbols = \"xyz\" res = [] for i in ( 0 , 1 , 2 ): t = Fraction ( translation [ i ]) . limit_denominator ( 12 ) v = \"\" if t != 0 : v += str ( t ) for j in range ( 0 , 3 ): c = rotation [ i ][ j ] if c != 0 : s = \"-\" if c < 0 else \"+\" v += s + symbols [ j ] res . append ( v ) res = \",\" . join ( res ) return res","title":"encode_symm_str()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.expanded_symmetry_list","text":"Create an expanded list of symmetry operations from the minimum specification given a certain lattice type. Parameters: Name Type Description Default reduced_symops List[SymmetryOperation] reduced list of symmetry operations required lattice_type int integer encoded lattice type with SHELX conventions, i.e. 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C required Returns: Type Description List[SymmetryOperation] an expanded list of symmetry operations given lattice type Source code in chmpy/crystal/symmetry_operation.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def expanded_symmetry_list ( reduced_symops , lattice_type ): \"\"\" Create an expanded list of symmetry operations from the minimum specification given a certain lattice type. Args: reduced_symops (List[SymmetryOperation]): reduced list of symmetry operations lattice_type (int): integer encoded lattice type with SHELX conventions, i.e. ``` 1: P, 2: I, 3: rhombohedral obverse on hexagonal axes, 4: F, 5: A, 6: B, 7: C ``` Returns: List[SymmetryOperation]: an expanded list of symmetry operations given lattice type \"\"\" lattice_type_value = abs ( lattice_type ) translations = LATTICE_TYPE_TRANSLATIONS [ lattice_type_value ] identity = SymmetryOperation . identity () if identity not in reduced_symops : LOG . debug ( \"Appending identity symop %s to reduced_symops\" ) reduced_symops . append ( identity ) LOG . debug ( \"Reduced symmetry list contains %d symops\" , len ( reduced_symops )) full_symops = [] for symop in reduced_symops : full_symops . append ( symop ) for t in translations : full_symops . append ( symop + t ) if lattice_type > 0 : full_symops += [ x . inverted () for x in full_symops ] LOG . debug ( \"Expanded symmetry list contains %d symops\" , len ( full_symops )) return full_symops","title":"expanded_symmetry_list()"},{"location":"API/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.reduced_symmetry_list","text":"Reduce an expanded list of symmetry operations to the minimum specification given a certain lattice type. Parameters: Name Type Description Default full_symops List[SymmetryOperation] list of symmetry operations required lattice_type int integer encoded lattice type with SHELX conventions, i.e. 1 : P , 2 : I , 3 : rhombohedral obverse on hexagonal axes , 4 : F , 5 : A , 6 : B , 7 : C required Returns: Type Description List[SymmetryOperation] minimal list of symmetry operations given lattice type Source code in chmpy/crystal/symmetry_operation.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def reduced_symmetry_list ( full_symops , lattice_type ): \"\"\" Reduce an expanded list of symmetry operations to the minimum specification given a certain lattice type. Args: full_symops (List[SymmetryOperation]): list of symmetry operations lattice_type (int): integer encoded lattice type with SHELX conventions, i.e. ``` 1: P, 2: I, 3: rhombohedral obverse on hexagonal axes, 4: F, 5: A, 6: B, 7: C ``` Returns: List[SymmetryOperation]: minimal list of symmetry operations given lattice type \"\"\" lattice_type_value = abs ( lattice_type ) translations = LATTICE_TYPE_TRANSLATIONS [ lattice_type_value ] reduced_symops = [ SymmetryOperation . identity ()] symops_to_process = list ( full_symops ) inversion = lattice_type > 0 while symops_to_process : next_symop = symops_to_process . pop ( 0 ) if next_symop in reduced_symops : continue if inversion and next_symop . inverted () in reduced_symops : continue for t in translations : x = next_symop + t if inversion and x . inverted () in reduced_symops : break if x in reduced_symops : break else : reduced_symops . append ( next_symop ) LOG . debug ( \"Reduced symmetry list contains %d symops\" , len ( reduced_symops )) return reduced_symops","title":"reduced_symmetry_list()"},{"location":"API/crystal/unit_cell/","text":"UnitCell Storage class for the lattice vectors of a crystal i.e. its unit cell. Attributes: Name Type Description direct np.ndarray the direct matrix of this unit cell i.e. the lattice vectors reciprocal_lattice np.ndarray the reciprocal matrix of this unit cell i.e. the reciprocal lattice vectors inverse np.ndarray the inverse matrix of this unit cell i.e. the transpose of reciprocal_lattice lattice np.ndarray an alias for direct a: float property readonly Length of lattice vector a a_star: float property readonly length of reciprocal lattice vector a* abc_different: bool property readonly are all of the lengths a, b, c different? abc_equal: bool property readonly are the lengths a, b, c all equal? alpha: float property readonly Angle between lattice vectors b and c alpha_deg: float property readonly Angle between lattice vectors b and c in degrees alpha_star: float property readonly Angle between reciprocal lattice vectors b and c angles_different: bool property readonly are all of the angles alpha, beta, gamma different? b: float property readonly Length of lattice vector b b_star: float property readonly length of reciprocal lattice vector b* beta: float property readonly Angle between lattice vectors a and c beta_deg: float property readonly Angle between lattice vectors a and c in degrees beta_star: float property readonly Angle between reciprocal lattice vectors a and c c: float property readonly Length of lattice vector c c_star: float property readonly length of reciprocal lattice vector c* direct_homogeneous: ndarray property readonly The direct matrix in homogeneous coordinates gamma: float property readonly Angle between lattice vectors a and b gamma_deg: float property readonly Angle between lattice vectors a and b in degrees gamma_star: float property readonly Angle between reciprocal lattice vectors a and c is_cubic: bool property readonly Returns true if all lengths are equal and all angles are 90 degrees is_hexagonal: bool property readonly Returns true if lengths a == b, a != c, alpha and beta == 90 and gamma == 120 is_monoclinic: bool property readonly Returns true if angles alpha and gamma are equal is_orthorhombic: bool property readonly Returns true if all angles are 90 degrees is_rhombohedral: bool property readonly Returns true if all lengths are equal and all angles are equal is_tetragonal: bool property readonly Returns true if a, b are equal and all angles are 90 degrees is_triclinic: bool property readonly Returns true if and lengths are different lattice: ndarray property readonly The direct matrix of this unit cell i.e. vectors of the lattice orthogonal: bool property readonly returns true if the lattice vectors are orthogonal parameters: ndarray property readonly single vector of lattice side lengths and angles in degrees reciprocal_lattice: ndarray property readonly The reciprocal matrix of this unit cell i.e. vectors of the reciprocal lattice v_a: ndarray property readonly lattice vector a v_a_star: ndarray property readonly reciprocal lattice vector a* v_b: ndarray property readonly lattice vector a v_b_star: ndarray property readonly reciprocal lattice vector b* v_c: ndarray property readonly lattice vector a v_c_star: ndarray property readonly reciprocal lattice vector c* __init__ ( self , vectors ) special Create a UnitCell object from a list of lattice vectors or a row major direct matrix. Unless otherwise specified, length units are Angstroms, and angular units are radians. Parameters: Name Type Description Default vectors array_like (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. required Source code in chmpy/crystal/unit_cell.py 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , vectors ): \"\"\" Create a UnitCell object from a list of lattice vectors or a row major direct matrix. Unless otherwise specified, length units are Angstroms, and angular units are radians. Args: vectors (array_like): (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. \"\"\" self . set_vectors ( vectors ) cubic ( length ) classmethod Construct a new cubic UnitCell from the provided side length. Parameters: Name Type Description Default length float Lattice side length a in Angstroms. required Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 424 425 426 427 428 429 430 431 432 433 434 435 @classmethod def cubic ( cls , length ): \"\"\" Construct a new cubic UnitCell from the provided side length. Args: length (float): Lattice side length a in Angstroms. Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" return cls ( np . eye ( 3 ) * length ) from_lengths_and_angles ( lengths , angles , unit = 'radians' ) classmethod Construct a new UnitCell from the provided lengths and angles. Parameters: Name Type Description Default lengths array_like Lattice side lengths (a, b, c) in Angstroms. required angles array_like Lattice angles (alpha, beta, gamma) in provided units (default radians) required unit str Unit for angles i.e. 'radians' or 'degrees' (default radians). 'radians' Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 @classmethod def from_lengths_and_angles ( cls , lengths , angles , unit = \"radians\" ): \"\"\" Construct a new UnitCell from the provided lengths and angles. Args: lengths (array_like): Lattice side lengths (a, b, c) in Angstroms. angles (array_like): Lattice angles (alpha, beta, gamma) in provided units (default radians) unit (str, optional): Unit for angles i.e. 'radians' or 'degrees' (default radians). Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" uc = cls ( np . eye ( 3 )) if unit == \"radians\" : if np . any ( np . abs ( angles ) > np . pi ): LOG . warn ( \"Large angle in UnitCell.from_lengths_and_angles, \" \"are you sure your angles are not in degrees?\" ) uc . set_lengths_and_angles ( lengths , angles ) else : uc . set_lengths_and_angles ( lengths , np . radians ( angles )) return uc from_unique_parameters ( params , cell_type = 'triclinic' , ** kwargs ) classmethod Construct a new unit cell from the unique parameters and the specified cell type. Parameters: Name Type Description Default params Tuple tuple of floats of unique parameters required cell_type str the desired cell type 'triclinic' Source code in chmpy/crystal/unit_cell.py 437 438 439 440 441 442 443 444 445 446 447 @classmethod def from_unique_parameters ( cls , params , cell_type = \"triclinic\" , ** kwargs ): \"\"\" Construct a new unit cell from the unique parameters and the specified cell type. Args: params (Tuple): tuple of floats of unique parameters cell_type (str, optional): the desired cell type \"\"\" return getattr ( cls , cell_type )( * params ) hexagonal ( * params , ** kwargs ) classmethod Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths (a, c) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 @classmethod def hexagonal ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths (a, c) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 2 lengths for Hexagonal cell\" unit = kwargs . pop ( \"unit\" , \"radians\" ) unit = \"radians\" angles = [ np . pi / 2 , np . pi / 2 , 2 * np . pi / 3 ] return cls . from_lengths_and_angles ( ( params [ 0 ], params [ 0 ], params [ 1 ]), angles , unit = unit , ** kwargs ) monoclinic ( * params , ** kwargs ) classmethod Construct a new UnitCell from the provided side lengths and angle. Parameters: Name Type Description Default params array_like Lattice side lengths and angles (a, b, c, beta) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 @classmethod def monoclinic ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angle. Args: params (array_like): Lattice side lengths and angles (a, b, c, beta) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert ( len ( params ) == 4 ), \"Requre three lengths and one angle for Monoclinic cell\" unit = kwargs . get ( \"unit\" , \"radians\" ) if unit != \"radians\" : alpha , gamma = 90 , 90 else : alpha , gamma = np . pi / 2 , np . pi / 2 return cls . from_lengths_and_angles ( params [: 3 ], ( alpha , params [ 3 ], gamma ), ** kwargs ) orthorhombic ( * lengths , ** kwargs ) classmethod Construct a new orthorhombic UnitCell from the provided side lengths. Parameters: Name Type Description Default lengths array_like Lattice side lengths (a, b, c) in Angstroms. () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 @classmethod def orthorhombic ( cls , * lengths , ** kwargs ): \"\"\" Construct a new orthorhombic UnitCell from the provided side lengths. Args: lengths (array_like): Lattice side lengths (a, b, c) in Angstroms. Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( lengths ) == 3 , \"Requre three lengths for Orthorhombic cell\" return cls ( np . diag ( lengths )) rhombohedral ( * params , ** kwargs ) classmethod Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side length a and angle alpha c () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 528 529 530 531 532 533 534 535 536 537 538 539 540 @classmethod def rhombohedral ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side length a and angle alpha c Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 1 length and 1 angle for Rhombohedral cell\" return cls . from_lengths_and_angles ([ params [ 0 ]] * 3 , [ params [ 1 ]] * 3 , ** kwargs ) set_lengths_and_angles ( self , lengths , angles ) Modify this unit cell by setting the lattice vectors according to lengths a, b, c and angles alpha, beta, gamma of a parallelipiped. Parameters: Name Type Description Default lengths array_like array of (a, b, c), the unit cell side lengths in Angstroms. required angles array_like array of (alpha, beta, gamma), the unit cell angles lengths in radians. required Source code in chmpy/crystal/unit_cell.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def set_lengths_and_angles ( self , lengths , angles ): \"\"\" Modify this unit cell by setting the lattice vectors according to lengths a, b, c and angles alpha, beta, gamma of a parallelipiped. Args: lengths (array_like): array of (a, b, c), the unit cell side lengths in Angstroms. angles (array_like): array of (alpha, beta, gamma), the unit cell angles lengths in radians. \"\"\" self . lengths = lengths self . angles = angles a , b , c = self . lengths ca , cb , cg = np . cos ( self . angles ) sg = np . sin ( self . angles [ 2 ]) v = self . volume () self . direct = np . transpose ( [ [ a , b * cg , c * cb ], [ 0 , b * sg , c * ( ca - cb * cg ) / sg ], [ 0 , 0 , v / ( a * b * sg )], ] ) r = [ [ 1 / a , 0.0 , 0.0 ], [ - cg / ( a * sg ), 1 / ( b * sg ), 0 ], [ b * c * ( ca * cg - cb ) / v / sg , a * c * ( cb * cg - ca ) / v / sg , a * b * sg / v , ], ] self . inverse = np . array ( r ) self . _set_cell_type () set_vectors ( self , vectors ) Modify this unit cell by setting the lattice vectors according to those provided. This is performed by setting the lattice parameters (lengths and angles) based on the provided vectors, such that it results in a consistent basis without directly matrix inverse (and typically losing precision), and as the SHELX file/CIF output will be relying on these lengths/angles anyway, it is important to have these consistent. Parameters: Name Type Description Default vectors array_like (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. required Source code in chmpy/crystal/unit_cell.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def set_vectors ( self , vectors ): \"\"\" Modify this unit cell by setting the lattice vectors according to those provided. This is performed by setting the lattice parameters (lengths and angles) based on the provided vectors, such that it results in a consistent basis without directly matrix inverse (and typically losing precision), and as the SHELX file/CIF output will be relying on these lengths/angles anyway, it is important to have these consistent. Args: vectors (array_like): (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. \"\"\" self . direct = vectors params = zeros ( 6 ) a , b , c = np . linalg . norm ( self . direct , axis = 1 ) u_a = vectors [ 0 , :] / a u_b = vectors [ 1 , :] / b u_c = vectors [ 2 , :] / c alpha = np . arccos ( np . clip ( np . vdot ( u_b , u_c ), - 1 , 1 )) beta = np . arccos ( np . clip ( np . vdot ( u_c , u_a ), - 1 , 1 )) gamma = np . arccos ( np . clip ( np . vdot ( u_a , u_b ), - 1 , 1 )) params [ 3 :] = np . degrees ([ alpha , beta , gamma ]) self . lengths = [ a , b , c ] self . angles = [ alpha , beta , gamma ] self . inverse = np . linalg . inv ( self . direct ) self . _set_cell_type () tetragonal ( * params , ** kwargs ) classmethod Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths (a, c) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 @classmethod def tetragonal ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths (a, c) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 2 lengths for Tetragonal cell\" unit = kwargs . get ( \"unit\" , \"radians\" ) if unit != \"radians\" : angles = [ 90 ] * 3 else : angles = [ np . pi / 2 ] * 3 return cls . from_lengths_and_angles ( ( params [ 0 ], params [ 0 ], params [ 1 ]), angles , ** kwargs ) to_cartesian ( self , coords ) Transform coordinates from fractional space (a, b, c) to Cartesian space (x, y, z). The x-direction will be aligned along lattice vector A. Parameters: Name Type Description Default coords ndarray (N, 3) array of fractional coordinates required Returns: Type Description ndarray np.ndarray: (N, 3) array of Cartesian coordinates Source code in chmpy/crystal/unit_cell.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def to_cartesian ( self , coords : np . ndarray ) -> np . ndarray : \"\"\" Transform coordinates from fractional space (a, b, c) to Cartesian space (x, y, z). The x-direction will be aligned along lattice vector A. Args: coords (array_like): (N, 3) array of fractional coordinates Returns: np.ndarray: (N, 3) array of Cartesian coordinates \"\"\" return np . dot ( coords , self . direct ) to_fractional ( self , coords ) Transform coordinates from Cartesian space (x, y, z) to fractional space (a, b, c). The x-direction will is assumed be aligned along lattice vector A. Parameters: Name Type Description Default coords ndarray an (N, 3) array of Cartesian coordinates required Returns: Type Description ndarray np.ndarray: (N, 3) array of fractional coordinates Source code in chmpy/crystal/unit_cell.py 65 66 67 68 69 70 71 72 73 74 75 76 77 def to_fractional ( self , coords : np . ndarray ) -> np . ndarray : \"\"\" Transform coordinates from Cartesian space (x, y, z) to fractional space (a, b, c). The x-direction will is assumed be aligned along lattice vector A. Args: coords (array_like): an (N, 3) array of Cartesian coordinates Returns: np.ndarray: (N, 3) array of fractional coordinates \"\"\" return np . dot ( coords , self . inverse ) triclinic ( * params , ** kwargs ) classmethod Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths and angles (a, b, c, alpha, beta, gamma) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @classmethod def triclinic ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths and angles (a, b, c, alpha, beta, gamma) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 6 , \"Requre three lengths and angles for Triclinic cell\" return cls . from_lengths_and_angles ( params [: 3 ], params [ 3 :], ** kwargs ) volume ( self ) The volume of the unit cell, in cubic Angstroms Source code in chmpy/crystal/unit_cell.py 196 197 198 199 200 def volume ( self ) -> float : \"\"\"The volume of the unit cell, in cubic Angstroms\"\"\" a , b , c = self . lengths ca , cb , cg = np . cos ( self . angles ) return a * b * c * np . sqrt ( 1 - ca * ca - cb * cb - cg * cg + 2 * ca * cb * cg )","title":"Unit Cell"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell","text":"","title":"chmpy.crystal.unit_cell"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell","text":"Storage class for the lattice vectors of a crystal i.e. its unit cell. Attributes: Name Type Description direct np.ndarray the direct matrix of this unit cell i.e. the lattice vectors reciprocal_lattice np.ndarray the reciprocal matrix of this unit cell i.e. the reciprocal lattice vectors inverse np.ndarray the inverse matrix of this unit cell i.e. the transpose of reciprocal_lattice lattice np.ndarray an alias for direct","title":"UnitCell"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.a","text":"Length of lattice vector a","title":"a"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.a_star","text":"length of reciprocal lattice vector a*","title":"a_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.abc_different","text":"are all of the lengths a, b, c different?","title":"abc_different"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.abc_equal","text":"are the lengths a, b, c all equal?","title":"abc_equal"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha","text":"Angle between lattice vectors b and c","title":"alpha"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha_deg","text":"Angle between lattice vectors b and c in degrees","title":"alpha_deg"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha_star","text":"Angle between reciprocal lattice vectors b and c","title":"alpha_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.angles_different","text":"are all of the angles alpha, beta, gamma different?","title":"angles_different"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.b","text":"Length of lattice vector b","title":"b"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.b_star","text":"length of reciprocal lattice vector b*","title":"b_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta","text":"Angle between lattice vectors a and c","title":"beta"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta_deg","text":"Angle between lattice vectors a and c in degrees","title":"beta_deg"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta_star","text":"Angle between reciprocal lattice vectors a and c","title":"beta_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.c","text":"Length of lattice vector c","title":"c"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.c_star","text":"length of reciprocal lattice vector c*","title":"c_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.direct_homogeneous","text":"The direct matrix in homogeneous coordinates","title":"direct_homogeneous"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma","text":"Angle between lattice vectors a and b","title":"gamma"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma_deg","text":"Angle between lattice vectors a and b in degrees","title":"gamma_deg"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma_star","text":"Angle between reciprocal lattice vectors a and c","title":"gamma_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_cubic","text":"Returns true if all lengths are equal and all angles are 90 degrees","title":"is_cubic"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_hexagonal","text":"Returns true if lengths a == b, a != c, alpha and beta == 90 and gamma == 120","title":"is_hexagonal"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_monoclinic","text":"Returns true if angles alpha and gamma are equal","title":"is_monoclinic"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_orthorhombic","text":"Returns true if all angles are 90 degrees","title":"is_orthorhombic"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_rhombohedral","text":"Returns true if all lengths are equal and all angles are equal","title":"is_rhombohedral"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_tetragonal","text":"Returns true if a, b are equal and all angles are 90 degrees","title":"is_tetragonal"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_triclinic","text":"Returns true if and lengths are different","title":"is_triclinic"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.lattice","text":"The direct matrix of this unit cell i.e. vectors of the lattice","title":"lattice"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.orthogonal","text":"returns true if the lattice vectors are orthogonal","title":"orthogonal"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.parameters","text":"single vector of lattice side lengths and angles in degrees","title":"parameters"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.reciprocal_lattice","text":"The reciprocal matrix of this unit cell i.e. vectors of the reciprocal lattice","title":"reciprocal_lattice"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_a","text":"lattice vector a","title":"v_a"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_a_star","text":"reciprocal lattice vector a*","title":"v_a_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_b","text":"lattice vector a","title":"v_b"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_b_star","text":"reciprocal lattice vector b*","title":"v_b_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_c","text":"lattice vector a","title":"v_c"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_c_star","text":"reciprocal lattice vector c*","title":"v_c_star"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.__init__","text":"Create a UnitCell object from a list of lattice vectors or a row major direct matrix. Unless otherwise specified, length units are Angstroms, and angular units are radians. Parameters: Name Type Description Default vectors array_like (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. required Source code in chmpy/crystal/unit_cell.py 22 23 24 25 26 27 28 29 30 31 32 def __init__ ( self , vectors ): \"\"\" Create a UnitCell object from a list of lattice vectors or a row major direct matrix. Unless otherwise specified, length units are Angstroms, and angular units are radians. Args: vectors (array_like): (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. \"\"\" self . set_vectors ( vectors )","title":"__init__()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.cubic","text":"Construct a new cubic UnitCell from the provided side length. Parameters: Name Type Description Default length float Lattice side length a in Angstroms. required Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 424 425 426 427 428 429 430 431 432 433 434 435 @classmethod def cubic ( cls , length ): \"\"\" Construct a new cubic UnitCell from the provided side length. Args: length (float): Lattice side length a in Angstroms. Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" return cls ( np . eye ( 3 ) * length )","title":"cubic()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.from_lengths_and_angles","text":"Construct a new UnitCell from the provided lengths and angles. Parameters: Name Type Description Default lengths array_like Lattice side lengths (a, b, c) in Angstroms. required angles array_like Lattice angles (alpha, beta, gamma) in provided units (default radians) required unit str Unit for angles i.e. 'radians' or 'degrees' (default radians). 'radians' Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 @classmethod def from_lengths_and_angles ( cls , lengths , angles , unit = \"radians\" ): \"\"\" Construct a new UnitCell from the provided lengths and angles. Args: lengths (array_like): Lattice side lengths (a, b, c) in Angstroms. angles (array_like): Lattice angles (alpha, beta, gamma) in provided units (default radians) unit (str, optional): Unit for angles i.e. 'radians' or 'degrees' (default radians). Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" uc = cls ( np . eye ( 3 )) if unit == \"radians\" : if np . any ( np . abs ( angles ) > np . pi ): LOG . warn ( \"Large angle in UnitCell.from_lengths_and_angles, \" \"are you sure your angles are not in degrees?\" ) uc . set_lengths_and_angles ( lengths , angles ) else : uc . set_lengths_and_angles ( lengths , np . radians ( angles )) return uc","title":"from_lengths_and_angles()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.from_unique_parameters","text":"Construct a new unit cell from the unique parameters and the specified cell type. Parameters: Name Type Description Default params Tuple tuple of floats of unique parameters required cell_type str the desired cell type 'triclinic' Source code in chmpy/crystal/unit_cell.py 437 438 439 440 441 442 443 444 445 446 447 @classmethod def from_unique_parameters ( cls , params , cell_type = \"triclinic\" , ** kwargs ): \"\"\" Construct a new unit cell from the unique parameters and the specified cell type. Args: params (Tuple): tuple of floats of unique parameters cell_type (str, optional): the desired cell type \"\"\" return getattr ( cls , cell_type )( * params )","title":"from_unique_parameters()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.hexagonal","text":"Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths (a, c) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 @classmethod def hexagonal ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths (a, c) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 2 lengths for Hexagonal cell\" unit = kwargs . pop ( \"unit\" , \"radians\" ) unit = \"radians\" angles = [ np . pi / 2 , np . pi / 2 , 2 * np . pi / 3 ] return cls . from_lengths_and_angles ( ( params [ 0 ], params [ 0 ], params [ 1 ]), angles , unit = unit , ** kwargs )","title":"hexagonal()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.monoclinic","text":"Construct a new UnitCell from the provided side lengths and angle. Parameters: Name Type Description Default params array_like Lattice side lengths and angles (a, b, c, beta) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 @classmethod def monoclinic ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angle. Args: params (array_like): Lattice side lengths and angles (a, b, c, beta) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert ( len ( params ) == 4 ), \"Requre three lengths and one angle for Monoclinic cell\" unit = kwargs . get ( \"unit\" , \"radians\" ) if unit != \"radians\" : alpha , gamma = 90 , 90 else : alpha , gamma = np . pi / 2 , np . pi / 2 return cls . from_lengths_and_angles ( params [: 3 ], ( alpha , params [ 3 ], gamma ), ** kwargs )","title":"monoclinic()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.orthorhombic","text":"Construct a new orthorhombic UnitCell from the provided side lengths. Parameters: Name Type Description Default lengths array_like Lattice side lengths (a, b, c) in Angstroms. () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 @classmethod def orthorhombic ( cls , * lengths , ** kwargs ): \"\"\" Construct a new orthorhombic UnitCell from the provided side lengths. Args: lengths (array_like): Lattice side lengths (a, b, c) in Angstroms. Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( lengths ) == 3 , \"Requre three lengths for Orthorhombic cell\" return cls ( np . diag ( lengths ))","title":"orthorhombic()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.rhombohedral","text":"Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side length a and angle alpha c () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 528 529 530 531 532 533 534 535 536 537 538 539 540 @classmethod def rhombohedral ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side length a and angle alpha c Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 1 length and 1 angle for Rhombohedral cell\" return cls . from_lengths_and_angles ([ params [ 0 ]] * 3 , [ params [ 1 ]] * 3 , ** kwargs )","title":"rhombohedral()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.set_lengths_and_angles","text":"Modify this unit cell by setting the lattice vectors according to lengths a, b, c and angles alpha, beta, gamma of a parallelipiped. Parameters: Name Type Description Default lengths array_like array of (a, b, c), the unit cell side lengths in Angstroms. required angles array_like array of (alpha, beta, gamma), the unit cell angles lengths in radians. required Source code in chmpy/crystal/unit_cell.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def set_lengths_and_angles ( self , lengths , angles ): \"\"\" Modify this unit cell by setting the lattice vectors according to lengths a, b, c and angles alpha, beta, gamma of a parallelipiped. Args: lengths (array_like): array of (a, b, c), the unit cell side lengths in Angstroms. angles (array_like): array of (alpha, beta, gamma), the unit cell angles lengths in radians. \"\"\" self . lengths = lengths self . angles = angles a , b , c = self . lengths ca , cb , cg = np . cos ( self . angles ) sg = np . sin ( self . angles [ 2 ]) v = self . volume () self . direct = np . transpose ( [ [ a , b * cg , c * cb ], [ 0 , b * sg , c * ( ca - cb * cg ) / sg ], [ 0 , 0 , v / ( a * b * sg )], ] ) r = [ [ 1 / a , 0.0 , 0.0 ], [ - cg / ( a * sg ), 1 / ( b * sg ), 0 ], [ b * c * ( ca * cg - cb ) / v / sg , a * c * ( cb * cg - ca ) / v / sg , a * b * sg / v , ], ] self . inverse = np . array ( r ) self . _set_cell_type ()","title":"set_lengths_and_angles()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.set_vectors","text":"Modify this unit cell by setting the lattice vectors according to those provided. This is performed by setting the lattice parameters (lengths and angles) based on the provided vectors, such that it results in a consistent basis without directly matrix inverse (and typically losing precision), and as the SHELX file/CIF output will be relying on these lengths/angles anyway, it is important to have these consistent. Parameters: Name Type Description Default vectors array_like (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. required Source code in chmpy/crystal/unit_cell.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def set_vectors ( self , vectors ): \"\"\" Modify this unit cell by setting the lattice vectors according to those provided. This is performed by setting the lattice parameters (lengths and angles) based on the provided vectors, such that it results in a consistent basis without directly matrix inverse (and typically losing precision), and as the SHELX file/CIF output will be relying on these lengths/angles anyway, it is important to have these consistent. Args: vectors (array_like): (3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc. \"\"\" self . direct = vectors params = zeros ( 6 ) a , b , c = np . linalg . norm ( self . direct , axis = 1 ) u_a = vectors [ 0 , :] / a u_b = vectors [ 1 , :] / b u_c = vectors [ 2 , :] / c alpha = np . arccos ( np . clip ( np . vdot ( u_b , u_c ), - 1 , 1 )) beta = np . arccos ( np . clip ( np . vdot ( u_c , u_a ), - 1 , 1 )) gamma = np . arccos ( np . clip ( np . vdot ( u_a , u_b ), - 1 , 1 )) params [ 3 :] = np . degrees ([ alpha , beta , gamma ]) self . lengths = [ a , b , c ] self . angles = [ alpha , beta , gamma ] self . inverse = np . linalg . inv ( self . direct ) self . _set_cell_type ()","title":"set_vectors()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.tetragonal","text":"Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths (a, c) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 @classmethod def tetragonal ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths (a, c) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 2 , \"Requre 2 lengths for Tetragonal cell\" unit = kwargs . get ( \"unit\" , \"radians\" ) if unit != \"radians\" : angles = [ 90 ] * 3 else : angles = [ np . pi / 2 ] * 3 return cls . from_lengths_and_angles ( ( params [ 0 ], params [ 0 ], params [ 1 ]), angles , ** kwargs )","title":"tetragonal()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.to_cartesian","text":"Transform coordinates from fractional space (a, b, c) to Cartesian space (x, y, z). The x-direction will be aligned along lattice vector A. Parameters: Name Type Description Default coords ndarray (N, 3) array of fractional coordinates required Returns: Type Description ndarray np.ndarray: (N, 3) array of Cartesian coordinates Source code in chmpy/crystal/unit_cell.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def to_cartesian ( self , coords : np . ndarray ) -> np . ndarray : \"\"\" Transform coordinates from fractional space (a, b, c) to Cartesian space (x, y, z). The x-direction will be aligned along lattice vector A. Args: coords (array_like): (N, 3) array of fractional coordinates Returns: np.ndarray: (N, 3) array of Cartesian coordinates \"\"\" return np . dot ( coords , self . direct )","title":"to_cartesian()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.to_fractional","text":"Transform coordinates from Cartesian space (x, y, z) to fractional space (a, b, c). The x-direction will is assumed be aligned along lattice vector A. Parameters: Name Type Description Default coords ndarray an (N, 3) array of Cartesian coordinates required Returns: Type Description ndarray np.ndarray: (N, 3) array of fractional coordinates Source code in chmpy/crystal/unit_cell.py 65 66 67 68 69 70 71 72 73 74 75 76 77 def to_fractional ( self , coords : np . ndarray ) -> np . ndarray : \"\"\" Transform coordinates from Cartesian space (x, y, z) to fractional space (a, b, c). The x-direction will is assumed be aligned along lattice vector A. Args: coords (array_like): an (N, 3) array of Cartesian coordinates Returns: np.ndarray: (N, 3) array of fractional coordinates \"\"\" return np . dot ( coords , self . inverse )","title":"to_fractional()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.triclinic","text":"Construct a new UnitCell from the provided side lengths and angles. Parameters: Name Type Description Default params array_like Lattice side lengths and angles (a, b, c, alpha, beta, gamma) () Returns: Type Description UnitCell A new unit cell object representing the provided lattice. Source code in chmpy/crystal/unit_cell.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @classmethod def triclinic ( cls , * params , ** kwargs ): \"\"\" Construct a new UnitCell from the provided side lengths and angles. Args: params (array_like): Lattice side lengths and angles (a, b, c, alpha, beta, gamma) Returns: UnitCell: A new unit cell object representing the provided lattice. \"\"\" assert len ( params ) == 6 , \"Requre three lengths and angles for Triclinic cell\" return cls . from_lengths_and_angles ( params [: 3 ], params [ 3 :], ** kwargs )","title":"triclinic()"},{"location":"API/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.volume","text":"The volume of the unit cell, in cubic Angstroms Source code in chmpy/crystal/unit_cell.py 196 197 198 199 200 def volume ( self ) -> float : \"\"\"The volume of the unit cell, in cubic Angstroms\"\"\" a , b , c = self . lengths ca , cb , cg = np . cos ( self . angles ) return a * b * c * np . sqrt ( 1 - ca * ca - cb * cb - cg * cg + 2 * ca * cb * cg )","title":"volume()"},{"location":"API/ext/charges/","text":"EEM Class to handle calculation of electronegativity equilibration method charges calculate_charges ( mol ) staticmethod Calculate the partial atomic charges based on the EEM method. Parameters: Name Type Description Default mol Molecule The molecule with atoms where partial charges are desired required Returns: Type Description np.ndarray the partial charges associated the atoms in mol Source code in chmpy/ext/charges.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @staticmethod def calculate_charges ( mol ): \"\"\" Calculate the partial atomic charges based on the EEM method. Args: mol (Molecule): The molecule with atoms where partial charges are desired Returns: np.ndarray: the partial charges associated the atoms in `mol` \"\"\" A = [] B = [] for el in mol . elements : a , b = EEM_PARAMETERS . get ( el . symbol , EEM_PARAMETERS [ \"*\" ]) A . append ( a ) B . append ( b ) N = len ( mol ) M = np . zeros (( N + 1 , N + 1 )) M [ - 1 , : - 1 ] = 1 M [: - 1 , - 1 ] = - 1 dists = mol . distance_matrix idx = np . triu_indices ( N , k = 1 ) M [ idx ] = EEM_KAPPA / dists [ idx ] idx = np . tril_indices ( N , k =- 1 ) M [ idx ] = EEM_KAPPA / dists [ idx ] np . fill_diagonal ( M , B ) M [ N , N ] = 0.0 y = np . zeros ( N + 1 ) y [: N ] -= A y [ N ] = mol . charge return np . linalg . solve ( M , y )[: N ]","title":"EEM Charges"},{"location":"API/ext/charges/#chmpy.ext.charges","text":"","title":"chmpy.ext.charges"},{"location":"API/ext/charges/#chmpy.ext.charges.EEM","text":"Class to handle calculation of electronegativity equilibration method charges","title":"EEM"},{"location":"API/ext/charges/#chmpy.ext.charges.EEM.calculate_charges","text":"Calculate the partial atomic charges based on the EEM method. Parameters: Name Type Description Default mol Molecule The molecule with atoms where partial charges are desired required Returns: Type Description np.ndarray the partial charges associated the atoms in mol Source code in chmpy/ext/charges.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @staticmethod def calculate_charges ( mol ): \"\"\" Calculate the partial atomic charges based on the EEM method. Args: mol (Molecule): The molecule with atoms where partial charges are desired Returns: np.ndarray: the partial charges associated the atoms in `mol` \"\"\" A = [] B = [] for el in mol . elements : a , b = EEM_PARAMETERS . get ( el . symbol , EEM_PARAMETERS [ \"*\" ]) A . append ( a ) B . append ( b ) N = len ( mol ) M = np . zeros (( N + 1 , N + 1 )) M [ - 1 , : - 1 ] = 1 M [: - 1 , - 1 ] = - 1 dists = mol . distance_matrix idx = np . triu_indices ( N , k = 1 ) M [ idx ] = EEM_KAPPA / dists [ idx ] idx = np . tril_indices ( N , k =- 1 ) M [ idx ] = EEM_KAPPA / dists [ idx ] np . fill_diagonal ( M , B ) M [ N , N ] = 0.0 y = np . zeros ( N + 1 ) y [: N ] -= A y [ N ] = mol . charge return np . linalg . solve ( M , y )[: N ]","title":"calculate_charges()"},{"location":"API/ext/elastic_tensor/","text":"Heavily inspired by fxcoudert's ELATE, and since it is a modified version of that, this is subject to the same MIT license. See the page, and the source here: http://progs.coudert.name/elate https://github.com/fxcoudert/elate ElasticTensor Class to represent an elastic tensor, along with methods to access it from_string ( s ) classmethod Initialize the elastic tensor from a string Source code in chmpy/ext/elastic_tensor.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @classmethod def from_string ( cls , s ): \"\"\"Initialize the elastic tensor from a string\"\"\" if not s : raise ValueError ( \"no matrix was provided\" ) if isinstance ( s , str ): # Remove braces and pipes s = s . replace ( \"|\" , \" \" ) . replace ( \"(\" , \" \" ) . replace ( \")\" , \" \" ) # Remove empty lines lines = [ line for line in s . split ( \" \\n \" ) if line . strip ()] if len ( lines ) != 6 : raise ValueError ( \"should have six rows\" ) # Convert to float try : mat = [[ float ( x ) for x in line . split ()] for line in lines ] except : raise ValueError ( \"not all entries are numbers\" ) return cls ( mat )","title":"Elastic Tensors"},{"location":"API/ext/elastic_tensor/#chmpy.ext.elastic_tensor","text":"Heavily inspired by fxcoudert's ELATE, and since it is a modified version of that, this is subject to the same MIT license. See the page, and the source here: http://progs.coudert.name/elate https://github.com/fxcoudert/elate","title":"chmpy.ext.elastic_tensor"},{"location":"API/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor","text":"Class to represent an elastic tensor, along with methods to access it","title":"ElasticTensor"},{"location":"API/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor.from_string","text":"Initialize the elastic tensor from a string Source code in chmpy/ext/elastic_tensor.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @classmethod def from_string ( cls , s ): \"\"\"Initialize the elastic tensor from a string\"\"\" if not s : raise ValueError ( \"no matrix was provided\" ) if isinstance ( s , str ): # Remove braces and pipes s = s . replace ( \"|\" , \" \" ) . replace ( \"(\" , \" \" ) . replace ( \")\" , \" \" ) # Remove empty lines lines = [ line for line in s . split ( \" \\n \" ) if line . strip ()] if len ( lines ) != 6 : raise ValueError ( \"should have six rows\" ) # Convert to float try : mat = [[ float ( x ) for x in line . split ()] for line in lines ] except : raise ValueError ( \"not all entries are numbers\" ) return cls ( mat )","title":"from_string()"},{"location":"API/util/color/","text":"property_to_color ( prop , cmap = 'viridis' , ** kwargs ) Convert a scalar array of property values to colors, given a provided color map (or property name). Parameters: Name Type Description Default prop array_like the scalar array of property values required cmap str the color map name or property name 'viridis' kwargs dict optional keyword arguments {} Returns: Type Description array_like the array of color values for the given property Source code in chmpy/util/color.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def property_to_color ( prop , cmap = \"viridis\" , ** kwargs ): \"\"\" Convert a scalar array of property values to colors, given a provided color map (or property name). Args: prop (array_like): the scalar array of property values cmap (str): the color map name or property name kwargs (dict): optional keyword arguments Returns: array_like: the array of color values for the given property \"\"\" from matplotlib.cm import get_cmap midpoint = kwargs . get ( \"midpoint\" , 0.0 if cmap in ( \"d_norm\" , \"esp\" ) else None ) colormap = get_cmap ( kwargs . get ( \"colormap\" , DEFAULT_COLORMAPS . get ( cmap , cmap ))) norm = None if midpoint is not None : try : from matplotlib.colors import TwoSlopeNorm except ImportError : from matplotlib.colors import DivergingNorm as TwoSlopeNorm vmin = prop . min () vmax = prop . max () if vmin >= 0.0 : vmin = - 1.0 if vmax <= 0.0 : vmax = 1.0 norm = TwoSlopeNorm ( vmin = vmin , vcenter = midpoint , vmax = vmax ) prop = norm ( prop ) return colormap ( prop )","title":"Colors"},{"location":"API/util/color/#chmpy.util.color","text":"","title":"chmpy.util.color"},{"location":"API/util/color/#chmpy.util.color.property_to_color","text":"Convert a scalar array of property values to colors, given a provided color map (or property name). Parameters: Name Type Description Default prop array_like the scalar array of property values required cmap str the color map name or property name 'viridis' kwargs dict optional keyword arguments {} Returns: Type Description array_like the array of color values for the given property Source code in chmpy/util/color.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def property_to_color ( prop , cmap = \"viridis\" , ** kwargs ): \"\"\" Convert a scalar array of property values to colors, given a provided color map (or property name). Args: prop (array_like): the scalar array of property values cmap (str): the color map name or property name kwargs (dict): optional keyword arguments Returns: array_like: the array of color values for the given property \"\"\" from matplotlib.cm import get_cmap midpoint = kwargs . get ( \"midpoint\" , 0.0 if cmap in ( \"d_norm\" , \"esp\" ) else None ) colormap = get_cmap ( kwargs . get ( \"colormap\" , DEFAULT_COLORMAPS . get ( cmap , cmap ))) norm = None if midpoint is not None : try : from matplotlib.colors import TwoSlopeNorm except ImportError : from matplotlib.colors import DivergingNorm as TwoSlopeNorm vmin = prop . min () vmax = prop . max () if vmin >= 0.0 : vmin = - 1.0 if vmax <= 0.0 : vmax = 1.0 norm = TwoSlopeNorm ( vmin = vmin , vcenter = midpoint , vmax = vmax ) prop = norm ( prop ) return colormap ( prop )","title":"property_to_color()"},{"location":"API/util/dict/","text":"nested_dict_delete ( root , key , sep = '.' ) Iterate through a dict, deleting items recursively based on a key. Parameters: Name Type Description Default root dict dictionary to remove an entry from required key str the string used to locate the key to delete in the root dictionary required sep str the separator for dictionary key items '.' Returns: Type Description dict the modified dict_to Examples: 1 2 3 4 5 6 7 8 >>> d1 = { 'test' : { 'test_val' : 3 }} >>> d2 = { 'test' : { 'test_val' : 5 , 'test_val_2' : 7 }, 'other' : 3 } >>> nested_dict_delete ( d1 , 'test.test_val' ) >>> d1 {} >>> nested_dict_delete ( d2 , 'test.test_val' ) >>> d2 { 'test' : { 'test_val_2' : 7 }, 'other' : 3 } Source code in chmpy/util/dict.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def nested_dict_delete ( root , key , sep = \".\" ): \"\"\" Iterate through a dict, deleting items recursively based on a key. Args: root (dict): dictionary to remove an entry from key (str): the string used to locate the key to delete in the root dictionary sep (str): the separator for dictionary key items Returns: dict: the modified dict_to Examples: >>> d1 = {'test': {'test_val': 3}} >>> d2 = {'test': {'test_val': 5, 'test_val_2': 7}, 'other': 3} >>> nested_dict_delete(d1, 'test.test_val') >>> d1 {} >>> nested_dict_delete(d2, 'test.test_val') >>> d2 {'test': {'test_val_2': 7}, 'other': 3} \"\"\" levels = key . split ( sep ) level_key = levels [ 0 ] if level_key in root : if isinstance ( root [ level_key ], collections . MutableMapping ): nested_dict_delete ( root [ level_key ], sep . join ( levels [ 1 :]), sep = sep ) if not root [ level_key ]: del root [ level_key ] else : del root [ level_key ] else : raise KeyError recursive_dict_update ( dict_to , dict_from ) Iterate through a dictionary , updating items inplace recursively from a second dictionary. Parameters: Name Type Description Default dict_to dict the first dictionary (to update) required dict_from dict the second dictionary (to pull updates from) required Returns: Type Description dict the modified dict_to Examples: 1 2 3 4 >>> d1 = { 'test' : { 'test_val' : 3 }} >>> d2 = { 'test' : { 'test_val' : 5 }, 'other' : 3 } >>> recursive_dict_update ( d1 , d2 ) { 'test' : { 'test_val' : 5 }, 'other' : 3 } Source code in chmpy/util/dict.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def recursive_dict_update ( dict_to , dict_from ): \"\"\" Iterate through a dictionary , updating items inplace recursively from a second dictionary. Args: dict_to (dict): the first dictionary (to update) dict_from (dict): the second dictionary (to pull updates from) Returns: dict: the modified dict_to Examples: >>> d1 = {'test': {'test_val': 3}} >>> d2 = {'test': {'test_val': 5}, 'other': 3} >>> recursive_dict_update(d1, d2) {'test': {'test_val': 5}, 'other': 3} \"\"\" for key , val in dict_from . items (): if isinstance ( val , collections . Mapping ): dict_to [ key ] = recursive_dict_update ( dict_to . get ( key , {}), val ) else : dict_to [ key ] = val return dict_to","title":"Dictionaries"},{"location":"API/util/dict/#chmpy.util.dict","text":"","title":"chmpy.util.dict"},{"location":"API/util/dict/#chmpy.util.dict.nested_dict_delete","text":"Iterate through a dict, deleting items recursively based on a key. Parameters: Name Type Description Default root dict dictionary to remove an entry from required key str the string used to locate the key to delete in the root dictionary required sep str the separator for dictionary key items '.' Returns: Type Description dict the modified dict_to Examples: 1 2 3 4 5 6 7 8 >>> d1 = { 'test' : { 'test_val' : 3 }} >>> d2 = { 'test' : { 'test_val' : 5 , 'test_val_2' : 7 }, 'other' : 3 } >>> nested_dict_delete ( d1 , 'test.test_val' ) >>> d1 {} >>> nested_dict_delete ( d2 , 'test.test_val' ) >>> d2 { 'test' : { 'test_val_2' : 7 }, 'other' : 3 } Source code in chmpy/util/dict.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def nested_dict_delete ( root , key , sep = \".\" ): \"\"\" Iterate through a dict, deleting items recursively based on a key. Args: root (dict): dictionary to remove an entry from key (str): the string used to locate the key to delete in the root dictionary sep (str): the separator for dictionary key items Returns: dict: the modified dict_to Examples: >>> d1 = {'test': {'test_val': 3}} >>> d2 = {'test': {'test_val': 5, 'test_val_2': 7}, 'other': 3} >>> nested_dict_delete(d1, 'test.test_val') >>> d1 {} >>> nested_dict_delete(d2, 'test.test_val') >>> d2 {'test': {'test_val_2': 7}, 'other': 3} \"\"\" levels = key . split ( sep ) level_key = levels [ 0 ] if level_key in root : if isinstance ( root [ level_key ], collections . MutableMapping ): nested_dict_delete ( root [ level_key ], sep . join ( levels [ 1 :]), sep = sep ) if not root [ level_key ]: del root [ level_key ] else : del root [ level_key ] else : raise KeyError","title":"nested_dict_delete()"},{"location":"API/util/dict/#chmpy.util.dict.recursive_dict_update","text":"Iterate through a dictionary , updating items inplace recursively from a second dictionary. Parameters: Name Type Description Default dict_to dict the first dictionary (to update) required dict_from dict the second dictionary (to pull updates from) required Returns: Type Description dict the modified dict_to Examples: 1 2 3 4 >>> d1 = { 'test' : { 'test_val' : 3 }} >>> d2 = { 'test' : { 'test_val' : 5 }, 'other' : 3 } >>> recursive_dict_update ( d1 , d2 ) { 'test' : { 'test_val' : 5 }, 'other' : 3 } Source code in chmpy/util/dict.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def recursive_dict_update ( dict_to , dict_from ): \"\"\" Iterate through a dictionary , updating items inplace recursively from a second dictionary. Args: dict_to (dict): the first dictionary (to update) dict_from (dict): the second dictionary (to pull updates from) Returns: dict: the modified dict_to Examples: >>> d1 = {'test': {'test_val': 3}} >>> d2 = {'test': {'test_val': 5}, 'other': 3} >>> recursive_dict_update(d1, d2) {'test': {'test_val': 5}, 'other': 3} \"\"\" for key , val in dict_from . items (): if isinstance ( val , collections . Mapping ): dict_to [ key ] = recursive_dict_update ( dict_to . get ( key , {}), val ) else : dict_to [ key ] = val return dict_to","title":"recursive_dict_update()"},{"location":"API/util/mesh/","text":"molecule_to_meshes ( molecule , ** kwargs ) Convert the provided molecule into a list of trimesh Meshes representing the molecule either as van der Waals spheres or as a CPK representation. Parameters: Name Type Description Default molecule Molecule The molecule to represent required kwargs dict Optional Keyword arguments {} Returns: Type Description list a list of meshes representing atoms and (optionally) bonds Source code in chmpy/util/mesh.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def molecule_to_meshes ( molecule , ** kwargs ): \"\"\" Convert the provided molecule into a list of trimesh Meshes representing the molecule either as van der Waals spheres or as a CPK representation. Args: molecule (Molecule): The molecule to represent kwargs (dict): Optional Keyword arguments Returns: list: a list of meshes representing atoms and (optionally) bonds \"\"\" from trimesh.creation import icosphere , cylinder from trimesh import Scene from trimesh import Trimesh import numpy as np from chmpy import Element from copy import deepcopy representation = kwargs . get ( \"representation\" , \"ball_stick\" ) base_sphere = icosphere ( subdivisions = 3 ) mesh_primitives = [] n_points = len ( base_sphere . vertices ) vertices = [] faces = [] colors = [] offset = 0 meshes = {} for i , ( el , pos ) in enumerate ( molecule ): m = base_sphere . copy () m . apply_scale ( getattr ( el , f \" { representation } _radius\" )) m . apply_translation ( pos ) m . visual . vertex_colors = np . repeat ([ el . color ], n_points , axis = 0 ) meshes [ f \"atom_ { molecule . labels [ i ] } \" ] = m if representation == \"ball_stick\" : bond_thickness = 0.12 for i , ( a , b , d ) in enumerate ( molecule . unique_bonds ): x1 = molecule . positions [ a ] x3 = molecule . positions [ b ] cyl = cylinder ( bond_thickness , d , segment = ( x1 , x3 )) cyl . visual . vertex_colors = np . repeat ( [( 100 , 100 , 100 , 255 ),], cyl . vertices . shape [ 0 ], axis = 0 ) bond_label = f \"bond_ { molecule . labels [ a ] } _ { molecule . labels [ b ] } \" meshes [ bond_label ] = cyl return meshes save_mesh ( mesh , filename ) Save the given Trimesh to a file. Parameters: Name Type Description Default mesh trimesh.Trimesh The mesh to save. required filename str The path to the destination file. required Source code in chmpy/util/mesh.py 6 7 8 9 10 11 12 13 14 15 16 17 18 def save_mesh ( mesh , filename ): \"\"\" Save the given Trimesh to a file. Args: mesh (trimesh.Trimesh): The mesh to save. filename (str): The path to the destination file. \"\"\" ext = filename . split ( \".\" )[ - 1 ] with open ( filename , \"wb\" ) as f : mesh . export ( f , ext ) LOG . debug ( \"Saved mesh %s to %s \" , mesh , filename )","title":"Meshes"},{"location":"API/util/mesh/#chmpy.util.mesh","text":"","title":"chmpy.util.mesh"},{"location":"API/util/mesh/#chmpy.util.mesh.molecule_to_meshes","text":"Convert the provided molecule into a list of trimesh Meshes representing the molecule either as van der Waals spheres or as a CPK representation. Parameters: Name Type Description Default molecule Molecule The molecule to represent required kwargs dict Optional Keyword arguments {} Returns: Type Description list a list of meshes representing atoms and (optionally) bonds Source code in chmpy/util/mesh.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def molecule_to_meshes ( molecule , ** kwargs ): \"\"\" Convert the provided molecule into a list of trimesh Meshes representing the molecule either as van der Waals spheres or as a CPK representation. Args: molecule (Molecule): The molecule to represent kwargs (dict): Optional Keyword arguments Returns: list: a list of meshes representing atoms and (optionally) bonds \"\"\" from trimesh.creation import icosphere , cylinder from trimesh import Scene from trimesh import Trimesh import numpy as np from chmpy import Element from copy import deepcopy representation = kwargs . get ( \"representation\" , \"ball_stick\" ) base_sphere = icosphere ( subdivisions = 3 ) mesh_primitives = [] n_points = len ( base_sphere . vertices ) vertices = [] faces = [] colors = [] offset = 0 meshes = {} for i , ( el , pos ) in enumerate ( molecule ): m = base_sphere . copy () m . apply_scale ( getattr ( el , f \" { representation } _radius\" )) m . apply_translation ( pos ) m . visual . vertex_colors = np . repeat ([ el . color ], n_points , axis = 0 ) meshes [ f \"atom_ { molecule . labels [ i ] } \" ] = m if representation == \"ball_stick\" : bond_thickness = 0.12 for i , ( a , b , d ) in enumerate ( molecule . unique_bonds ): x1 = molecule . positions [ a ] x3 = molecule . positions [ b ] cyl = cylinder ( bond_thickness , d , segment = ( x1 , x3 )) cyl . visual . vertex_colors = np . repeat ( [( 100 , 100 , 100 , 255 ),], cyl . vertices . shape [ 0 ], axis = 0 ) bond_label = f \"bond_ { molecule . labels [ a ] } _ { molecule . labels [ b ] } \" meshes [ bond_label ] = cyl return meshes","title":"molecule_to_meshes()"},{"location":"API/util/mesh/#chmpy.util.mesh.save_mesh","text":"Save the given Trimesh to a file. Parameters: Name Type Description Default mesh trimesh.Trimesh The mesh to save. required filename str The path to the destination file. required Source code in chmpy/util/mesh.py 6 7 8 9 10 11 12 13 14 15 16 17 18 def save_mesh ( mesh , filename ): \"\"\" Save the given Trimesh to a file. Args: mesh (trimesh.Trimesh): The mesh to save. filename (str): The path to the destination file. \"\"\" ext = filename . split ( \".\" )[ - 1 ] with open ( filename , \"wb\" ) as f : mesh . export ( f , ext ) LOG . debug ( \"Saved mesh %s to %s \" , mesh , filename )","title":"save_mesh()"},{"location":"API/util/num/","text":"cartesian_product ( * arrays ) Efficiently calculate the Cartesian product of the provided vectors A x B x C ... etc. This will maintain order in loops from the right most array. Parameters: Name Type Description Default *arrays array_like 1D arrays to use for the Cartesian product () Returns: Type Description ndarray np.ndarray: The Cartesian product of the provided vectors. Source code in chmpy/util/num.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def cartesian_product ( * arrays ) -> np . ndarray : \"\"\" Efficiently calculate the Cartesian product of the provided vectors A x B x C ... etc. This will maintain order in loops from the right most array. Args: *arrays (array_like): 1D arrays to use for the Cartesian product Returns: np.ndarray: The Cartesian product of the provided vectors. \"\"\" arrays = [ np . asarray ( a ) for a in arrays ] la = len ( arrays ) dtype = np . result_type ( * arrays ) arr = np . empty ([ len ( a ) for a in arrays ] + [ la ], dtype = dtype ) for i , a in enumerate ( np . ix_ ( * arrays )): arr [ ... , i ] = a return arr . reshape ( - 1 , la ) is_perfect_square ( value ) Check if a number is perfect square. Parameters: Name Type Description Default value Number the number in question required Returns: Type Description bool bool: True if the number is a perfect square, otherwise False Source code in chmpy/util/num.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def is_perfect_square ( value : Number ) -> bool : \"\"\" Check if a number is perfect square. Args: value (Number): the number in question Returns: bool: `True` if the number is a perfect square, otherwise `False` \"\"\" import math root = math . sqrt ( value ) if int ( root + 0.5 ) ** 2 == value : return True else : return False kabsch_rotation_matrix ( A , B ) Calculate the optimal rotation matrix R to rotate A onto B , minimising root-mean-square deviation so that this may be then calculated. See: https://en.wikipedia.org/wiki/Kabsch_algorithm Reference: Kabsch, W. Acta Cryst. A, 32, 922-923, (1976) DOI: http://dx.doi.org/10.1107/S0567739476001873 Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description np.ndarray (D,D) rotation matrix where D is the dimension of each vector Source code in chmpy/util/num.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def kabsch_rotation_matrix ( A , B ): \"\"\" Calculate the optimal rotation matrix `R` to rotate `A` onto `B`, minimising root-mean-square deviation so that this may be then calculated. See: https://en.wikipedia.org/wiki/Kabsch_algorithm Reference: ``` Kabsch, W. Acta Cryst. A, 32, 922-923, (1976) DOI: http://dx.doi.org/10.1107/S0567739476001873 ``` Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: np.ndarray (D,D) rotation matrix where D is the dimension of each vector \"\"\" # Calculate the covariance matrix cov = np . dot ( np . transpose ( A ), B ) # Use singular value decomposition to calculate # the optimal rotation matrix v , s , w = np . linalg . svd ( cov ) # check the determinant to ensure a right-handed # coordinate system if ( np . linalg . det ( v ) * np . linalg . det ( w )) < 0.0 : s [ - 1 ] = - s [ - 1 ] v [:, - 1 ] = - v [:, - 1 ] R = np . dot ( v , w ) return R reorient_points ( A , B , method = 'kabsch' ) Rotate the points in A onto B Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector, now rotated to align with B Source code in chmpy/util/num.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def reorient_points ( A , B , method = \"kabsch\" ): \"\"\" Rotate the points in `A` onto `B` Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: np.ndarray: (N,D) matrix where N is the number of vectors and D is the dimension of each vector, now rotated to align with B \"\"\" if method != \"kabsch\" : raise NotImplementedError ( \"Only kabsch algorithm is currently implemented\" ) R = kabsch_rotation_matrix ( A , B ) A = np . dot ( A , R ) return A rmsd_points ( A , B , reorient = 'kabsch' ) Rotate the points in A onto B and calculate their RMSD Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description float root mean squared deviation Source code in chmpy/util/num.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def rmsd_points ( A , B , reorient = \"kabsch\" ): \"\"\" Rotate the points in `A` onto `B` and calculate their RMSD Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: float: root mean squared deviation \"\"\" if reorient : A = reorient_points ( A , B , method = reorient ) diff = B - A return np . sqrt ( np . vdot ( diff , diff ) / diff . shape [ 0 ]) spherical_to_cartesian ( rtp , dtype =< class ' numpy . float64 '>) Given an N by 3 array of (r, theta, phi) spherical coordinates return an N by 3 array of Cartesian(x, y, z) coordinates. Uses the following convention:: x = r sin(theta) cos(phi) y = r sin(theta) sin(phi) z = r cos(theta) Parameters: Name Type Description Default rtp ndarray (N,3) array of of r, theta, phi coordinates in the above spherical coordinate system. required dtype numpy datatype or string <class 'numpy.float64'> Returns: Type Description ndarray np.ndarray: (N,3) array of x,y,z Cartesian coordinates Source code in chmpy/util/num.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def spherical_to_cartesian ( rtp : np . ndarray , dtype = np . float64 ) -> np . ndarray : \"\"\" Given an N by 3 array of (r, theta, phi) spherical coordinates return an N by 3 array of Cartesian(x, y, z) coordinates. Uses the following convention:: x = r sin(theta) cos(phi) y = r sin(theta) sin(phi) z = r cos(theta) Args: rtp (array_like): (N,3) array of of r, theta, phi coordinates in the above spherical coordinate system. dtype: numpy datatype or string Returns: np.ndarray: (N,3) array of x,y,z Cartesian coordinates \"\"\" xyz = np . empty ( rtp . shape , dtype = dtype ) xyz [:, 0 ] = rtp [:, 0 ] * np . sin ( rtp [:, 1 ]) * np . cos ( rtp [:, 2 ]) xyz [:, 1 ] = rtp [:, 0 ] * np . sin ( rtp [:, 1 ]) * np . sin ( rtp [:, 2 ]) xyz [:, 2 ] = rtp [:, 0 ] * np . cos ( rtp [:, 1 ]) return xyz","title":"Numerics"},{"location":"API/util/num/#chmpy.util.num","text":"","title":"chmpy.util.num"},{"location":"API/util/num/#chmpy.util.num.cartesian_product","text":"Efficiently calculate the Cartesian product of the provided vectors A x B x C ... etc. This will maintain order in loops from the right most array. Parameters: Name Type Description Default *arrays array_like 1D arrays to use for the Cartesian product () Returns: Type Description ndarray np.ndarray: The Cartesian product of the provided vectors. Source code in chmpy/util/num.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def cartesian_product ( * arrays ) -> np . ndarray : \"\"\" Efficiently calculate the Cartesian product of the provided vectors A x B x C ... etc. This will maintain order in loops from the right most array. Args: *arrays (array_like): 1D arrays to use for the Cartesian product Returns: np.ndarray: The Cartesian product of the provided vectors. \"\"\" arrays = [ np . asarray ( a ) for a in arrays ] la = len ( arrays ) dtype = np . result_type ( * arrays ) arr = np . empty ([ len ( a ) for a in arrays ] + [ la ], dtype = dtype ) for i , a in enumerate ( np . ix_ ( * arrays )): arr [ ... , i ] = a return arr . reshape ( - 1 , la )","title":"cartesian_product()"},{"location":"API/util/num/#chmpy.util.num.is_perfect_square","text":"Check if a number is perfect square. Parameters: Name Type Description Default value Number the number in question required Returns: Type Description bool bool: True if the number is a perfect square, otherwise False Source code in chmpy/util/num.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def is_perfect_square ( value : Number ) -> bool : \"\"\" Check if a number is perfect square. Args: value (Number): the number in question Returns: bool: `True` if the number is a perfect square, otherwise `False` \"\"\" import math root = math . sqrt ( value ) if int ( root + 0.5 ) ** 2 == value : return True else : return False","title":"is_perfect_square()"},{"location":"API/util/num/#chmpy.util.num.kabsch_rotation_matrix","text":"Calculate the optimal rotation matrix R to rotate A onto B , minimising root-mean-square deviation so that this may be then calculated. See: https://en.wikipedia.org/wiki/Kabsch_algorithm Reference: Kabsch, W. Acta Cryst. A, 32, 922-923, (1976) DOI: http://dx.doi.org/10.1107/S0567739476001873 Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description np.ndarray (D,D) rotation matrix where D is the dimension of each vector Source code in chmpy/util/num.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def kabsch_rotation_matrix ( A , B ): \"\"\" Calculate the optimal rotation matrix `R` to rotate `A` onto `B`, minimising root-mean-square deviation so that this may be then calculated. See: https://en.wikipedia.org/wiki/Kabsch_algorithm Reference: ``` Kabsch, W. Acta Cryst. A, 32, 922-923, (1976) DOI: http://dx.doi.org/10.1107/S0567739476001873 ``` Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: np.ndarray (D,D) rotation matrix where D is the dimension of each vector \"\"\" # Calculate the covariance matrix cov = np . dot ( np . transpose ( A ), B ) # Use singular value decomposition to calculate # the optimal rotation matrix v , s , w = np . linalg . svd ( cov ) # check the determinant to ensure a right-handed # coordinate system if ( np . linalg . det ( v ) * np . linalg . det ( w )) < 0.0 : s [ - 1 ] = - s [ - 1 ] v [:, - 1 ] = - v [:, - 1 ] R = np . dot ( v , w ) return R","title":"kabsch_rotation_matrix()"},{"location":"API/util/num/#chmpy.util.num.reorient_points","text":"Rotate the points in A onto B Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector, now rotated to align with B Source code in chmpy/util/num.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def reorient_points ( A , B , method = \"kabsch\" ): \"\"\" Rotate the points in `A` onto `B` Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: np.ndarray: (N,D) matrix where N is the number of vectors and D is the dimension of each vector, now rotated to align with B \"\"\" if method != \"kabsch\" : raise NotImplementedError ( \"Only kabsch algorithm is currently implemented\" ) R = kabsch_rotation_matrix ( A , B ) A = np . dot ( A , R ) return A","title":"reorient_points()"},{"location":"API/util/num/#chmpy.util.num.rmsd_points","text":"Rotate the points in A onto B and calculate their RMSD Parameters: Name Type Description Default A np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required B np.ndarray (N,D) matrix where N is the number of vectors and D is the dimension of each vector required Returns: Type Description float root mean squared deviation Source code in chmpy/util/num.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def rmsd_points ( A , B , reorient = \"kabsch\" ): \"\"\" Rotate the points in `A` onto `B` and calculate their RMSD Args: A (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector B (np.ndarray): (N,D) matrix where N is the number of vectors and D is the dimension of each vector Returns: float: root mean squared deviation \"\"\" if reorient : A = reorient_points ( A , B , method = reorient ) diff = B - A return np . sqrt ( np . vdot ( diff , diff ) / diff . shape [ 0 ])","title":"rmsd_points()"},{"location":"API/util/num/#chmpy.util.num.spherical_to_cartesian","text":"Given an N by 3 array of (r, theta, phi) spherical coordinates return an N by 3 array of Cartesian(x, y, z) coordinates. Uses the following convention:: x = r sin(theta) cos(phi) y = r sin(theta) sin(phi) z = r cos(theta) Parameters: Name Type Description Default rtp ndarray (N,3) array of of r, theta, phi coordinates in the above spherical coordinate system. required dtype numpy datatype or string <class 'numpy.float64'> Returns: Type Description ndarray np.ndarray: (N,3) array of x,y,z Cartesian coordinates Source code in chmpy/util/num.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def spherical_to_cartesian ( rtp : np . ndarray , dtype = np . float64 ) -> np . ndarray : \"\"\" Given an N by 3 array of (r, theta, phi) spherical coordinates return an N by 3 array of Cartesian(x, y, z) coordinates. Uses the following convention:: x = r sin(theta) cos(phi) y = r sin(theta) sin(phi) z = r cos(theta) Args: rtp (array_like): (N,3) array of of r, theta, phi coordinates in the above spherical coordinate system. dtype: numpy datatype or string Returns: np.ndarray: (N,3) array of x,y,z Cartesian coordinates \"\"\" xyz = np . empty ( rtp . shape , dtype = dtype ) xyz [:, 0 ] = rtp [:, 0 ] * np . sin ( rtp [:, 1 ]) * np . cos ( rtp [:, 2 ]) xyz [:, 1 ] = rtp [:, 0 ] * np . sin ( rtp [:, 1 ]) * np . sin ( rtp [:, 2 ]) xyz [:, 2 ] = rtp [:, 0 ] * np . cos ( rtp [:, 1 ]) return xyz","title":"spherical_to_cartesian()"},{"location":"API/util/text/","text":"natural_sort_key ( s , _nsre = re . compile ( '([a-zA-Z]+)( \\\\ d+)' )) Utility function for sorting strings of the form A1, B_2, A12 etc. so that the suffixes will be in numeric order rather than lexicographical order. Parameters: Name Type Description Default s str the string whose sort key to determine required Returns: Type Description tuple the (str, int) natural sort key for the provided string Source code in chmpy/util/text.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def natural_sort_key ( s : str , _nsre = re . compile ( r \"([a-zA-Z]+)(\\d+)\" )): \"\"\" Utility function for sorting strings of the form A1, B_2, A12 etc. so that the suffixes will be in numeric order rather than lexicographical order. Args: s (str): the string whose sort key to determine Returns: tuple: the (str, int) natural sort key for the provided string \"\"\" m = _nsre . match ( s ) if not m : return s c , i = m . groups ( 0 ) return ( c , int ( i )) overline ( x ) Add a unicode overline modifier to the provided string. Parameters: Name Type Description Default x str the string to be overlined required Returns: Type Description str str: the overlined string Source code in chmpy/util/text.py 88 89 90 91 92 93 94 95 96 97 98 99 def overline ( x : str ) -> str : \"\"\" Add a unicode overline modifier to the provided string. Args: x (str): the string to be overlined Returns: str: the overlined string \"\"\" return f \" \\u0305 { x } \" subscript ( x ) Convert the provided string to its subscript equivalent in unicode Parameters: Name Type Description Default x str the string to be converted required Returns: Type Description str str: the converted string Source code in chmpy/util/text.py 74 75 76 77 78 79 80 81 82 83 84 85 def subscript ( x : str ) -> str : \"\"\" Convert the provided string to its subscript equivalent in unicode Args: x (str): the string to be converted Returns: str: the converted string \"\"\" return SUBSCRIPT_MAP . get ( x , x )","title":"Text"},{"location":"API/util/text/#chmpy.util.text","text":"","title":"chmpy.util.text"},{"location":"API/util/text/#chmpy.util.text.natural_sort_key","text":"Utility function for sorting strings of the form A1, B_2, A12 etc. so that the suffixes will be in numeric order rather than lexicographical order. Parameters: Name Type Description Default s str the string whose sort key to determine required Returns: Type Description tuple the (str, int) natural sort key for the provided string Source code in chmpy/util/text.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def natural_sort_key ( s : str , _nsre = re . compile ( r \"([a-zA-Z]+)(\\d+)\" )): \"\"\" Utility function for sorting strings of the form A1, B_2, A12 etc. so that the suffixes will be in numeric order rather than lexicographical order. Args: s (str): the string whose sort key to determine Returns: tuple: the (str, int) natural sort key for the provided string \"\"\" m = _nsre . match ( s ) if not m : return s c , i = m . groups ( 0 ) return ( c , int ( i ))","title":"natural_sort_key()"},{"location":"API/util/text/#chmpy.util.text.overline","text":"Add a unicode overline modifier to the provided string. Parameters: Name Type Description Default x str the string to be overlined required Returns: Type Description str str: the overlined string Source code in chmpy/util/text.py 88 89 90 91 92 93 94 95 96 97 98 99 def overline ( x : str ) -> str : \"\"\" Add a unicode overline modifier to the provided string. Args: x (str): the string to be overlined Returns: str: the overlined string \"\"\" return f \" \\u0305 { x } \"","title":"overline()"},{"location":"API/util/text/#chmpy.util.text.subscript","text":"Convert the provided string to its subscript equivalent in unicode Parameters: Name Type Description Default x str the string to be converted required Returns: Type Description str str: the converted string Source code in chmpy/util/text.py 74 75 76 77 78 79 80 81 82 83 84 85 def subscript ( x : str ) -> str : \"\"\" Convert the provided string to its subscript equivalent in unicode Args: x (str): the string to be converted Returns: str: the converted string \"\"\" return SUBSCRIPT_MAP . get ( x , x )","title":"subscript()"}]}